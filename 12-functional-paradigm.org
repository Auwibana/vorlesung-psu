#+TITLE: Programmiersprachen und Übersetzer
#+SUBTITLE: 12 - Das Funktionale Programmierparadigma
#+SETUPFILE: setup.org
#+INCLUDE: export-prologue.org
#+PROPERTY: header-args:latex :tangle yes :noweb yes :tangle-macros yes :tangle-prologue topic :tangle-epilogue endtopic :exports none

#+NAME: topic
#+BEGIN_SRC latex :tangle no
\psuSectionStart{{{{property(ITEM)}}}}{{{{n(block)}}}}
#+END_SRC

#+NAME: endtopic
#+BEGIN_SRC latex :tangle no
\psuSectionStop{{{{property(ITEM)}}}}{{{{n(block,-)}}}}
#+END_SRC

* Gedanken zu dieser Vorlesung                                     :noexport:
- Was war überhaupt das Problem?
  - Der Zustand von Programmen wird unübersichtlich
  - Alles interagiert irgendwie wie allem anderen

- Einordnung in die anderen Paradigmen

* Freiheit von Seiteneffekten
:PROPERTIES:
:CUSTOM_ID: 12-einleitung
:END:
#+begin_src latex
  \subtitle{{{{subtitle()}}}}
  \maketitleframe

  \begin{frame}{Probleme, Probleme, Probleme,\ldots}
    \bi
    \ii Kleine Programme sind \advantage{einfach}, Große Softwareprojekte sind \alert{schwer}.{
      \bi
      \ii Viele EntwicklerInnen, Viele Standorte, Viele Zeitzonen
      \ii Riesige Codebasis und \structure{interagierende Komponenten}
      \ii Viele Prozeduren (Algorithmen) und viele Objekte (Daten)
      \ei
    }
    \pause 
    \begin{center}
    \includegraphics[width=3.5cm]{fig/12-brain}
  \end{center}

    \ii Begrenzte geistitge Kapazität: \structure{Veränderlicher Zustand} sieht man nicht {
      \bi
      \ii[$\leftrightarrow$] Ausführung von Code ist meist sequentiell und lokal
      \ii Der aktuelle Zustand ist \textbf{Akkumulation aller Änderungen}
      \ii Ohne Einhaltung von Invarianten leicht \alert{unübersichtlich}
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{Funktionen: Prozeduren mit Scheuklappen}
    \mbox{}\hspace{-1.5em}\OrangeBox{(Reine) funktionale Programmierung erhöht die Lokalität von Änderungen}

    \bi
    \ii \structure{Rein Funktional}: Prozeduren werden zu mathematischen Funktionen {
      \bi
      \ii Das Ergebnis einer (echte) Funktion hängt nur von ihren Parametern ab.
      \ii Kein Seitenkanal über den globaler Zustand.
      \ii Funktionsausführung hat \ADVANTAGE{keine Seiteneffekte}!
      \ei
    }

    \begin{center}
      \includegraphics[width=4cm,page=2]{fig/12-function}\hspace{1.5cm}%
      \includegraphics[width=4cm,page=1]{fig/12-function}
    \end{center}

    \bigskip


    \ii<2> Mischformen mit veränderlichem Zustand \hfill\emph{functional style}{
      \bi
      \ii Rein funktionale Programmierung ist auch schwierig
      \ii Viele Programmiersprachen haben \structure{funktionale Elemente}
      \ei
    }
    \ei

  \end{frame}

  \begin{frame}{Verhältnis zu anderen Programmierparadigmen}
    \btAnimation[width=\textwidth]{range=1-3:<1->,center,padding}{fig/12-functional}
  \end{frame}

  \begin{frame}{Direkte Folgen von Seiteneffektfreiheit}
    \bi
    \ii Einige Sprachkonzepte werden sinnlos\ldots {
      \bi
      \ii Wiederbeschreibbare \structure{Variablen} sind veränderlicher Zustand  \hfill $\Rightarrow$ \ALERT{Verboten}
      \ii Veränderbare Objekte wären veränderlicher Zustand                      \hfill $\Rightarrow$ \ALERT{Verboten}
      \ii \structure{Schleifen}iterationen kommunizieren über ihre Seiteneffekte \hfill $\Rightarrow$ \ALERT{Sinnlos}
      \ii Sequenzierte \structure{Statements} haben keinen Rückgabewert          \hfill $\Rightarrow$ \ALERT{Sinnlos}
      \ei
    }\medskip
    \ii<2-> Andere Sprachkonzepte gewinnen an Wichtigkeit! {
      \bi
      \ii \structure{Immutable Objekte}: \btSetTab Werte- und Referenzmodell fallen zusammen!
      \ii \structure{Ausdrücke}:  \btUseTab Jede Operation braucht einen Rückgabewert!
      \ii \structure{Rekursion}:  \btUseTab Wiederholte Ausführungen nur durch Rekursion!
      \ii \structure{Funktionen}: \btUseTab Funktionsaufrufe modelieren abhängigkeiten Operationen!
      \ei
    }\medskip
    \ii<3-> Weitere wichtige Fragen, die direkt aufkommen! {
      \bi
      \ii Wie soll man so bitte übersichtlich programmieren?!
      \ii Wie kann das bitte nicht ineffizient sein?!
      \ii Wie soll ich Ein- und Ausgabe machen?!
      \ei
    }
    \ei
  \end{frame}
#+end_src

* Aufzählungstypen und Pattern Matching

#+begin_src latex
  \dividerframe{Unveränderliche\\Datentypen}

  \begin{frame}[fragile]{Typen für funktionale Programmierung}
    \begin{btBlock}[type=alert]{}
      Viele Datentypen sind darauf ausgelegt, dass ihre Objekte während ihrer Lebenszeit verändert werden. Das haben wir leider \ALERT{verboten}!
    \end{btBlock}

    \bi
    \ii Objekte werden nur initialisiert, aber nie verändert. {
      \bi
      \ii Jede Referenz erlaubt nur das Lesen des Objekts
      \ii "Modifikation" nur über partielle Kopie und parametrisierte Konstruktoren
      \ii Effizienz: Übersetzer kann viele dieser Kopie durch Optimierungen entfernen
      \ei

      \begin{center}
        \begin{minipage}{0.7\linewidth}
          \begin{code}[tag=Pseudocode]
            \begin{lzero}
              func add(a : Point, b : Point) : Point {
                return new Point(a.x+b.x, a.y+b.y);
              }
            \end{lzero}
          \end{code}
        \end{minipage}
      \end{center}
    }
    \ii<2-> Bei hierarchisch verzeigerte Datentypen funktioniert das besonders gut {
      \bi
      \ii \structure{Einfach verkettete Listen}: Vorne anhängen ist leicht
      \ii \structure{Bäume}: Unterbäume können bei einem Knotenupdate übernommen werden
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{Update und Modifikation von Listen}
    \btAnimation[width=0.8\textwidth]{range=1-3:<1->,3:<4->,center,padding=2ex}{fig/12-trees}
  
    \bi
    \ii Funktionale Programmierung arbeitet viel mit einfach verketteten Listen{%
      \bi
      \ii<2-> \structure{Vorne anhängen} erfordert keine Änderung der vorhandenen Listenelemente
      \ii<2-> \structure{Gebundene Namen} bleiben valide und verändern ihren Wert nicht.
      \ii<3-> \structure{Updates} erfordert Elementkopien bis zur Änderungsstelle
      \ei
    }\medskip
    \ii<4-> Einfach verkettete Listen sind eine \ALERT{rekursive} Datenstruktur\\
     $\Rightarrow$ Passt hervorragend zur rekursiven Struktur funktionaler Programme.
    \ei
  \end{frame}

  \begin{frame}[fragile]{Aufzählungstypen mit Nutzlast}
    \OrangeBox{\textbf{Problem:} Wir wollen viele Objekte erzeugen und wieder zerlegen}
    \medskip
    \begin{columns}
      \begin{column}{0.49\textwidth}
        \begin{code}[tag=Rust]
          \begin{onlyenv}<1>
            \begin{rust}
              enum PointKind {
                XY,
                XYZ,
              };
            \end{rust}
          \end{onlyenv}%
          \begin{onlyenv}<2->
            \begin{rust}
              enum Point {
                XY(i32, i32),
                XYZ(i32, i32, i32)
              };
            \end{rust}
          \end{onlyenv}
        \end{code}
      \end{column}\hfill
      \begin{column}<3->{0.49\textwidth}
        \begin{code}[tag=Rust]
          \begin{rust}[style=highlighting]
            @4fn handle(p : Point);@
            let p1 = @3Point::XY@ (0, 3);
            let p2 = @3Point::XYZ@(0, 3, 0)
            @4handle(p1); handle(p2);@
          \end{rust}
        \end{code}
      \end{column}
    \end{columns}

    \bi
    \ii Funktionale Sprachen bieten Aufzählungstypen (\structure{enum}) \only<2->{mit Nutzlast} {
      \bi
      \ii Endliche (aufzählbare) Anzahl an Varianten
      \ii<2-> Jeder Variante kann unterschiedliche Felder mit sich führen.
      \ii<3-> Aufzählungsname wird Konstruktor.
      \ii<4-> Tagged variante Records (\structure{union}) sind typsicher und polymorph
      \ei
    }
    \ii<5-> Rekursiv generisch-polymorphe typsichere Aufzählungstypen {
      \begin{columns}
        \begin{column}{0.49\textwidth}
           \begin{code}[tag=Haskell]
             \begin{haskell}
               data Tree t = Leaf T
                           | Node (Tree t) (Tree t)
               freeTree :: Tree Char
               freeTree = Node
                            (Node
                               (Leaf 'X')
                               (Leaf 'Y'))
                            (Leaf 'Z')
             \end{haskell}
           \end{code}        
        \end{column}\hfill
        \begin{column}{0.49\textwidth}
          \begin{tikzpicture}[
            level distance=10mm,
            every node/.style={draw, font=\scriptsize}
            ]
            
            \node (r){Node}
              child { node {Node}
                child { node (x) {Leaf 'X'}}
                child { node {Leaf 'Y'}}}
              child { node (z){Leaf 'Z'}};

            \node[fit=(r) (x) (z),draw, dashed,
                  pin={[align=center]0:Tree Char\\==\\Ein Baum\\aus Char}] {};
          \end{tikzpicture}
        \end{column}
      \end{columns}
    }
    \ei
  \end{frame}

  \begin{frame}[fragile]{Destructuring Bind und Pattern Matching}
    \OrangeBox{Deklaration und Konstruktion von Aufzählungsobjekten ist sehr kompakt.}
    \bi
    \ii<2-> \structure{Destructuring Bind}: Zerlegen eines Objekts in seine Einzelteile {
      \bi
      \ii Muster mit der gleichen Struktur aber freien Namen
      \ii Objekt wird auf dieses Muster aufgeteilt
      \ii Freie Namen werden werden an die zerlegten Subobjekte gebunden
      \ei
      \medskip
      \begin{columns}
        \begin{column}{0.49\textwidth}
          \begin{code}[tag=Rust]
            \begin{rust}
              struct ObjT { a : i32, b : i32 }
              let ObjT {a: y0, b: y1} = obj;
            
              let (x0, x1) = (1, 2);
            \end{rust}
          \end{code}
        \end{column}\hfill
        \begin{column}<3->{0.49\textwidth}
          \begin{code}[tag=Rust]
            \begin{rust}
              let norm = match p1 {
                Point::XYZ(x,y,z) => x+y+z,
                Point::XY (x,y)   => x+y,
              }
            \end{rust}
          \end{code}
        \end{column}
      \end{columns}
    }\medskip
    \ii<3-> \structure{Pattern Matching}: Selektionsoperation mittels Destructuring Bind{
      \bi
      \ii Ähnlich, aber mächtiger wie ein switch-case in C
      \ii Vergleich eines Objekts gegen mehrere Muster und Destructuring Bind
      \ii Der entsprechende Arm wird mit den gebundenen Namen ausgeführt
      \ii Semantische Analyse kann prüfen ob alle Fälle abgedeckt sind
      \ei
    }
    \ei
  \end{frame}
#+end_src

* Funktionen als Bürger erster Klasse

#+begin_src latex
  \dividerframe{Funktionen als \\Bürger erster Klasse}

  \begin{frame}{Funktionen erster und höherer Ordnung}
    \btAnimation[width=0.7\textwidth]{range=1-3:<1->,center,padding}{fig/12-function-universe.pdf}

    \bi
    \ii \textbf{Bisher:} Wir hatten hauptsächlich \structure{Funktionen erster Ordnung} {
      \bi
      \ii Funktionen und Objekte sind zwei getrennte Universen
      \ii<2-> Funktionsanwendung kombiniert eine Funktion und mehrere Objekte\\[2ex]
      \ii<2->[$\Rightarrow$] Definition: Funktion erster Ordnung hat nur passive Objekte als Argument
      \ei
    }
    \medskip
    \ii<3-> \structure{Funktionen höhrerer Ordnung} haben Funktionen als Parameter{
      \bi
      \ii Viele Imperative Sprachen bieten bereits Funktionszeiger
      \ii \ALERT{Aber:} Funktionen sind immer noch nicht wirklich gleichberechtigt! 
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{First-Class Functions}
    \begin{center}
      \btAnimation[width=0.65\textwidth]{range=4-5:<1-end>}{fig/12-function-universe.pdf}
    \end{center}


    \bi
    \ii Im funktionalen Paradigma sind Funktionen wirklich gleichberechtigt {
      \bi
      \ii Keine kategorieller Unterschied zwischen Funktionen und Objekten
      \ii<2-> Funktionen können Argument \textbf{und} Rückggabewert sein!
      \ei
    }\medskip
    \ii<3-> Funktionen sind \ADVANTAGE{WIRKLICH} gleichberechtigt! {
      \bi
      \ii Funktionen können während der Laufzeit neu erzeugt werden.
      \ii Funktionen können komponiert und partiell angewendet werden.
      \ei
    }
    \ei

    \uncover<4->{\Large $\Rightarrow$ \btSetTab Im funktionale Paradigma werden die\\
                            \btUseTab algorithmischen Aspekte einer Sprache gestärkt!}
    \end{frame}
#+end_src


#+begin_src latex
  \dividerframe{Funktionales Programmieren}

  \begin{frame}[fragile]{Funktionen als Argumente}
    \begin{btBlock}{}
      Obwohl Python keine rein(!) funktionale Programmiersprache ist, werde ich die Beispiele, soweit es geht, als Python Code zeigen.
    \end{btBlock}
    \bigskip

    \bi
    \ii Funktionen höherer Ordnung können \structure{Auswertungsstrategien} abstrahieren{%
      \bi
      \ii \enquote{Äußere} Funktion steuert die Auswertung, die Übergebene macht die Arbeit.
      \ii Die übergebene Funktion kann mehrfach und mit unterschiedlichen Parametern aufgerufen werden. Die Ergebnisse können kombiniert werden.
      \ii Die Auswertestrategie ist parametrisierbar und wird so \advantage{wiederverwendbar}!{\\\medskip
      \begin{columns}
        \begin{column}{0.49\textwidth}
          \begin{code}[]
            \begin{py}
              def outer(fn, arr):
                  return fn(arr[0]) + fn(arr[1])

                  outer(innerA, [23, 42]) # => 6500
                  outer(innerB, [23, 42]) # => -65
            \end{py}
          \end{code}
        \end{column}\hfill
        \begin{column}{0.49\textwidth}
          \begin{code}[]
            \begin{py}
              def innerA(x):
                  return x * 100
                
              def innerB(x):
                  return x * -1
            \end{py}
          \end{code}
        \end{column}
      \end{columns}
    }\medskip
    \ii Wir hatten dies bereits bei \texttt{traverse()} und \texttt{fixpoint()} benutzt.
    \ei
    }\medskip

    \ei
  \end{frame}

  \begin{frame}[fragile]{$\lambda$/Lambda: Anonyme Funktionen}
    \bi
    \ii Bei funktionaler Programmierung braucht man ständig kleine Funktionen{%
      \bi
      \ii Entfernte Funktionsdefinition an anderer Stelle zerstört die Code-Lokalität
      \ii Außerdem ist es aufwändig sich ständig neue Funktionsnamen auszudenken
      \ei
    }\medskip
    \begin{center}
      \uncover<2->{\includegraphics[page=1,width=0.6\textwidth]{fig/12-lambda}}
    \end{center}
    \ii<2-> \textbf{Lösung}: \structure{Lambda-Ausdrücke} erzeugen ein Funktionsobjekt ohne Namen{
      \bi
      \ii Inspiriert vom, aber nicht immer äquivalent zum, Lambda-Kalkül
      \ii Bestandteile: Parameterliste und \textbf{ein} Ausdruck
      \ii Funktionsobjekt kann später aufgerufen werden
      \ei
    }
    \ei
    \begin{columns}<2->
      \begin{column}{0.65\textwidth}
        \begin{code}[]
          \begin{py}
            outer(lambda x: x * 100, [23,42]) # => 6500
            outer(lambda x: x * -1,  [23,42]) # => -65          
          \end{py}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.31\textwidth}
        \begin{code}[]
          \begin{py}
            add = lambda x, y: x+y
            add(1,2) # => 3      
          \end{py}
        \end{code}
      \end{column}\hfill\mbox{}
    \end{columns}

  \end{frame}

  \begin{frame}{Beispiel: Listenmanipulationen}
    \bi
    \ii Listen sind die funktionale \enquote{Brot-und-Butter} Datenstruktur{
      \bi
      \ii Funktionen höherer Ordnung bieten standardisierte Auswertungsstrategien
      \ii Diese Funktionen ersetzen teilweise iterative Sprachelemente
      \ei
    }
    \ei

    \medskip
    \begin{columns}[t]
      \begin{column}<2->{0.32\textwidth}
        \includegraphics[width=\textwidth,page=1]{fig/12-list-manipulation}
      
        \medskip
        { \small
          \codebox{map()} bildet jedes Element mit Hilfe der übergebenen Funktion ab und konstruiert daraus eine neue Ergebnisliste.}

      \end{column}\hfill
      \begin{column}<3->{0.32\textwidth}
        \includegraphics[width=\textwidth,page=2]{fig/12-list-manipulation}


        \medskip
        { \small
          \codebox{filter()} prüft jedes Element mittels einem Prädikat und konstruiert eine Liste \enquote{erfolgreichen} Elementen.}

      \end{column}\hfill
      \begin{column}<4->{0.32\textwidth}
        \includegraphics[width=\textwidth,page=3]{fig/12-list-manipulation}

        \medskip
        { \small
          \codebox{reduce()} reduziert eine Liste zu einem Wert indem die übergebene Funktion als Infixoperator angewendet wird.}
      \end{column}
    \end{columns}
  \end{frame}

  \begin{frame}[fragile]{Komposition von Funktionen}

    \bi
    \ii \structure{Funktionskomposition} ist die Hintereinanderausführung von Funktionen{
      \bi
      \ii Aus zwei Funktionsobjekten kreieren wir ein neues Funktionsobjekt
      \ii Die neue Funktion wendet beide Funktionen in Reihe an.\\
          Das Ergebnis der ersten wird zur Eingabe der zweiten.
      \ii Rückgabetypen und Parametertypen müssen zueinander passen
      \ei
    }
    \ei

    \begin{center}
      \includegraphics[page=1,width=0.8\textwidth]{fig/12-composition}
    \end{center}

  \begin{columns}
    \begin{column}{0.49\textwidth}
      \begin{code}[tag=Python]
        \begin{py}
          def inc(x):
             return x + 1

          def compose(f, g):
             return lambda x: f(g(x))
           
          x = compose(inc, inc)
          x(0) # => 2
        \end{py}
      \end{code}
    \end{column}\hfill
    \begin{column}{0.49\textwidth}
      \begin{code}[tag=Haskell]
        \begin{haskell}
          inc = \x -> x +1
          x   = x . x
        
          x(0) # => 2
        \end{haskell}
      \end{code}
    
      Haskell bietet Komposition sogar als \structure{Infixoperator} \enquote{.}, angelehnt an $f \circ g$:
    \end{column}
  \end{columns}


  \end{frame}

  \begin{frame}{Partielle Anwendung von Funktionen}
  
  \end{frame}


  \begin{frame}{Beispiel: Eine Verarbeitungskette}
  
  \end{frame}


#+end_src
* Monaden

* Zusammenfassung
