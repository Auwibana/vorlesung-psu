#+TITLE: Programmiersprachen und Übersetzer
#+SUBTITLE: 12 - Das Funktionale Programmierparadigma
#+SETUPFILE: setup.org
#+INCLUDE: export-prologue.org
#+PROPERTY: header-args:latex :tangle yes :noweb yes :tangle-macros yes :tangle-prologue topic :tangle-epilogue endtopic :exports none

#+NAME: topic
#+BEGIN_SRC latex :tangle no
\psuSectionStart{{{{property(ITEM)}}}}{{{{n(block)}}}}
#+END_SRC

#+NAME: endtopic
#+BEGIN_SRC latex :tangle no
\psuSectionStop{{{{property(ITEM)}}}}{{{{n(block,-)}}}}
#+END_SRC

* Gedanken zu dieser Vorlesung                                     :noexport:
- Was war überhaupt das Problem?
  - Der Zustand von Programmen wird unübersichtlich
  - Alles interagiert irgendwie wie allem anderen

- Einordnung in die anderen Paradigmen

* Freiheit von Seiteneffekten
:PROPERTIES:
:CUSTOM_ID: 12-einleitung
:END:
#+begin_src latex
  \subtitle{{{{subtitle()}}}}
  \maketitleframe

  \begin{frame}{Probleme, Probleme, Probleme,\ldots}
    \bi
    \ii Kleine Programme sind \advantage{einfach}, Große Softwareprojekte sind \alert{schwer}.{
      \bi
      \ii Viele EntwicklerInnen, Viele Standorte, Viele Zeitzonen
      \ii Riesige Codebasis und \structure{interagierende Komponenten}
      \ii Viele Prozeduren (Algorithmen) und viele Objekte (Daten)
      \ei
    }
    \pause 
    \begin{center}
    \includegraphics[width=3.5cm]{fig/12-brain}
  \end{center}

    \ii Begrenzte geistitge Kapazität: \structure{Veränderlicher Zustand} sieht man nicht {
      \bi
      \ii[$\leftrightarrow$] Ausführung von Code ist meist sequentiell und lokal
      \ii Der aktuelle Zustand ist \textbf{Akkumulation aller Änderungen}
      \ii Ohne Einhaltung von Invarianten leicht \alert{unübersichtlich}
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{Funktionen: Prozeduren mit Scheuklappen}
    \mbox{}\hspace{-1.5em}\OrangeBox{(Reine) funktionale Programmierung erhöht die Lokalität von Änderungen}

    \bi
    \ii \structure{Rein Funktional}: Prozeduren werden zu mathematischen Funktionen {
      \bi
      \ii Das Ergebnis einer (echte) Funktion hängt nur von ihren Parametern ab.
      \ii Kein Seitenkanal über den globaler Zustand.
      \ii Funktionsausführung hat \ADVANTAGE{keine Seiteneffekte}!
      \ei
    }

    \begin{center}
      \includegraphics[width=4cm,page=2]{fig/12-function}\hspace{1.5cm}%
      \includegraphics[width=4cm,page=1]{fig/12-function}
    \end{center}

    \bigskip


    \ii<2> Mischformen mit veränderlichem Zustand \hfill\emph{functional style}{
      \bi
      \ii Rein funktionale Programmierung ist auch schwierig
      \ii Viele Programmiersprachen haben \structure{funktionale Elemente}
      \ei
    }
    \ei

  \end{frame}

  \begin{frame}{Verhältnis zu anderen Programmierparadigmen}
    \btAnimation[width=\textwidth]{range=1-3:<1->,center,padding}{fig/12-functional}
  \end{frame}

  \begin{frame}{Direkte Folgen von Seiteneffektfreiheit}
    \bi
    \ii Einige Sprachkonzepte werden sinnlos\ldots {
      \bi
      \ii Wiederbeschreibbare \structure{Variablen} sind veränderlicher Zustand  \hfill $\Rightarrow$ \ALERT{Verboten}
      \ii Veränderbare Objekte wären veränderlicher Zustand                      \hfill $\Rightarrow$ \ALERT{Verboten}
      \ii \structure{Schleifen}iterationen kommunizieren über ihre Seiteneffekte \hfill $\Rightarrow$ \ALERT{Sinnlos}
      \ii Sequenzierte \structure{Statements} haben keinen Rückgabewert          \hfill $\Rightarrow$ \ALERT{Sinnlos}
      \ei
    }\medskip
    \ii<2-> Andere Sprachkonzepte gewinnen an Wichtigkeit! {
      \bi
      \ii \structure{Immutable Objekte}: \btSetTab Werte- und Referenzmodell fallen zusammen!
      \ii \structure{Ausdrücke}:  \btUseTab Jede Operation braucht einen Rückgabewert!
      \ii \structure{Rekursion}:  \btUseTab Wiederholte Ausführungen nur durch Rekursion!
      \ii \structure{Funktionen}: \btUseTab Funktionsaufrufe modelieren abhängigkeiten Operationen!
      \ei
    }\medskip
    \ii<3-> Weitere wichtige Fragen, die direkt aufkommen! {
      \bi
      \ii Wie soll man so bitte übersichtlich programmieren?!
      \ii Wie kann das bitte nicht ineffizient sein?!
      \ii Wie soll ich Ein- und Ausgabe machen?!
      \ei
    }
    \ei
  \end{frame}
#+end_src


Wir haben die letzte Vorlesung mit das objektorientierten Paradigmas besprochen und mit einer Kritik beendet.
Angetreten ist dieses Paradigma und die damit verbundenen Designprinzipien um Softwareentwicklung "im Großen", als in großen Softwareprojekten an denen viele Menschen arbeiten, möglich zu machen. Und in dieser Hinsicht hat das OO Paradigma einiges geleistetet. Wir sind mit aktuellen Entwicklungsmodellen in der Lage viel viel größere Softwareprojekte zu realisieren, als wir das noch vor 40 Jahren waren. Teilweise ist das auf schnellere Hardware, was zu schnelleren Compile-Test-Zyklen führt, zurückzuführen, aber das bessere Verständnis für die Probleme, die erst in großen Projekten sichtbar werden, hat ebenso dazu beigetragen. Die Modelierung von Software entlang den Objekten, die sie versucht abzubilden, erleichtert es uns Menschen darüber zu reden. Aber, wie wir gesehen haben, das OO Paradigma ist nicht ohne Kritik. 

Der grundlegende Konflikt der bei der Softwareentwicklung großer Projekte auftritt ist, dass ein solches Projekt viele Interagierende Entitäten hat: Auf der Ebene der Entwicklung haben wir viele Menschen, die, verstreut über den ganzen Erdball, gemeinsam an einer Software arbeiten wollen. Dies erfordert einiges an Koordination, aber auch an Kommunikation; die Menschen müssen sich in ihrer Sprache über die Struktur der Software austauschen können (Hier hat OO einiges geleistet). Auf der Ebene der Software haben wir ebenfalls viele interagierende Entitäten: Viele Module enthalten eine vielzahl an Klassen, von denen Objekte instantiiert werden, die alle einen Zustand haben (Persistenz!) und sich gegenseitig Nachrichten zuschicken (Methodenaufruf!). Diese technische Komplexität kommt dann mit der begrenzten geistigen Kapazität von Menschen zusammen: Wir müssen Sie verstehen um sie beherschen zu können und um sie anderen mitteilen zu können.

Jetzt gibt es aber eine Kluft zwischen dem Quellcode, der die Klassen definiert, und dem Universum instantiierter Objekte ein Problem: Im Gegensatz zu statischen Codestrukturen sieht man den dynamischen Zustand nicht. Wo der Quellcode, durch die Verwendung des imperativen Paradigmas, relativ lokal abläuft (Eine Zeile nach der anderen), ist der dynamische Zustand viel schwierige zu fassen. Denn der Zustand eines Objektes ist die Kombination aller Änderungen, die dieses Objekt seit seiner Geburt{{{see(06-birth,Geburt von Objekten)}}} erfahren hat. Wir versuchen diesen dynamischen Zustand besser fassbar zu machen, indem wie **Invarianten** einführen, die den Raum möglicher Belegungen eingrenzt. Aber selbst mit guten Invarianten, müssen wir bei der Entwicklung immer die möglichen Zustände des Objektuniversums in unseren Köpfen nachvollziehen. Allzuhäufig fallen dabei die Randfälle, also da wo Objekte gerade noch die Invarianten einhalten, hinten runter und führen zu Softwarefehlern.

Es ist dieses Problem des Zustandsraums, dem sich das **funktionale Paradigma** annimmt.
Mit diesem Paradigma **eliminieren** wir den **veränderlichen Zustand**.
Lesen Sie den letzten Satz noch einmal, atmen Sie tief durch, und versuchen Sie die tragweite dieser Entscheidung zu verstehen.
Wir verbieten die Veränderung von Zustand[fn::Lassen Sie uns das gleich ein bisschen einschränken:
Nur das reine funktionale Paradigma geht in dieser Radikalität gegen veränderlichen Zustand vor.
Nur wenige Sprachen ziehen dies zum extrem durch.
Aber selbst abgeschwächte Formen führen zu einem völlig veränderten Nachdenken über Programmiersprachen.
Bleiben Sie also dabei, wenn wir jetzt einmal das Extrem ausloten].
Dieser radikale Schritt hat eine ganze Reihe von Implikationen, denen wir uns jetzt widmen werden, bevor wir darüber reden, wie man mit einer solch eingeschränkten Sprache nützliche Programme entwerfen kann.

Zunächst müssen wir uns einmal überlegen, was der Zustand eines Programs ist. All die Variablen die wir haben, die lokalen, die globalen, und die einzelnen Parameter von Funktionsinstanzen. All das ist Zustand. Aber auch die Objekte, die wir nur indirekt über diese Variablen über Referenzen erreichen können{{{see(06-garbage-collection,Mark-and-Sweep Garbage Collector)}}}, sind der Zustand eines Programms. Immer wenn wir ein existierendes Objekt verändern, dann benötigen wir das Sprachkonzept "veränderlicher Zustand". Jedes Beschreiben eines Record-Felds, jedes Setzen eines Array-Elements, jedes Verändern einer Variable, all das verändert den existierenden Zustand. All das wollen wir verbieten. Einzig zwei Dinge werden uns gelassen: Wir können neue Objekte parametrisiert erzeugen, und wir können einen bisher ungebundenen Namen an ein existierendes Objekt binden. Etwas flapsiger, und ungenau, ausgedrückt, würde man sagen: Variablen können nicht überschrieben, Objekte nicht verändert werden.

Was hat diese Einschränkung zur Folge? Eine ganze Menge! Bei der Diskussion der Operationen{{{see(07-operation-dependencies,Operationen und Seiteneffekte)}}} und ihrer Abhängigkeiten haben wir den Begriff der Seiteneffekte eingeführt. Ein Seiteneffekt einer Operation führt dazu, dass die Operation über ihren Rückggabewert hinaus, den Zustand der virtuellen Maschine verändert. Und es sind genau dies Seiteneffekte, die wir bei der funktionalen Programmierung verbieten werde.

Durch Seiteneffekte und globalen Zustand kann eine Prozedur Zustand besitzen und bei wiederholten Aufruf mit den selben Argumenten, jedesmal ein anderes Ergebnis liefern. Der globale Zustand, bzw. jeder andere veränderbare Ausführungskontext, agiert in solchen Situationen als **Seitenkanal** für die Prozedur:

#+begin_src python
counter = 0
def inc():
    global counter
    counter += 1
    return counter

print [inc(), inc(), inc()]
#+end_src

Wenn wir nun Prozeduren mit mathematischen Funktionen vergleichen, sehen wir, dass es hier eine Lücke gibt. Solche Prozeduren, die ihren Ausführungskontext verändern, sind keine Funktionen im mathematischen Sinne, da ihr Ergebnis nicht nur von ihren Eingabeparametern abhängt. Stellen Sie sich das einmal vor, wie das wäre, wenn die Addition in einem Ganzzahlring jedes mal ein anderes Ergebnis liefern würde. So könnte ja niemand Mathematik machen! Aber in der Programmierung erlauben wir uns das, wenn wir veränderlichen Zustand haben.

Mit dem funktionalen Paradigma werden Prozeduren also zu echten mathematischen Funktionen, deren Ergebnis nur noch von den übergebenen Argumenten abhängt. Die Ausführung einer solchen Funktion hat **keine Seitenffekte** und wir können Sie beliebig oft aufrufen, es wird immer das gleiche das gleiche dabei raus kommen. Auf diese Weise schafft es das funktionale Paradigma, dass nicht nur die Ausführung von Quellcode lokal ist, sondern auch, dass der Zustandsraum lokaler wird. Dies erleichtert es ungemein über die Korrektheit eines Programms nachzudenken. 

Vergleichen wir die drei Paradigmen, die wir in dieser Vorlesung besprechen, so sehen wir eine Entwicklung in zwei Richtungen, ausgehend vom imperativen Paradigma. Dieses grundlegende Paradigma hat vier Elemente: Sequenzierung, Komplexe Datentypen, Prozeduren und Veränderlichen Zustand. Damit kann man schon ziemlich viel machen. Das Objektorientierte Paradigma erweitert diesen Werkzeugkasten um die Methode, die Zustand und Prozedur vereint. Es entsteht eine Closure, eine Prozedur, die dynamisch erzeugten Zustand mit sich herumträgt (das Objekt auf dem die Methode aufgerufen wird). 

Das funktionale Paradigma geht einen anderen Weg: Anstatt ein weiteres Konzept einzuführen, schränkt es ein grundlegendes Konzept ein: Der veränderliche Zustand verliert seine Veränderlichkeit, was direkt dazu führt, dass Prozeduren zu Funktionen werden. Es hat aber auch zur Folge, dass einige Sprachkonstrukte keinen Nutzen mehr haben bzw. das andere Konzepte größere Wichtigkeit erlangen.

Durch Seiteneffektfreiheit haben wir keine echten Variablen mehr und keine veränderlichen Objekte. Dies führt direkt dazu, dass Statements ohne Rückggabewerte keinen Sinn mehr haben. Außerdem hatten wir darüber geredet{{{see(07-iteration,Iteration: Wiederholte Ausführung)}}}, dass Schleifen nur durch Seiteneffekte mit dem restlichen Code kommunizieren können. Beides fällt also in einer rein funktionale Programmiersprache weg. Haskell[fn::Eine rein funktionale Programmiersprache] kennt einfach keine Schleifen! Alles was wir an Konzepten in unserem funktionalen Werkzeugkasten (=Paradigma) haben wollen, muss einen Rückgabewert erzeugen, da dies der einzige Kanal ist Ergebnisse nach Außen kommunizieren zu können. Es muss also alles ein **Ausdruck** werden.

Es stellt sich allerdings noch die Frage, wie man in einer Welt ohne Schleifen wiederholte Ausführung bewerkstelligen soll. Die Antwort darauf, wird dem Erstsemester-Studierenden nicht gefallen: **Rekursion**. Bei der Rekursion hat jeder Rekursionschritt einen Rückgabewert und wir können, bis zur Abbruchbedingung, eine variable Anzahl an Rekursionsschritten durchführen. Daher ist Rekursion für das funktionale Paradigma ein essentielles Konzept.

Jedoch gibt es noch einige andere Fragen, die aufkommen, denen wir uns im Folgenden widmen wollen: Wie kann man so überhaupt übersichtlich, effizient, und effektiv programmieren! Man könnte meinen, dass dies alles viel zu beschnitten ist. Aber mit dem funktionalen Paradigma kommen eine ganze Reihe von Sprachkonzepten, die es einfach machen funktional zu programmieren. Diese wollen wir uns im folgenden anschauen.

* Funktionale Datentypen
:PROPERTIES:
:CUSTOM_ID: 12-functional-types
:END:


#+begin_src latex
  \dividerframe{Unveränderliche\\Datentypen}

  \begin{frame}[fragile]{Typen für funktionale Programmierung}
    \begin{btBlock}[type=alert]{}
      Viele Datentypen sind darauf ausgelegt, dass ihre Objekte während ihrer Lebenszeit verändert werden. Das haben wir leider \ALERT{verboten}!
    \end{btBlock}

    \bi
    \ii Objekte werden nur initialisiert, aber nie verändert. {
      \bi
      \ii Jede Referenz erlaubt nur das Lesen des Objekts
      \ii "Modifikation" nur über partielle Kopie und parametrisierte Konstruktoren
      \ii Effizienz: Übersetzer kann viele dieser Kopie durch Optimierungen entfernen
      \ei

      \begin{center}
        \begin{minipage}{0.7\linewidth}
          \begin{code}[tag=Pseudocode]
            \begin{lzero}
              func add(a : Point, b : Point) : Point {
                return new Point(a.x+b.x, a.y+b.y);
              }
            \end{lzero}
          \end{code}
        \end{minipage}
      \end{center}
    }
    \ii<2-> Bei hierarchisch verzeigerte Datentypen funktioniert das besonders gut {
      \bi
      \ii \structure{Einfach verkettete Listen}: Vorne anhängen ist leicht
      \ii \structure{Bäume}: Unterbäume können bei einem Knotenupdate übernommen werden
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}<handout:1-3>{Update und Modifikation von Listen}
    \btAnimation[width=0.8\textwidth]{range=1-3:<1->,3:<4->,center,padding=2ex}{fig/12-trees}
  
    \bi
    \ii Funktionale Programmierung arbeitet viel mit einfach verketteten Listen{%
      \bi
      \ii<2-> \structure{Vorne anhängen} erfordert keine Änderung der vorhandenen Listenelemente
      \ii<2-> \structure{Gebundene Namen} bleiben valide und verändern ihren Wert nicht.
      \ii<3-> \structure{Updates} erfordert Elementkopien bis zur Änderungsstelle
      \ei
    }\medskip
    \ii<4-> Einfach verkettete Listen sind eine \ALERT{rekursive} Datenstruktur\\
     $\Rightarrow$ Passt hervorragend zur rekursiven Struktur funktionaler Programme.
    \ei
  \end{frame}
#+end_src

Bevor wir uns den Operationen im funktionalen Paradigma zuwenden, müssen wir uns über die Objekte unterhalten.
Durch die Freiheit von Seitenffekten, sind alle Objekte in einem funktionalen Programm unveränderlich.
Es sind also alles **Immutable Objects**, von denen wir an anderer Stelle schon einmal geredet haben{{{see(06-immutable-objects,Fallstudie: Unveränderliche Objekte)}}}, die nur bei der Initialisierung vom Konstruktor mit Werten gefüllt werden. Dies führt auch direkt dazu, dass Referenz- und Wertemodell{{{see(06-value-reference-model,Werte- und Referenzmodell für Variablen)}}} zu einem Punkt zusammenfallen und wir keine Zeigertypen in einer rein funktionalen Sprache brauchen.
Die Beschränkung auf unveränderliche Objekte führt aber auch dazu, dass wir andere Datentypen brauchen, mit denen wir dennoch effizient Berechnungen durchführen können.

Um eine Berechnung durchzuführen geben wir einer Funktion eines (oder mehrere) dieser unveränderlichen Objekte als Argumente mit. Die Funktion kann die Informationen daraus auslesen, kombinieren, und ein neues Objekt mit den Ergebnissen erzeugen, welches dann zurück gegeben wird. Wollen wir ein Feld in einem Objekt "updaten", müssen wir eine Kopie anlegen, in der alle bis auf eines der Felder gleich sind wie im orginalen Objekt. Für die funktionale Programmierung müssen wir also beständig Informationen aus Objekten extrahieren, und neue Objekte mit beinahe gleichem Inhalt konstruieren. Auf den ersten Blick mag dies Ineffizient sein, aber Übersetzer für die Sprache sind ziemlich gut darin, unnötige Kopien zu vermeiden. Überlassen Sie dieses Problem also erstmal den Übersetzern. 

Aber wir haben auch ein Problem auf der Verwendungsebene der Sprache: Nicht jede Datenstruktur eignet sich gleich gut für dieses Muster des partiellen Updatens. Zum einen müssten wir für große monolithische Objekte (wie ein Array), viele Daten kopieren um ein einzelnes Feld zu verändern, zum anderen wäre es schön Typen und Syntax zu haben um mit sehr wenig Code Informationen aus Objekten zu extrahieren und neue Objekte anzulegen. Diesen Herausforderungen für funktionale Datenstruktur wollen wir uns nun widmen.

Partielle Updates von Daten funktioniert mit einigen Datentypen besser als mit anderen. Wie wir schon gesagt haben eignen sich große Arrays eher weniger. Aber welche Datentypen eignen sich denn dann für funktionale Programmierung? Die Antwort darauf sind Datenstrukturen, die aus vielen kleinen Objekten bestehen, die sich gegenseitig hierarchisch referenzieren. Das Paradebeispiel hierfür ist die einfach **verkette Liste**. Aber auch Bäume eignen sich ganz gut. 


Solche Datenstrukturen eigenen sich daher gut, da man die Datenstruktur (in ihrer Gesamtheit) leicht erweitern kann ohne die bereits bestehenden Objekte zu modifizieren. So kann man zu einer verketten Liste vorne etwas anhängen, indem man ein neues Listenelement erzeugt, welches auf den bereits existierenden Listenkopf zeigt. Selbst wenn der bereits bestehende Listenkopf an einen anderen Namen gebunden ist, ist das kein Problem: Die neue Liste teilt sich einfach alle, bis auf das erste, Listenelement mit der alten Liste. Und da alle Elemente unveränderlich sind, bekommen wir niemals ein Problem! Niemals kann es in der Zukunft geschehen, dass eine Operation auf der alten Liste dazu führt, dass die neue Liste sich verändert. 

Will man in einer solchen unveränderlichen Struktur ein Element in der Mitte der Liste austauschen, so muss man alle Elemente bis zum betroffenen Element kopieren, da sich ja deren Nachfolger ändert. Allerdings bleiben nur so, bereits existierende Liste intakt. Im folgenden Stück Python Code habe ich die Situation auf der Folie für Sie einmal nachempfunden. Die Klasse ~Elem~ beschreibt die Listenelement. Neben dem Wert des Elements (~value~) und der Referenz auf das folgende Element (~next~), hat jedes Element eine eindeutige Nummer (~__id__~), die im Konstruktor gesetzt wird. Auf diese Weise können Sie in der Ausgabe nachvollziehen, welche Listen sich welche Objekte teilen. So hat das Element ~([#0] 4 None)~ die eindeutige Nummer 0, den Wert 4, und keinen (~None~) Nachfolger.

Die Funktion ~cat()~ hängt vorne an die Liste ein neues Element an, während die Funktion ~setnth()~ das Nte Element in einer bestehenden Liste austauscht. Dazu geht ~setnth()~ die Liste rekursiv durch, bis Sie beim entsprechenden Element angekommen ist und erzeugt ein neues Element mit dem neuen Wert. Bei der Rückkehr aus der Rekursion werden die Werte aus der alten Liste kopiert und neu "verzeigert". 

#+INCLUDE: ../lst/12-immutable.py

In ähnlicher Weise sind verzeigerte Bäume eine gute funktionale Datenstruktur. Beide haben es gemein, dass die Datenstrukturen rekursiv sind. Ein Kind eines Baumelements ist selbst wieder ein Baum. Bei der Liste ist der Nachfolger wieder eine Liste (oder das Listenendsymbol).

#+begin_src latex
  \begin{frame}<handout:1,2,4,5>[fragile]{Aufzählungstypen mit Nutzlast}
    \OrangeBox{\textbf{Problem:} Wir wollen viele Objekte erzeugen und wieder zerlegen}
    \medskip
    \begin{columns}
      \begin{column}{0.49\textwidth}
        \begin{code}[tag=Rust]
          \begin{onlyenv}<handout:1|1>
            \begin{rust}
              enum PointKind {
                XY,
                XYZ,
              };
            \end{rust}
          \end{onlyenv}%
          \begin{onlyenv}<handout:2-|2->
            \begin{rust}
              enum Point {
                XY(i32, i32),
                XYZ(i32, i32, i32)
              };
            \end{rust}
          \end{onlyenv}
        \end{code}
      \end{column}\hfill
      \begin{column}<handout:3-|3->{0.49\textwidth}
        \begin{code}[tag=Rust]
          \begin{rust}[style=highlighting]
            @4fn handle(p : Point);@
            let p1 = @3Point::XY@ (0, 3);
            let p2 = @3Point::XYZ@(0, 3, 0)
            @4handle(p1); handle(p2);@
          \end{rust}
        \end{code}
      \end{column}
    \end{columns}

    \bi
    \ii Funktionale Sprachen bieten Aufzählungstypen (\structure{enum}) \only<2->{mit Nutzlast} {
      \bi
      \ii Endliche (aufzählbare) Anzahl an Varianten
      \ii<handout:2-|2-> Jeder Variante kann unterschiedliche Felder mit sich führen.
      \ii<handout:3-|3-> Aufzählungsname wird Konstruktor.
      \ii<handout:4-|4-> Tagged variante Records (\structure{union}) sind typsicher und polymorph
      \ei
    }
    \ii<handout:5-|5-> Rekursiv generisch-polymorphe typsichere Aufzählungstypen {
      \begin{columns}
        \begin{column}{0.49\textwidth}
           \begin{code}[tag=Haskell]
             \begin{haskell}
               data Tree T = Leaf T
                           | Node (Tree T) (Tree T)
               freeTree :: Tree Char
               freeTree = Node
                            (Node
                               (Leaf 'X')
                               (Leaf 'Y'))
                            (Leaf 'Z')
             \end{haskell}
           \end{code}        
        \end{column}\hfill
        \begin{column}{0.49\textwidth}
          \begin{tikzpicture}[
            level distance=10mm,
            every node/.style={draw, font=\scriptsize}
            ]
            
            \node (r){Node}
              child { node {Node}
                child { node (x) {Leaf 'X'}}
                child { node {Leaf 'Y'}}}
              child { node (z){Leaf 'Z'}};

            \node[fit=(r) (x) (z),draw, dashed,
                  pin={[align=center]0:Tree Char\\==\\Ein Baum\\aus Char}] {};
          \end{tikzpicture}
        \end{column}
      \end{columns}
    }
    \ei
  \end{frame}
#+end_src  

Neben der Verwendbarkeit von Datenstrukturen haben wir allerdings noch eine zweite Dimension, die wir uns für unsere Daten vom funktionalen Paradigma wünschen:
Einfache Handhabbarkeit.
Es muss einfach sein Objekte zu erzeugen und wieder zu zerlegen.
Denn beides werden wir ständig machen, da wir ja keine Modifikationen durchführen werden.
Dazu haben sich **Aufzählungstypen mit Nutzlast** als sehr geeignete Typen heraus gestellt.
Kennen gelernt haben wir einfache Aufzählungstypen bereits in der Vorlesung über Typen{{{see(03-scalar-types,Skalare Typen)}}} als skalare Datentypen.
Dort haben wir gelernt, dass ein eine Aufzählung einen diskreten und endlichen Wertebereich hat, der von den Entwicklern deklariert wird.
Jedes Element einer Aufzählung ist ein möglicher Wert, eine Variante, der Aufzählung.

Nun wollen wir aus diesen Aufzählungen zu zusammengesetzten Typen{{{see(03-composite-types,Zusammengesetzte Typen)}}} erweitern.
Jede Variante der Aufzählung bekommt jetzt noch eine Nutzlast in Form von Felder (ähnlich wie bei Records). Dabei erlauben wir, dass jede Variante unterschiedliche Felder haben kann. Die Aufzählung selbst wird dabei zu einem einzelnen Datentypen, der wir verwenden können um Variable und Parameter zu deklarieren.
Die einzelnen Varianten werden zu Konstruktoren, die ihre angehängten Felder als Argumente bekommen, und ein Objekt vom Aufzählungstypen erzeugen. 

Diese Art der Aufzählungen ist ähnlich zu den varianten Records (~union~), allerdings hat jedes Objekt zusätzlich das Wissen mit welchem Variantenkonstruktor sie erzeugt wurde. Im Gegensatz zu C-~union~ Objekten kann man durch dieses Wissen die einzelnen Felder auch wieder Typsicher aus dem Objekt extrahieren. Falls es ihnen leichter fällt C Code zu verstehen, bietet das folgende Stück C Code die gleiche Funktionalität wie der auf den Folien gezeigte Aufzählungstyp ~Point~. Sie müssen zugeben, dass es sich wirklich lohnt Syntax in der Sprache zu haben, mit der man gleichzeitig die Aufzählungswerte, die Konstruktoren und die Felder deklarieren kann:

#+INCLUDE: ../lst/12-variant.c

In Haskell ist die Syntax für solche Aufzählungstypen sogar noch kompakter und erlaubt es auch sehr einfach Typen für rekursive Datenstrukturen zu definieren. Zusätzlich kommt noch dazu, dass solche rekursiven Typen bei Haskell generisch sind{{{see(03-polymorphism,Polymorphismus: Generische Typen)}}}.
Da die Haskell Syntax doch sehr kompakt ist, wollen wir den Ausdruck ~data Tree T = Leaf T | Node (Tree T) (Tree T)~ Schritt für Schritt auseinander nehmen.

Das Schlüsselwort ~data~ leitet die Deklaration eines neuen Typen ein. Der Name des neuen Typen ist ~Tree~ und er hat einen generischen Typparameter ~T~. Instantiiert mit einem ~Char~ (Haskell: ~Tree Char~) würde dieser Type den Typausdruck ~Tree(Char)~ erzeugen, einen Baum mit Buchstaben an den Blättern. Auf der rechten Seite des ~=~ befinden sich die beiden Varianten dieses Aufzählungstyps (~Leaf~ und ~Node~):
Zunächst haben wir die Variante ~Leaf~, die mit einem Feld Nutzlast kommt, welches vom Typ parametrischen ~T~ ist. In einem ~Tree Char~, würde jedes Blatt also genau einen Buchstaben speichern. Die zweite Variante von ~Tree~ ist ein innerer Knoten ~Node~, der zwei Felder hat, die beide vom vom parametrischen Typ ~Tree T~ sind. Im Kontext eines ~Tree Char~ heißt dies, dass ein innner Knoten zwei Felder hat, die wiederrum vom Type ~Tree Char~ sind. 

Wie im Rust Beispiel, sind die Aufzählungsvariante gleichzeitig Konstruktoren um Objekte vom Typ ~Tree T~ zu instantiieren. Im Beispiel sehen wir, dass die Variable ~freeTree~ als ein ~Tree Char~ deklariert wird und wir danach einen entsprechenden Baum an den Namen binden. Hier kommen die Variantennamen als Konstruktoren zum Einsatz.

#+begin_src latex
  \begin{frame}[fragile]{Destructuring Bind und Pattern Matching}
    \OrangeBox{Deklaration und Konstruktion von Aufzählungsobjekten ist sehr kompakt.}
    \bi
    \ii<2-> \structure{Destructuring Bind}: Zerlegen eines Objekts in seine Einzelteile {
      \bi
      \ii Muster mit der gleichen Struktur aber freien Namen
      \ii Objekt wird auf dieses Muster aufgeteilt
      \ii Freie Namen werden werden an die zerlegten Subobjekte gebunden
      \ei
      \medskip
      \begin{columns}
        \begin{column}{0.49\textwidth}
          \begin{code}[tag=Rust]
            \begin{rust}
              struct ObjT { a : i32, b : i32 }
              let ObjT {a: y0, b: y1} = obj;
            
              let (x0, x1) = (1, 2);
            \end{rust}
          \end{code}
        \end{column}\hfill
        \begin{column}<handout:2-|3->{0.49\textwidth}
          \begin{code}[tag=Rust]
            \begin{rust}
              let norm = match p1 {
                Point::XYZ(x,y,z) => x+y+z,
                Point::XY (x,y)   => x+y,
              }
            \end{rust}
          \end{code}
        \end{column}
      \end{columns}
    }\medskip
    \ii<handout:2-|3-> \structure{Pattern Matching}: Selektionsoperation mittels Destructuring Bind{
      \bi
      \ii Ähnlich, aber mächtiger wie ein switch-case in C
      \ii Vergleich eines Objekts gegen mehrere Muster und Destructuring Bind
      \ii Der entsprechende Arm wird mit den gebundenen Namen ausgeführt
      \ii Semantische Analyse kann prüfen ob alle Fälle abgedeckt sind
      \ei
    }
    \ei
  \end{frame}
#+end_src

Aber wir wollen Objekte ja nicht nur kompakt erzeugen, sondern sie, und auch andere unveränderliche Objekte,  auch kompakt verwenden. Dazu haben sich zwei sehr nah verwandte Konzepte etabliert, mit denen man Objekte wieder zerlegen kann. Mit dem **destructuring bind** binden wir die einzelnen Subobjekte eines Objekts mittels eines Musters an Namen. Mit dem **pattern matching** verwenden wir solche Muster um zwischen unterschiedlichen Varianten eines Aufzählungstyps zu eine Fallunterscheidung durchzuführen. 

Beim **destructuring bind**, einem Wort für das ich keine deutsche Entsprechung kenne, verwenden wir ein Muster mit freien Variablennamen um ein Objekt in einer Zuweisung zu zerlegen. Dabei muss das Muster die gleiche Struktur haben, wie das Objekt was wir zerlegen wollen, sonst schlägt die Zerlegung zur Laufzeit fehl. Ist das Objekt ein Record, so muss das Muster auch aussehen wie ein Record, ist das Objekt ein Tupel, so muss das Muster auch ein Tupel sein. Im Muster befinden sich anstatt konkreter Werte Namen, die frei, also noch ungebunden, sind. Im Beispiel sieht dass dann so aus, dass wir das Tupelobjekt ~(1,2)~ zerlegen wollen. Das Muster auf der linken Seite ist ~(x0, x1)~ und enthält die freien Namen ~x0~ und ~x1~. Durch das destructuring bind weisen wir die entsprechenden Subobjekte den Namen zu, sodass danach ~x0~ den Wert 1 und ~x1~ den Wert 2 hat.

Destructuring bind sollten bei ihnen bereits ein Gefühl von Bekanntheit erzeugen, da es sehr ähnlich aussieht wie Unifikation, bei dem wir ja auch Muster aneinander angeglichen haben.
Allerdings gibt es zwei bedeutende Unterschiede zur Unifikikation:
(1) Beim destructuring bind ist ganz klar, dass es ein Muster und eine Vorlage gibt und abgleichen nur in eine Richtung geschieht.
Bei der Unifikation sind beide Seiten gleichberechtigt.
(2) Beim destructuring bind darf jeder freie Name nur genau einmal im Muster auftreten, während bei der Unifikation freie Variablen mehrfach auftreten dürfen.
Durch beide Einschränkungen ist das destructuring bind deterministisch und schnell zu bewerkstelligen, während die Unifikation ein NP-vollständiges Problem ist.

Sehr verwandt zum destructuring bind ist das **pattern matching** bei wir auch strukturelle Muster verwenden, aber diesmal um eine Fallunterscheidung durch zu führen. Der Ablauf ist dann wie ein ~switch-case~: Ein gegebenes Objekt (~p1~ auf den Folien) wird gegen eine Reihe von Mustern verglichen. Das erste Muster das auf das Objekt passt führt dazu, dass der entsprechende Arm der Fallunterscheidung selektiert wird. Mittels destructuring bind wird das Muster (~Point::XY (x,y)~)verwendet um das Objekt zu zerlegen und Teile davon an Namen zu binden, die dann innerhalb der Fallunterscheidung zur Verfügung stehen.

Durch pattern matching kann man sehr kompakt gegen alle Varianten eines Aufzählungstypen mit Nutzlast vergleichen und Variantenspezifischen Code ausführen. Im Gegensatz zu einer ~if-elif-else~ Kaskade ist es bei diesem Konstrukt für den Übersetzer auch leicht zu prüfen, ob wirklich alle Fälle der Aufzählung abgehandelt wurden, oder ob ein Fall vergessen wurde.

* Funktionen als Bürger erster Klasse

#+begin_src latex
  \dividerframe{Funktionen als \\Bürger erster Klasse}

  \begin{frame}{Funktionen erster und höherer Ordnung}
    \btAnimation[width=0.7\textwidth]{range=1-3:<1->,center,padding}{fig/12-function-universe.pdf}

    \bi
    \ii \textbf{Bisher:} Wir hatten hauptsächlich \structure{Funktionen erster Ordnung} {
      \bi
      \ii Funktionen und Objekte sind zwei getrennte Universen
      \ii<2-> Funktionsanwendung kombiniert eine Funktion und mehrere Objekte\\[2ex]
      \ii<2->[$\Rightarrow$] Definition: Funktion erster Ordnung hat nur passive Objekte als Argument
      \ei
    }
    \medskip
    \ii<3-> \structure{Funktionen höhrerer Ordnung} haben Funktionen als Parameter{
      \bi
      \ii Viele Imperative Sprachen bieten bereits Funktionszeiger
      \ii \ALERT{Aber:} Funktionen sind immer noch nicht wirklich gleichberechtigt! 
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{First-Class Functions}
    \begin{center}
      \btAnimation[width=0.65\textwidth]{range=4-5:<1-end>}{fig/12-function-universe.pdf}
    \end{center}


    \bi
    \ii Im funktionalen Paradigma sind Funktionen wirklich gleichberechtigt {
      \bi
      \ii Keine kategorieller Unterschied zwischen Funktionen und Objekten
      \ii<2-> Funktionen können Argument \textbf{und} Rückggabewert sein!
      \ei
    }\medskip
    \ii<3-> Funktionen sind \ADVANTAGE{WIRKLICH} gleichberechtigt! {
      \bi
      \ii Funktionen können während der Laufzeit neu erzeugt werden.
      \ii Funktionen können komponiert und partiell angewendet werden.
      \ei
    }
    \ei

    \uncover<4->{\Large $\Rightarrow$ \btSetTab Im funktionale Paradigma werden die\\
                            \btUseTab algorithmischen Aspekte einer Sprache gestärkt!}
    \end{frame}
#+end_src

#+begin_src latex
  \dividerframe{Funktionales Programmieren}

  \begin{frame}[fragile]{Funktionen als Argumente}
    \begin{btBlock}{}
      Obwohl Python keine rein(!) funktionale Programmiersprache ist, werde ich die Beispiele, soweit es geht, als Python Code zeigen.
    \end{btBlock}
    \bigskip

    \bi
    \ii Funktionen höherer Ordnung können \structure{Auswertungsstrategien} abstrahieren{%
      \bi
      \ii \enquote{Äußere} Funktion steuert die Auswertung, die Übergebene macht die Arbeit.
      \ii Die übergebene Funktion kann mehrfach und mit unterschiedlichen Parametern aufgerufen werden. Die Ergebnisse können kombiniert werden.
      \ii Die Auswertestrategie ist parametrisierbar und wird so \advantage{wiederverwendbar}!{\\\medskip
      \begin{columns}
        \begin{column}{0.49\textwidth}
          \begin{code}[]
            \begin{py}
              def outer(fn, arr):
                  return fn(arr[0]) + fn(arr[1])

                  outer(innerA, [23, 42]) # => 6500
                  outer(innerB, [23, 42]) # => -65
            \end{py}
          \end{code}
        \end{column}\hfill
        \begin{column}{0.49\textwidth}
          \begin{code}[]
            \begin{py}
              def innerA(x):
                  return x * 100
                
              def innerB(x):
                  return x * -1
            \end{py}
          \end{code}
        \end{column}
      \end{columns}
    }\medskip
    \ii Wir hatten dies bereits bei \texttt{traverse()} und \texttt{fixpoint()} benutzt.
    \ei
    }\medskip

    \ei
  \end{frame}

  \begin{frame}[fragile]{$\lambda$/Lambda: Anonyme Funktionen}
    \bi
    \ii Bei funktionaler Programmierung braucht man ständig kleine Funktionen{%
      \bi
      \ii Entfernte Funktionsdefinition an anderer Stelle zerstört die Code-Lokalität
      \ii Außerdem ist es aufwändig sich ständig neue Funktionsnamen auszudenken
      \ei
    }\medskip
    \begin{center}
      \uncover<2->{\includegraphics[page=1,width=0.6\textwidth]{fig/12-lambda}}
    \end{center}
    \ii<2-> \textbf{Lösung}: \structure{Lambda-Ausdrücke} erzeugen ein Funktionsobjekt ohne Namen{
      \bi
      \ii Inspiriert vom, aber nicht immer äquivalent zum, Lambda-Kalkül
      \ii Bestandteile: Parameterliste und \textbf{ein} Ausdruck
      \ii Funktionsobjekt kann später aufgerufen werden
      \ei
    }
    \ei
    \begin{columns}<2->
      \begin{column}{0.65\textwidth}
        \begin{code}[]
          \begin{py}
            outer(lambda x: x * 100, [23,42]) # => 6500
            outer(lambda x: x * -1,  [23,42]) # => -65          
          \end{py}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.31\textwidth}
        \begin{code}[]
          \begin{py}
            add = lambda x, y: x+y
            add(1,2) # => 3      
          \end{py}
        \end{code}
      \end{column}\hfill\mbox{}
    \end{columns}

  \end{frame}

  \begin{frame}{Beispiel: Listenmanipulationen}
    \bi
    \ii Listen sind die funktionale \enquote{Brot-und-Butter} Datenstruktur{
      \bi
      \ii Funktionen höherer Ordnung bieten standardisierte Auswertungsstrategien
      \ii Diese Funktionen ersetzen teilweise iterative Sprachelemente
      \ei
    }
    \ei

    \medskip
    \begin{columns}[t]
      \begin{column}<2->{0.32\textwidth}
        \includegraphics[width=\textwidth,page=1]{fig/12-list-manipulation}
      
        \medskip
        { \small
          \codebox{map()} bildet jedes Element mit Hilfe der übergebenen Funktion ab und konstruiert daraus eine neue Ergebnisliste.}

      \end{column}\hfill
      \begin{column}<3->{0.32\textwidth}
        \includegraphics[width=\textwidth,page=2]{fig/12-list-manipulation}


        \medskip
        { \small
          \codebox{filter()} prüft jedes Element mittels einem Prädikat und konstruiert eine Liste \enquote{erfolgreichen} Elementen.}

      \end{column}\hfill
      \begin{column}<4->{0.32\textwidth}
        \includegraphics[width=\textwidth,page=3]{fig/12-list-manipulation}

        \medskip
        { \small
          \codebox{reduce()} reduziert eine Liste zu einem Wert indem die übergebene Funktion als Infixoperator angewendet wird.}
      \end{column}
    \end{columns}
  \end{frame}

  \begin{frame}[fragile]{Komposition von Funktionen}

    \bi
    \ii \structure{Funktionskomposition} ist die Hintereinanderausführung von Funktionen{
      \bi
      \ii Aus zwei Funktionsobjekten kreieren wir ein neues Funktionsobjekt
      \ii Die neue Funktion wendet beide Funktionen in Reihe an.\\
          Das Ergebnis der ersten wird zur Eingabe der zweiten.
      \ii Rückgabetypen und Parametertypen müssen zueinander passen
      \ei
    }
    \ei

    \begin{center}
      \includegraphics[page=1,width=0.8\textwidth]{fig/12-composition}
    \end{center}

  \begin{columns}<2->
    \begin{column}{0.49\textwidth}
      \begin{code}[tag=Python]
        \begin{py}
          def inc(x):
             return x + 1

          def compose(f, g):
             return lambda x: f(g(x))
           
          x = compose(inc, inc)
          x(0) # => 2
        \end{py}
      \end{code}
    \end{column}\hfill
    \begin{column}{0.49\textwidth}
      \begin{code}[tag=Haskell]
        \begin{haskell}
          inc = \x -> x +1
          x   = inc . inc
        
          x(0) # => 2
        \end{haskell}
      \end{code}
    
      Haskell bietet Komposition sogar als \structure{Infixoperator} \enquote{.}, angelehnt an $f \circ g$:
    \end{column}
  \end{columns}


  \end{frame}

  \begin{frame}[fragile]{Partielle Anwendung von Funktionen}
    \bi
    \ii \structure{Partielle Anwendung} bindet einige Parameter einer Funktion{
      \bi
      \ii \textbf{Beobachtung}: Funktionen brauchen all ihre Parameter zur Ausführung
      \ii \textbf{Idee}: Wir könnten einige Parameter mit bekannten Argumenten vorbelegen
      \ii Erzeugen eines Funktionsobjekts mit geringerer Stelligkeit
      \ei
    }
    \ei

    \begin{center}
      \includegraphics[page=1,width=0.8\textwidth]{fig/12-partial}
    \end{center}

    \begin{columns}<2->
    \begin{column}{0.49\textwidth}
      \begin{code}[tag=Python]
        \begin{py}
          def add(a,b):
             return a + b

          def partial(f, *a0):
             return lambda *a1: f(*(a0+a1))
           
          inc = partial(add, 1)
          inc(0) # => 1
        \end{py}
      \end{code}
    \end{column}\hfill
    \begin{column}{0.49\textwidth}
      \begin{code}[tag=Haskell]
        \begin{haskell}
          add :: Int -> (Int -> Int)
          add a b = a + b

          inc = (add 1)
          inc(1) -- => 2
        \end{haskell}
      \end{code}
    
      Haskell bietet \structure{Currying}, wo jede Funktion standardmäßig partiell anwendbar ist.
    \end{column}
  \end{columns}
  \end{frame}

  \begin{frame}[t,fragile]{Beispiel: Eine Verarbeitungskette}
    \begin{columns}
      \begin{column}{0.25\textwidth}
        \btAnimation[width=0.9\textwidth]{1:<1-3>,range=2-4:<4->}{fig/12-points}
      \end{column}\hfill
      \begin{column}{0.74\textwidth}
        \textbf{Aufgabe}: Gegeben eine 2 dimensionale Punktwolke, finden Sie innerhalb des Einheitskreises die größte Distanz, die ein Punkt zum Ursprung hat.

        \begin{code}[]
          \begin{py}
            points = [(-0.3,0.4),  (-0.3, -0.2),
                      (0.6,-0.4),  (1, 1)]
          \end{py}
        \end{code}

      \end{column}
    \end{columns}
    \begin{columns}
      \begin{column}<2->{0.4\textwidth}
        \begin{code}[]\ttfamily\footnotesize
          \def\I{\mbox{\hspace{2ex}}}%
          def norm(N, point): ...\\
          \uncover<6->{maxD = \textbackslash}\\
           \I\uncover<6->{reduce(max,}\\
           \I\I\uncover<5->{filter(lambda d: d <= 1.0,}\\
           \I\I\I\uncover<4->{map(}\uncover<3->{partial(norm, 2)}\uncover<4->{,}\\
           \I\I\I\I\uncover<4->{points)}\uncover<5->{)}\uncover<6->{)}\\
       \end{code}
      \end{column}\hfill
      \begin{column}{0.59\textwidth}
        \bii
        \ii<2-> Generische Normierungsfunktion $\|\cdot\|_N$
        \ii<3-> Die Distanz zum Ursprung ist die 2-Norm
        \ii<4-> Bilde jeden Punkt auf seine Distanz ab
        \ii<5-> Filtere Distanzen die $\le 1$ sind
        \ii<6-> Reduziere Distanzen zur maximalen Distanz
        \eii

      \end{column}
    \end{columns}
    \medskip



    \begin{center}
      \uncover<2->{\btAnimation[height=2cm]{1:<1-2>,range=2-5:<3->}{fig/12-point-pipeline}}
    \end{center}
  \end{frame}

#+end_src

* Funktionale Ein-/Ausgabe

#+begin_src latex
  \dividerframe{Funktionale\\Ein-/Ausgabe}

  \begin{frame}{Keine Seiteneffekte $\rightarrow$ Keine Schokolade}
    \bi
    \ii \textbf{Erinnerung}: Im rein-funktionalen Paradigma gibt es keine Seiteneffekte{%
      \bi
      \ii Kein veränderlicher Zustand, keine Variablen, ausschließlich \structure{pure Funktionen}
      \ii[$\Rightarrow$] Jegliche Art der Ein- oder Ausgabe sind verbotene Seiteneffekte
      \ii[$\Rightarrow$] Keine Terminalausgabe, keine Dateisystem, kein Netzwerk
      \ei
    }
    \ei
  
    \begin{center}
      \OrangeBox{Wie soll man damit nützliche Programme schreiben?}
    \end{center}

    \bi
    \ii<2-> \structure{Functional-Style Programming} als Funktionales Paradigma Light{
      \bi
      \ii Programmierstil der funktionale Elemente in anderen Sprachen verwendet
      \ii Komposition, partielle Applikation, oder \texttt{map()} geht auch mit Seiteneffekten
      \ii Trennung des Programs in Funktionen mit und ohne Seiteneffekte\\[2ex]
      \ii[$\Rightarrow$] Ein effektiver Entwickler setzt Seiteneffekte gezielt ein
      \ei
    }\medskip
    \ii<3-> Funktionale Elemente verbreiten sich unter den Sprachen {
      \bi
      \ii Skriptsprachen haben meist funktionale Aspekte (Python, Ruby, Lua,\ldots)
      \ii Die Tendenz bei übersetzten Sprachen geht auch zu funktionalen Elementen.
      \ei
    }
    \ei
  \end{frame}


  \begin{frame}{Und bei rein funktionalen Sprachen?}
    \bi
    \ii Nur wenige Sprachen verbieten Seiteneffekte völlig{
      \bi
      \ii \structure{Haskell} ist das prominenteste Beispiel
      \ii Es gibt noch weitere Forschungssprachen: Clean, Mercury\\[1ex]
      \ei
    }\medskip
    \ii<2-> In Haskell wird I/O über die  \structure{I/O Monade} gesteuert{\medskip
      \begin{columns}
        \begin{column}{0.6\textwidth}
            \btAnimation[width=\textwidth]{1:<1-2>,range=2-3:<3-end>,center,padding}{fig/12-haskell-io}
        \end{column}\hfill
        \begin{column}{0.38\textwidth}
          \bi
          \ii \textbf{Intuition}: Die I/O Monade transformiert das Universum
          \ii<3-> Sie steuert die Ausführung monadisch-komponierter Funktionen
          \ii<3-> Ruft Funktionen mit Welt-Informationen auf und koppelt Ergebnisse zurück
          \ii<4-> Unten in der Aufrufhierarchie sind nur pure Funktionen
          \ei
        \end{column}
      \end{columns}

    }
    \ei
  \end{frame}

  \begin{frame}[fragile]{I/O Monade in Haskell}
    \begin{columns}
      \begin{column}{0.49\textwidth}
        \begin{code}
          \begin{haskell}
            printUpCase :: String -> IO ()
            printUpCase l = putStrLn (upCase l)

            main :: IO ()
            main = (getLine >>= printUpCase)
                   >> main          
          \end{haskell}
        \end{code}

      \end{column}\hfill
      \begin{column}<2->{0.49\textwidth}
        \begin{code}[]
          \begin{haskell}
            main = do
                l <- getLine
                putStrLn (upCase l)
                main
          \end{haskell}
        \end{code}
      \end{column}
    \end{columns}

    \bi
    \ii Die I/O  Monade ist \enquote{magisch} im Haskell Universum {
      \bi
      \ii Im Programm komponiert man nur Funktionen zusammen (\texttt{>>}, \texttt{>>=})
      \ii Virtuelle Haskell-Maschine entimmt das Monadenobjekt \texttt{main} und führt es aus.
      \ii<2-> \structure{Synaktischer Zucker} erleichtert die Monadenkomposition
      \ei
    }\medskip
    \ii<3-> Monaden sind ein allgemeineres und mächtigeres Konzept{
      \bi
      \ii Monaden sind ein Konzept aus der \structure{Kategorientheorie}
      \ii Monaden kapsel Strategien zur Auswertereihenfolge und zum Datenflusss
      \ii Es gibt viele spannende Monadentypen: Maybe, State, Writer
      \ii Wir können und werden keine davon hier besprechen\ldots
      \ei
    }
    \ei
  \end{frame}
#+end_src


* Zusammenfassung
#+begin_src latex
  \begin{frame}{Zusammenfassung}
    \bi
    \ii \structure{Veränderlicher Zustand} ist problematisch in großen Softwareprojekten{
      \bi
      \ii Viele Prozeduren interagiern mit und verändern eine Vielzahl an Objekten
      \ii Zustand ist am Quellcode nicht sichtbar und daher unübersichtlich
      \ei
    }\medskip
    \ii Das (rein) \structure{funktionale Paradigma} verzichtet auf veränderlichen Zustand{%
      \bi
      \ii Variablen können nur einmal an ein Objekt gebunden werden
      \ii Listen und Aufzählungstypen mit Nutzlast sind nützliche Datentypen
      \ei
    }\medskip
    \ii Seiteneffektfreie Funktionen werden \structure{Bürger erster Klasse}{
      \bi
      \ii Funktionsobjekte sind als Argumente und Rückgabewerte gleichberechtigt
      \ii Komposition, Partielle Applikation und Listenfunktionen
      \ei
    }\medskip
    \ii \structure{Ein- und Ausgabe} kann nicht Seiteneffektfrei sein {
      \bi
      \ii Der funktionale Programmierstil ist erlaubt veränderlichen Zustand
      \ii Rein funktionale Sprachen transformieren die Welt über \structure{Monaden} 
      \ei
    }
    \ei

  \end{frame}
#+end_src
