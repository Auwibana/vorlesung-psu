#+TITLE: Programmiersprachen und Übersetzer
#+SUBTITLE: 12 - Das Funktionale Programmierparadigma
#+SETUPFILE: setup.org
#+INCLUDE: export-prologue.org
#+PROPERTY: header-args:latex :tangle yes :noweb yes :tangle-macros yes :tangle-prologue topic :tangle-epilogue endtopic :exports none

#+NAME: topic
#+BEGIN_SRC latex :tangle no
\psuSectionStart{{{{property(ITEM)}}}}{{{{n(block)}}}}
#+END_SRC

#+NAME: endtopic
#+BEGIN_SRC latex :tangle no
\psuSectionStop{{{{property(ITEM)}}}}{{{{n(block,-)}}}}
#+END_SRC

* Gedanken zu dieser Vorlesung                                     :noexport:
- Was war überhaupt das Problem?
  - Der Zustand von Programmen wird unübersichtlich
  - Alles interagiert irgendwie wie allem anderen

- Einordnung in die anderen Paradigmen

* Freiheit von Seiteneffekten
:PROPERTIES:
:CUSTOM_ID: 12-einleitung
:END:
#+begin_src latex
  \subtitle{{{{subtitle()}}}}
  \maketitleframe

  \begin{frame}{Probleme, Probleme, Probleme,\ldots}
    \bi
    \ii Kleine Programme sind \advantage{einfach}, Große Softwareprojekte sind \alert{schwer}.{
      \bi
      \ii Viele EntwicklerInnen, Viele Standorte, Viele Zeitzonen
      \ii Riesige Codebasis und \structure{interagierende Komponenten}
      \ii Viele Prozeduren (Algorithmen) und viele Objekte (Daten)
      \ei
    }
    \pause 
    \begin{center}
    \includegraphics[width=3.5cm]{fig/12-brain}
  \end{center}

    \ii Begrenzte geistitge Kapazität: \structure{Veränderlicher Zustand} sieht man nicht {
      \bi
      \ii[$\leftrightarrow$] Ausführung von Code ist meist sequentiell und lokal
      \ii Der aktuelle Zustand ist \textbf{Akkumulation aller Änderungen}
      \ii Ohne Einhaltung von Invarianten leicht \alert{unübersichtlich}
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{Funktionen: Prozeduren mit Scheuklappen}
    \mbox{}\hspace{-1.5em}\OrangeBox{(Reine) funktionale Programmierung erhöht die Lokalität von Änderungen}

    \bi
    \ii \structure{Rein Funktional}: Prozeduren werden zu mathematischen Funktionen {
      \bi
      \ii Das Ergebnis einer (echte) Funktion hängt nur von ihren Parametern ab.
      \ii Kein Seitenkanal über den globaler Zustand.
      \ii Funktionsausführung hat \ADVANTAGE{keine Seiteneffekte}!
      \ei
    }

    \begin{center}
      \includegraphics[width=4cm,page=2]{fig/12-function}\hspace{1.5cm}%
      \includegraphics[width=4cm,page=1]{fig/12-function}
    \end{center}

    \bigskip


    \ii<2> Mischformen mit veränderlichem Zustand \hfill\emph{functional style}{
      \bi
      \ii Rein funktionale Programmierung ist auch schwierig
      \ii Viele Programmiersprachen haben \structure{funktionale Elemente}
      \ei
    }
    \ei

  \end{frame}

  \begin{frame}{Verhältnis zu anderen Programmierparadigmen}
    \btAnimation[width=\textwidth]{range=1-3:<1->,center,padding}{fig/12-functional}
  \end{frame}

  \begin{frame}{Direkte Folgen von Seiteneffektfreiheit}
    \bi
    \ii Einige Sprachkonzepte werden sinnlos\ldots {
      \bi
      \ii Wiederbeschreibbare \structure{Variablen} sind veränderlicher Zustand  \hfill $\Rightarrow$ \ALERT{Verboten}
      \ii Veränderbare Objekte wären veränderlicher Zustand                      \hfill $\Rightarrow$ \ALERT{Verboten}
      \ii \structure{Schleifen}iterationen kommunizieren über ihre Seiteneffekte \hfill $\Rightarrow$ \ALERT{Sinnlos}
      \ii Sequenzierte \structure{Statements} haben keinen Rückgabewert          \hfill $\Rightarrow$ \ALERT{Sinnlos}
      \ei
    }\medskip
    \ii<2-> Andere Sprachkonzepte gewinnen an Wichtigkeit! {
      \bi
      \ii \structure{Immutable Objekte}: \btSetTab Werte- und Referenzmodell fallen zusammen!
      \ii \structure{Ausdrücke}:  \btUseTab Jede Operation braucht einen Rückgabewert!
      \ii \structure{Rekursion}:  \btUseTab Wiederholte Ausführungen nur durch Rekursion!
      \ii \structure{Funktionen}: \btUseTab Funktionsaufrufe modelieren abhängigkeiten Operationen!
      \ei
    }\medskip
    \ii<3-> Weitere wichtige Fragen, die direkt aufkommen! {
      \bi
      \ii Wie soll man so bitte übersichtlich programmieren?!
      \ii Wie kann das bitte nicht ineffizient sein?!
      \ii Wie soll ich Ein- und Ausgabe machen?!
      \ei
    }
    \ei
  \end{frame}
#+end_src


Wir haben die letzte Vorlesung mit das objektorientierten Paradigmas besprochen und mit einer Kritik beendet.
Angetreten ist dieses Paradigma und die damit verbundenen Designprinzipien um Softwareentwicklung "im Großen", als in großen Softwareprojekten an denen viele Menschen arbeiten, möglich zu machen. Und in dieser Hinsicht hat das OO Paradigma einiges geleistetet. Wir sind mit aktuellen Entwicklungsmodellen in der Lage viel viel größere Softwareprojekte zu realisieren, als wir das noch vor 40 Jahren waren. Teilweise ist das auf schnellere Hardware, was zu schnelleren Compile-Test-Zyklen führt, zurückzuführen, aber das bessere Verständnis für die Probleme, die erst in großen Projekten sichtbar werden, hat ebenso dazu beigetragen. Die Modelierung von Software entlang den Objekten, die sie versucht abzubilden, erleichtert es uns Menschen darüber zu reden. Aber, wie wir gesehen haben, das OO Paradigma ist nicht ohne Kritik. 

Der grundlegende Konflikt der bei der Softwareentwicklung großer Projekte auftritt ist, dass ein solches Projekt viele Interagierende Entitäten hat: Auf der Ebene der Entwicklung haben wir viele Menschen, die, verstreut über den ganzen Erdball, gemeinsam an einer Software arbeiten wollen. Dies erfordert einiges an Koordination, aber auch an Kommunikation; die Menschen müssen sich in ihrer Sprache über die Struktur der Software austauschen können (Hier hat OO einiges geleistet). Auf der Ebene der Software haben wir ebenfalls viele interagierende Entitäten: Viele Module enthalten eine vielzahl an Klassen, von denen Objekte instantiiert werden, die alle einen Zustand haben (Persistenz!) und sich gegenseitig Nachrichten zuschicken (Methodenaufruf!). Diese technische Komplexität kommt dann mit der begrenzten geistigen Kapazität von Menschen zusammen: Wir müssen Sie verstehen um sie beherschen zu können und um sie anderen mitteilen zu können.

Jetzt gibt es aber eine Kluft zwischen dem Quellcode, der die Klassen definiert, und dem Universum instantiierter Objekte ein Problem: Im Gegensatz zu statischen Codestrukturen sieht man den dynamischen Zustand nicht. Wo der Quellcode, durch die Verwendung des imperativen Paradigmas, relativ lokal abläuft (Eine Zeile nach der anderen), ist der dynamische Zustand viel schwierige zu fassen. Denn der Zustand eines Objektes ist die Kombination aller Änderungen, die dieses Objekt seit seiner Geburt{{{see(06-birth,Geburt von Objekten)}}} erfahren hat. Wir versuchen diesen dynamischen Zustand besser fassbar zu machen, indem wie **Invarianten** einführen, die den Raum möglicher Belegungen eingrenzt. Aber selbst mit guten Invarianten, müssen wir bei der Entwicklung immer die möglichen Zustände des Objektuniversums in unseren Köpfen nachvollziehen. Allzuhäufig fallen dabei die Randfälle, also da wo Objekte gerade noch die Invarianten einhalten, hinten runter und führen zu Softwarefehlern.

Es ist dieses Problem des Zustandsraums, dem sich das **funktionale Paradigma** annimmt.
Mit diesem Paradigma **eliminieren** wir den **veränderlichen Zustand**.
Lesen Sie den letzten Satz noch einmal, atmen Sie tief durch, und versuchen Sie die tragweite dieser Entscheidung zu verstehen.
Wir verbieten die Veränderung von Zustand[fn::Lassen Sie uns das gleich ein bisschen einschränken:
Nur das reine funktionale Paradigma geht in dieser Radikalität gegen veränderlichen Zustand vor.
Nur wenige Sprachen ziehen dies zum extrem durch.
Aber selbst abgeschwächte Formen führen zu einem völlig veränderten Nachdenken über Programmiersprachen.
Bleiben Sie also dabei, wenn wir jetzt einmal das Extrem ausloten].
Dieser radikale Schritt hat eine ganze Reihe von Implikationen, denen wir uns jetzt widmen werden, bevor wir darüber reden, wie man mit einer solch eingeschränkten Sprache nützliche Programme entwerfen kann.

Zunächst müssen wir uns einmal überlegen, was der Zustand eines Programs ist. All die Variablen die wir haben, die lokalen, die globalen, und die einzelnen Parameter von Funktionsinstanzen. All das ist Zustand. Aber auch die Objekte, die wir nur indirekt über diese Variablen über Referenzen erreichen können{{{see(06-garbage-collection,Mark-and-Sweep Garbage Collector)}}}, sind der Zustand eines Programms. Immer wenn wir ein existierendes Objekt verändern, dann benötigen wir das Sprachkonzept "veränderlicher Zustand". Jedes Beschreiben eines Record-Felds, jedes Setzen eines Array-Elements, jedes Verändern einer Variable, all das verändert den existierenden Zustand. All das wollen wir verbieten. Einzig zwei Dinge werden uns gelassen: Wir können neue Objekte parametrisiert erzeugen, und wir können einen bisher ungebundenen Namen an ein existierendes Objekt binden. Etwas flapsiger, und ungenau, ausgedrückt, würde man sagen: Variablen können nicht überschrieben, Objekte nicht verändert werden.

Was hat diese Einschränkung zur Folge? Eine ganze Menge! Bei der Diskussion der Operationen{{{see(07-operation-dependencies,Operationen und Seiteneffekte)}}} und ihrer Abhängigkeiten haben wir den Begriff der Seiteneffekte eingeführt. Ein Seiteneffekt einer Operation führt dazu, dass die Operation über ihren Rückggabewert hinaus, den Zustand der virtuellen Maschine verändert. Und es sind genau dies Seiteneffekte, die wir bei der funktionalen Programmierung verbieten werde.

Durch Seiteneffekte und globalen Zustand kann eine Prozedur Zustand besitzen und bei wiederholten Aufruf mit den selben Argumenten, jedesmal ein anderes Ergebnis liefern. Der globale Zustand, bzw. jeder andere veränderbare Ausführungskontext, agiert in solchen Situationen als **Seitenkanal** für die Prozedur:

#+begin_src python
counter = 0
def inc():
    global counter
    counter += 1
    return counter

print [inc(), inc(), inc()]
#+end_src

Wenn wir nun Prozeduren mit mathematischen Funktionen vergleichen, sehen wir, dass es hier eine Lücke gibt. Solche Prozeduren, die ihren Ausführungskontext verändern, sind keine Funktionen im mathematischen Sinne, da ihr Ergebnis nicht nur von ihren Eingabeparametern abhängt. Stellen Sie sich das einmal vor, wie das wäre, wenn die Addition in einem Ganzzahlring jedes mal ein anderes Ergebnis liefern würde. So könnte ja niemand Mathematik machen! Aber in der Programmierung erlauben wir uns das, wenn wir veränderlichen Zustand haben.

Mit dem funktionalen Paradigma werden Prozeduren also zu echten mathematischen Funktionen, deren Ergebnis nur noch von den übergebenen Argumenten abhängt. Die Ausführung einer solchen Funktion hat **keine Seitenffekte** und wir können Sie beliebig oft aufrufen, es wird immer das gleiche das gleiche dabei raus kommen. Auf diese Weise schafft es das funktionale Paradigma, dass nicht nur die Ausführung von Quellcode lokal ist, sondern auch, dass der Zustandsraum lokaler wird. Dies erleichtert es ungemein über die Korrektheit eines Programms nachzudenken. 

Vergleichen wir die drei Paradigmen, die wir in dieser Vorlesung besprechen, so sehen wir eine Entwicklung in zwei Richtungen, ausgehend vom imperativen Paradigma. Dieses grundlegende Paradigma hat vier Elemente: Sequenzierung, Komplexe Datentypen, Prozeduren und Veränderlichen Zustand. Damit kann man schon ziemlich viel machen. Das Objektorientierte Paradigma erweitert diesen Werkzeugkasten um die Methode, die Zustand und Prozedur vereint. Es entsteht eine Closure, eine Prozedur, die dynamisch erzeugten Zustand mit sich herumträgt (das Objekt auf dem die Methode aufgerufen wird). 

Das funktionale Paradigma geht einen anderen Weg: Anstatt ein weiteres Konzept einzuführen, schränkt es ein grundlegendes Konzept ein: Der veränderliche Zustand verliert seine Veränderlichkeit, was direkt dazu führt, dass Prozeduren zu Funktionen werden. Es hat aber auch zur Folge, dass einige Sprachkonstrukte keinen Nutzen mehr haben bzw. das andere Konzepte größere Wichtigkeit erlangen.

Durch Seiteneffektfreiheit haben wir keine echten Variablen mehr und keine veränderlichen Objekte. Dies führt direkt dazu, dass Statements ohne Rückggabewerte keinen Sinn mehr haben. Außerdem hatten wir darüber geredet{{{see(07-iteration,Iteration: Wiederholte Ausführung)}}}, dass Schleifen nur durch Seiteneffekte mit dem restlichen Code kommunizieren können. Beides fällt also in einer rein funktionale Programmiersprache weg. Haskell[fn::Eine rein funktionale Programmiersprache] kennt einfach keine Schleifen! Alles was wir an Konzepten in unserem funktionalen Werkzeugkasten (=Paradigma) haben wollen, muss einen Rückgabewert erzeugen, da dies der einzige Kanal ist Ergebnisse nach Außen kommunizieren zu können. Es muss also alles ein **Ausdruck** werden.

Es stellt sich allerdings noch die Frage, wie man in einer Welt ohne Schleifen wiederholte Ausführung bewerkstelligen soll. Die Antwort darauf, wird dem Erstsemester-Studierenden nicht gefallen: **Rekursion**. Bei der Rekursion hat jeder Rekursionschritt einen Rückgabewert und wir können, bis zur Abbruchbedingung, eine variable Anzahl an Rekursionsschritten durchführen. Daher ist Rekursion für das funktionale Paradigma ein essentielles Konzept.

Jedoch gibt es noch einige andere Fragen, die aufkommen, denen wir uns im Folgenden widmen wollen: Wie kann man so überhaupt übersichtlich, effizient, und effektiv programmieren! Man könnte meinen, dass dies alles viel zu beschnitten ist. Aber mit dem funktionalen Paradigma kommen eine ganze Reihe von Sprachkonzepten, die es einfach machen funktional zu programmieren. Diese wollen wir uns im folgenden anschauen.

* Aufzählungstypen und Pattern Matching

#+begin_src latex
  \dividerframe{Unveränderliche\\Datentypen}

  \begin{frame}[fragile]{Typen für funktionale Programmierung}
    \begin{btBlock}[type=alert]{}
      Viele Datentypen sind darauf ausgelegt, dass ihre Objekte während ihrer Lebenszeit verändert werden. Das haben wir leider \ALERT{verboten}!
    \end{btBlock}

    \bi
    \ii Objekte werden nur initialisiert, aber nie verändert. {
      \bi
      \ii Jede Referenz erlaubt nur das Lesen des Objekts
      \ii "Modifikation" nur über partielle Kopie und parametrisierte Konstruktoren
      \ii Effizienz: Übersetzer kann viele dieser Kopie durch Optimierungen entfernen
      \ei

      \begin{center}
        \begin{minipage}{0.7\linewidth}
          \begin{code}[tag=Pseudocode]
            \begin{lzero}
              func add(a : Point, b : Point) : Point {
                return new Point(a.x+b.x, a.y+b.y);
              }
            \end{lzero}
          \end{code}
        \end{minipage}
      \end{center}
    }
    \ii<2-> Bei hierarchisch verzeigerte Datentypen funktioniert das besonders gut {
      \bi
      \ii \structure{Einfach verkettete Listen}: Vorne anhängen ist leicht
      \ii \structure{Bäume}: Unterbäume können bei einem Knotenupdate übernommen werden
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{Update und Modifikation von Listen}
    \btAnimation[width=0.8\textwidth]{range=1-3:<1->,3:<4->,center,padding=2ex}{fig/12-trees}
  
    \bi
    \ii Funktionale Programmierung arbeitet viel mit einfach verketteten Listen{%
      \bi
      \ii<2-> \structure{Vorne anhängen} erfordert keine Änderung der vorhandenen Listenelemente
      \ii<2-> \structure{Gebundene Namen} bleiben valide und verändern ihren Wert nicht.
      \ii<3-> \structure{Updates} erfordert Elementkopien bis zur Änderungsstelle
      \ei
    }\medskip
    \ii<4-> Einfach verkettete Listen sind eine \ALERT{rekursive} Datenstruktur\\
     $\Rightarrow$ Passt hervorragend zur rekursiven Struktur funktionaler Programme.
    \ei
  \end{frame}

  \begin{frame}[fragile]{Aufzählungstypen mit Nutzlast}
    \OrangeBox{\textbf{Problem:} Wir wollen viele Objekte erzeugen und wieder zerlegen}
    \medskip
    \begin{columns}
      \begin{column}{0.49\textwidth}
        \begin{code}[tag=Rust]
          \begin{onlyenv}<1>
            \begin{rust}
              enum PointKind {
                XY,
                XYZ,
              };
            \end{rust}
          \end{onlyenv}%
          \begin{onlyenv}<2->
            \begin{rust}
              enum Point {
                XY(i32, i32),
                XYZ(i32, i32, i32)
              };
            \end{rust}
          \end{onlyenv}
        \end{code}
      \end{column}\hfill
      \begin{column}<3->{0.49\textwidth}
        \begin{code}[tag=Rust]
          \begin{rust}[style=highlighting]
            @4fn handle(p : Point);@
            let p1 = @3Point::XY@ (0, 3);
            let p2 = @3Point::XYZ@(0, 3, 0)
            @4handle(p1); handle(p2);@
          \end{rust}
        \end{code}
      \end{column}
    \end{columns}

    \bi
    \ii Funktionale Sprachen bieten Aufzählungstypen (\structure{enum}) \only<2->{mit Nutzlast} {
      \bi
      \ii Endliche (aufzählbare) Anzahl an Varianten
      \ii<2-> Jeder Variante kann unterschiedliche Felder mit sich führen.
      \ii<3-> Aufzählungsname wird Konstruktor.
      \ii<4-> Tagged variante Records (\structure{union}) sind typsicher und polymorph
      \ei
    }
    \ii<5-> Rekursiv generisch-polymorphe typsichere Aufzählungstypen {
      \begin{columns}
        \begin{column}{0.49\textwidth}
           \begin{code}[tag=Haskell]
             \begin{haskell}
               data Tree T = Leaf T
                           | Node (Tree T) (Tree T)
               freeTree :: Tree Char
               freeTree = Node
                            (Node
                               (Leaf 'X')
                               (Leaf 'Y'))
                            (Leaf 'Z')
             \end{haskell}
           \end{code}        
        \end{column}\hfill
        \begin{column}{0.49\textwidth}
          \begin{tikzpicture}[
            level distance=10mm,
            every node/.style={draw, font=\scriptsize}
            ]
            
            \node (r){Node}
              child { node {Node}
                child { node (x) {Leaf 'X'}}
                child { node {Leaf 'Y'}}}
              child { node (z){Leaf 'Z'}};

            \node[fit=(r) (x) (z),draw, dashed,
                  pin={[align=center]0:Tree Char\\==\\Ein Baum\\aus Char}] {};
          \end{tikzpicture}
        \end{column}
      \end{columns}
    }
    \ei
  \end{frame}

  \begin{frame}[fragile]{Destructuring Bind und Pattern Matching}
    \OrangeBox{Deklaration und Konstruktion von Aufzählungsobjekten ist sehr kompakt.}
    \bi
    \ii<2-> \structure{Destructuring Bind}: Zerlegen eines Objekts in seine Einzelteile {
      \bi
      \ii Muster mit der gleichen Struktur aber freien Namen
      \ii Objekt wird auf dieses Muster aufgeteilt
      \ii Freie Namen werden werden an die zerlegten Subobjekte gebunden
      \ei
      \medskip
      \begin{columns}
        \begin{column}{0.49\textwidth}
          \begin{code}[tag=Rust]
            \begin{rust}
              struct ObjT { a : i32, b : i32 }
              let ObjT {a: y0, b: y1} = obj;
            
              let (x0, x1) = (1, 2);
            \end{rust}
          \end{code}
        \end{column}\hfill
        \begin{column}<3->{0.49\textwidth}
          \begin{code}[tag=Rust]
            \begin{rust}
              let norm = match p1 {
                Point::XYZ(x,y,z) => x+y+z,
                Point::XY (x,y)   => x+y,
              }
            \end{rust}
          \end{code}
        \end{column}
      \end{columns}
    }\medskip
    \ii<3-> \structure{Pattern Matching}: Selektionsoperation mittels Destructuring Bind{
      \bi
      \ii Ähnlich, aber mächtiger wie ein switch-case in C
      \ii Vergleich eines Objekts gegen mehrere Muster und Destructuring Bind
      \ii Der entsprechende Arm wird mit den gebundenen Namen ausgeführt
      \ii Semantische Analyse kann prüfen ob alle Fälle abgedeckt sind
      \ei
    }
    \ei
  \end{frame}
#+end_src

* Funktionen als Bürger erster Klasse

#+begin_src latex
  \dividerframe{Funktionen als \\Bürger erster Klasse}

  \begin{frame}{Funktionen erster und höherer Ordnung}
    \btAnimation[width=0.7\textwidth]{range=1-3:<1->,center,padding}{fig/12-function-universe.pdf}

    \bi
    \ii \textbf{Bisher:} Wir hatten hauptsächlich \structure{Funktionen erster Ordnung} {
      \bi
      \ii Funktionen und Objekte sind zwei getrennte Universen
      \ii<2-> Funktionsanwendung kombiniert eine Funktion und mehrere Objekte\\[2ex]
      \ii<2->[$\Rightarrow$] Definition: Funktion erster Ordnung hat nur passive Objekte als Argument
      \ei
    }
    \medskip
    \ii<3-> \structure{Funktionen höhrerer Ordnung} haben Funktionen als Parameter{
      \bi
      \ii Viele Imperative Sprachen bieten bereits Funktionszeiger
      \ii \ALERT{Aber:} Funktionen sind immer noch nicht wirklich gleichberechtigt! 
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{First-Class Functions}
    \begin{center}
      \btAnimation[width=0.65\textwidth]{range=4-5:<1-end>}{fig/12-function-universe.pdf}
    \end{center}


    \bi
    \ii Im funktionalen Paradigma sind Funktionen wirklich gleichberechtigt {
      \bi
      \ii Keine kategorieller Unterschied zwischen Funktionen und Objekten
      \ii<2-> Funktionen können Argument \textbf{und} Rückggabewert sein!
      \ei
    }\medskip
    \ii<3-> Funktionen sind \ADVANTAGE{WIRKLICH} gleichberechtigt! {
      \bi
      \ii Funktionen können während der Laufzeit neu erzeugt werden.
      \ii Funktionen können komponiert und partiell angewendet werden.
      \ei
    }
    \ei

    \uncover<4->{\Large $\Rightarrow$ \btSetTab Im funktionale Paradigma werden die\\
                            \btUseTab algorithmischen Aspekte einer Sprache gestärkt!}
    \end{frame}
#+end_src

#+begin_src latex
  \dividerframe{Funktionales Programmieren}

  \begin{frame}[fragile]{Funktionen als Argumente}
    \begin{btBlock}{}
      Obwohl Python keine rein(!) funktionale Programmiersprache ist, werde ich die Beispiele, soweit es geht, als Python Code zeigen.
    \end{btBlock}
    \bigskip

    \bi
    \ii Funktionen höherer Ordnung können \structure{Auswertungsstrategien} abstrahieren{%
      \bi
      \ii \enquote{Äußere} Funktion steuert die Auswertung, die Übergebene macht die Arbeit.
      \ii Die übergebene Funktion kann mehrfach und mit unterschiedlichen Parametern aufgerufen werden. Die Ergebnisse können kombiniert werden.
      \ii Die Auswertestrategie ist parametrisierbar und wird so \advantage{wiederverwendbar}!{\\\medskip
      \begin{columns}
        \begin{column}{0.49\textwidth}
          \begin{code}[]
            \begin{py}
              def outer(fn, arr):
                  return fn(arr[0]) + fn(arr[1])

                  outer(innerA, [23, 42]) # => 6500
                  outer(innerB, [23, 42]) # => -65
            \end{py}
          \end{code}
        \end{column}\hfill
        \begin{column}{0.49\textwidth}
          \begin{code}[]
            \begin{py}
              def innerA(x):
                  return x * 100
                
              def innerB(x):
                  return x * -1
            \end{py}
          \end{code}
        \end{column}
      \end{columns}
    }\medskip
    \ii Wir hatten dies bereits bei \texttt{traverse()} und \texttt{fixpoint()} benutzt.
    \ei
    }\medskip

    \ei
  \end{frame}

  \begin{frame}[fragile]{$\lambda$/Lambda: Anonyme Funktionen}
    \bi
    \ii Bei funktionaler Programmierung braucht man ständig kleine Funktionen{%
      \bi
      \ii Entfernte Funktionsdefinition an anderer Stelle zerstört die Code-Lokalität
      \ii Außerdem ist es aufwändig sich ständig neue Funktionsnamen auszudenken
      \ei
    }\medskip
    \begin{center}
      \uncover<2->{\includegraphics[page=1,width=0.6\textwidth]{fig/12-lambda}}
    \end{center}
    \ii<2-> \textbf{Lösung}: \structure{Lambda-Ausdrücke} erzeugen ein Funktionsobjekt ohne Namen{
      \bi
      \ii Inspiriert vom, aber nicht immer äquivalent zum, Lambda-Kalkül
      \ii Bestandteile: Parameterliste und \textbf{ein} Ausdruck
      \ii Funktionsobjekt kann später aufgerufen werden
      \ei
    }
    \ei
    \begin{columns}<2->
      \begin{column}{0.65\textwidth}
        \begin{code}[]
          \begin{py}
            outer(lambda x: x * 100, [23,42]) # => 6500
            outer(lambda x: x * -1,  [23,42]) # => -65          
          \end{py}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.31\textwidth}
        \begin{code}[]
          \begin{py}
            add = lambda x, y: x+y
            add(1,2) # => 3      
          \end{py}
        \end{code}
      \end{column}\hfill\mbox{}
    \end{columns}

  \end{frame}

  \begin{frame}{Beispiel: Listenmanipulationen}
    \bi
    \ii Listen sind die funktionale \enquote{Brot-und-Butter} Datenstruktur{
      \bi
      \ii Funktionen höherer Ordnung bieten standardisierte Auswertungsstrategien
      \ii Diese Funktionen ersetzen teilweise iterative Sprachelemente
      \ei
    }
    \ei

    \medskip
    \begin{columns}[t]
      \begin{column}<2->{0.32\textwidth}
        \includegraphics[width=\textwidth,page=1]{fig/12-list-manipulation}
      
        \medskip
        { \small
          \codebox{map()} bildet jedes Element mit Hilfe der übergebenen Funktion ab und konstruiert daraus eine neue Ergebnisliste.}

      \end{column}\hfill
      \begin{column}<3->{0.32\textwidth}
        \includegraphics[width=\textwidth,page=2]{fig/12-list-manipulation}


        \medskip
        { \small
          \codebox{filter()} prüft jedes Element mittels einem Prädikat und konstruiert eine Liste \enquote{erfolgreichen} Elementen.}

      \end{column}\hfill
      \begin{column}<4->{0.32\textwidth}
        \includegraphics[width=\textwidth,page=3]{fig/12-list-manipulation}

        \medskip
        { \small
          \codebox{reduce()} reduziert eine Liste zu einem Wert indem die übergebene Funktion als Infixoperator angewendet wird.}
      \end{column}
    \end{columns}
  \end{frame}

  \begin{frame}[fragile]{Komposition von Funktionen}

    \bi
    \ii \structure{Funktionskomposition} ist die Hintereinanderausführung von Funktionen{
      \bi
      \ii Aus zwei Funktionsobjekten kreieren wir ein neues Funktionsobjekt
      \ii Die neue Funktion wendet beide Funktionen in Reihe an.\\
          Das Ergebnis der ersten wird zur Eingabe der zweiten.
      \ii Rückgabetypen und Parametertypen müssen zueinander passen
      \ei
    }
    \ei

    \begin{center}
      \includegraphics[page=1,width=0.8\textwidth]{fig/12-composition}
    \end{center}

  \begin{columns}<2->
    \begin{column}{0.49\textwidth}
      \begin{code}[tag=Python]
        \begin{py}
          def inc(x):
             return x + 1

          def compose(f, g):
             return lambda x: f(g(x))
           
          x = compose(inc, inc)
          x(0) # => 2
        \end{py}
      \end{code}
    \end{column}\hfill
    \begin{column}{0.49\textwidth}
      \begin{code}[tag=Haskell]
        \begin{haskell}
          inc = \x -> x +1
          x   = inc . inc
        
          x(0) # => 2
        \end{haskell}
      \end{code}
    
      Haskell bietet Komposition sogar als \structure{Infixoperator} \enquote{.}, angelehnt an $f \circ g$:
    \end{column}
  \end{columns}


  \end{frame}

  \begin{frame}[fragile]{Partielle Anwendung von Funktionen}
    \bi
    \ii \structure{Partielle Anwendung} bindet einige Parameter einer Funktion{
      \bi
      \ii \textbf{Beobachtung}: Funktionen brauchen all ihre Parameter zur Ausführung
      \ii \textbf{Idee}: Wir könnten einige Parameter mit bekannten Argumenten vorbelegen
      \ii Erzeugen eines Funktionsobjekts mit geringerer Stelligkeit
      \ei
    }
    \ei

    \begin{center}
      \includegraphics[page=1,width=0.8\textwidth]{fig/12-partial}
    \end{center}

    \begin{columns}<2->
    \begin{column}{0.49\textwidth}
      \begin{code}[tag=Python]
        \begin{py}
          def add(a,b):
             return a + b

          def partial(f, *a0):
             return lambda *a1: f(*(a0+a1))
           
          inc = partial(add, 1)
          inc(0) # => 1
        \end{py}
      \end{code}
    \end{column}\hfill
    \begin{column}{0.49\textwidth}
      \begin{code}[tag=Haskell]
        \begin{haskell}
          add :: Int -> (Int -> Int)
          add a b = a + b

          inc = (add 1)
          inc(1) -- => 2
        \end{haskell}
      \end{code}
    
      Haskell bietet \structure{Currying}, wo jede Funktion standardmäßig partiell anwendbar ist.
    \end{column}
  \end{columns}
  \end{frame}

  \begin{frame}[t,fragile]{Beispiel: Eine Verarbeitungskette}
    \begin{columns}
      \begin{column}{0.25\textwidth}
        \btAnimation[width=0.9\textwidth]{1:<1-3>,range=2-4:<4->}{fig/12-points}
      \end{column}\hfill
      \begin{column}{0.74\textwidth}
        \textbf{Aufgabe}: Gegeben eine 2 dimensionale Punktwolke, finden Sie innerhalb des Einheitskreises die größte Distanz, die ein Punkt zum Ursprung hat.

        \begin{code}[]
          \begin{py}
            points = [(-0.3,0.4),  (-0.3, -0.2),
                      (0.6,-0.4),  (1, 1)]
          \end{py}
        \end{code}

      \end{column}
    \end{columns}
    \begin{columns}
      \begin{column}<2->{0.4\textwidth}
        \begin{code}[]\ttfamily\footnotesize
          \def\I{\mbox{\hspace{2ex}}}%
          def norm(N, point): ...\\
          \uncover<6->{maxD = \textbackslash}\\
           \I\uncover<6->{reduce(max,}\\
           \I\I\uncover<5->{filter(lambda d: d <= 1.0,}\\
           \I\I\I\uncover<4->{map(}\uncover<3->{partial(norm, 2)}\uncover<4->{,}\\
           \I\I\I\I\uncover<4->{points)}\uncover<5->{)}\uncover<6->{)}\\
       \end{code}
      \end{column}\hfill
      \begin{column}{0.59\textwidth}
        \bii
        \ii<2-> Generische Normierungsfunktion $\|\cdot\|_N$
        \ii<3-> Die Distanz zum Ursprung ist die 2-Norm
        \ii<4-> Bilde jeden Punkt auf seine Distanz ab
        \ii<5-> Filtere Distanzen die $\le 1$ sind
        \ii<6-> Reduziere Distanzen zur maximalen Distanz
        \eii

      \end{column}
    \end{columns}
    \medskip



    \begin{center}
      \uncover<2->{\btAnimation[height=2cm]{1:<1-2>,range=2-5:<3->}{fig/12-point-pipeline}}
    \end{center}
  \end{frame}

#+end_src

* Funktionale Ein-/Ausgabe

#+begin_src latex
  \dividerframe{Funktionale\\Ein-/Ausgabe}

  \begin{frame}{Keine Seiteneffekte $\rightarrow$ Keine Schokolade}
    \bi
    \ii \textbf{Erinnerung}: Im rein-funktionalen Paradigma gibt es keine Seiteneffekte{%
      \bi
      \ii Kein veränderlicher Zustand, keine Variablen, ausschließlich \structure{pure Funktionen}
      \ii[$\Rightarrow$] Jegliche Art der Ein- oder Ausgabe sind verbotene Seiteneffekte
      \ii[$\Rightarrow$] Keine Terminalausgabe, keine Dateisystem, kein Netzwerk
      \ei
    }
    \ei
  
    \begin{center}
      \OrangeBox{Wie soll man damit nützliche Programme schreiben?}
    \end{center}

    \bi
    \ii<2-> \structure{Functional-Style Programming} als Funktionales Paradigma Light{
      \bi
      \ii Programmierstil der funktionale Elemente in anderen Sprachen verwendet
      \ii Komposition, partielle Applikation, oder \texttt{map()} geht auch mit Seiteneffekten
      \ii Trennung des Programs in Funktionen mit und ohne Seiteneffekte\\[2ex]
      \ii[$\Rightarrow$] Ein effektiver Entwickler setzt Seiteneffekte gezielt ein
      \ei
    }\medskip
    \ii<3-> Funktionale Elemente verbreiten sich unter den Sprachen {
      \bi
      \ii Skriptsprachen haben meist funktionale Aspekte (Python, Ruby, Lua,\ldots)
      \ii Die Tendenz bei übersetzten Sprachen geht auch zu funktionalen Elementen.
      \ei
    }
    \ei
  \end{frame}


  \begin{frame}{Und bei rein funktionalen Sprachen?}
    \bi
    \ii Nur wenige Sprachen verbieten Seiteneffekte völlig{
      \bi
      \ii \structure{Haskell} ist das prominenteste Beispiel
      \ii Es gibt noch weitere Forschungssprachen: Clean, Mercury\\[1ex]
      \ei
    }\medskip
    \ii<2-> In Haskell wird I/O über die  \structure{I/O Monade} gesteuert{\medskip
      \begin{columns}
        \begin{column}{0.6\textwidth}
            \btAnimation[width=\textwidth]{1:<1-2>,range=2-3:<3-end>,center,padding}{fig/12-haskell-io}
        \end{column}\hfill
        \begin{column}{0.38\textwidth}
          \bi
          \ii \textbf{Intuition}: Die I/O Monade transformiert das Universum
          \ii<3-> Sie steuert die Ausführung monadisch-komponierter Funktionen
          \ii<3-> Ruft Funktionen mit Welt-Informationen auf und koppelt Ergebnisse zurück
          \ii<4-> Unten in der Aufrufhierarchie sind nur pure Funktionen
          \ei
        \end{column}
      \end{columns}

    }
    \ei
  \end{frame}

  \begin{frame}[fragile]{I/O Monade in Haskell}
    \begin{columns}
      \begin{column}{0.49\textwidth}
        \begin{code}
          \begin{haskell}
            printUpCase :: String -> IO ()
            printUpCase l = putStrLn (upCase l)

            main :: IO ()
            main = (getLine >>= printUpCase)
                   >> main          
          \end{haskell}
        \end{code}

      \end{column}\hfill
      \begin{column}<2->{0.49\textwidth}
        \begin{code}[]
          \begin{haskell}
            main = do
                l <- getLine
                putStrLn (upCase l)
                main
          \end{haskell}
        \end{code}
      \end{column}
    \end{columns}

    \bi
    \ii Die I/O  Monade ist \enquote{magisch} im Haskell Universum {
      \bi
      \ii Im Programm komponiert man nur Funktionen zusammen (\texttt{>>}, \texttt{>>=})
      \ii Virtuelle Haskell-Maschine entimmt das Monadenobjekt \texttt{main} und führt es aus.
      \ii<2-> \structure{Synaktischer Zucker} erleichtert die Monadenkomposition
      \ei
    }\medskip
    \ii<3-> Monaden sind ein allgemeineres und mächtigeres Konzept{
      \bi
      \ii Monaden sind ein Konzept aus der \structure{Kategorientheorie}
      \ii Monaden kapsel Strategien zur Auswertereihenfolge und zum Datenflusss
      \ii Es gibt viele spannende Monadentypen: Maybe, State, Writer
      \ii Wir können und werden keine davon hier besprechen\ldots
      \ei
    }
    \ei
  \end{frame}
#+end_src


* Zusammenfassung
#+begin_src latex
  \begin{frame}{Zusammenfassung}
    \bi
    \ii \structure{Veränderlicher Zustand} ist problematisch in großen Softwareprojekten{
      \bi
      \ii Viele Prozeduren interagiern mit und verändern eine Vielzahl an Objekten
      \ii Zustand ist am Quellcode nicht sichtbar und daher unübersichtlich
      \ei
    }\medskip
    \ii Das (rein) \structure{funktionale Paradigma} verzichtet auf veränderlichen Zustand{%
      \bi
      \ii Variablen können nur einmal an ein Objekt gebunden werden
      \ii Listen und Aufzählungstypen mit Nutzlast sind nützliche Datentypen
      \ei
    }\medskip
    \ii Seiteneffektfreie Funktionen werden \structure{Bürger erster Klasse}{
      \bi
      \ii Funktionsobjekte sind als Argumente und Rückgabewerte gleichberechtigt
      \ii Komposition, Partielle Applikation und Listenfunktionen
      \ei
    }\medskip
    \ii \structure{Ein- und Ausgabe} kann nicht Seiteneffektfrei sein {
      \bi
      \ii Der funktionale Programmierstil ist erlaubt veränderlichen Zustand
      \ii Rein funktionale Sprachen transformieren die Welt über \structure{Monaden} 
      \ei
    }
    \ei

  \end{frame}
#+end_src
