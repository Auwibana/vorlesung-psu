#+TITLE: Programmiersprachen und Übersetzer
#+SUBTITLE: 04 - Namen
#+SETUPFILE: setup.org
#+INCLUDE: export-prologue.org
#+PROPERTY: header-args:latex :tangle yes :noweb yes :tangle-macros yes :tangle-prologue topic :tangle-epilogue endtopic :exports none

#+NAME: topic
#+BEGIN_SRC latex :tangle no
\psuSectionStart{{{{property(ITEM)}}}}{{{{n(block)}}}}
#+END_SRC

#+NAME: endtopic
#+BEGIN_SRC latex :tangle no
\psuSectionStop{{{{property(ITEM)}}}}{{{{n(block,-)}}}}
#+END_SRC

* Gedanken zu dieser Vorlesung                                     :noexport:

Was lernt man aus dieser Vorlesung für die Ziele effektiv und effizient?
 - Die Regeln der Namensauflösung etablieren die Links zwischen Definition und  Benutzung [effektiv]
 - Dynamische Namensauflösung kostet immer Laufzeit                                       [effizient]


* Was ist ein "Name"?
:PROPERTIES:
:CUSTOM_ID: 04-einleitung
:END:

#+begin_src latex
  \subtitle{{{{subtitle()}}}}
  \begin{frame}
    \maketitle
  \end{frame}

  \begin{frame}{Wieso sollte ich mich mit Namen beschäftigen?}
    \begin{center}
      \includegraphics[page=11,width=0.6\linewidth]{fig/01-overview-small}
    \end{center}
    \bi
    \ii Die Namensauflösung ist grundlegend für das Programmverständnis{
      \bi
      \ii Namen etablieren \structure{Querverbindungen} zu Laufzeitobjekten kontextsensitiv.
      \ii Das informatische Grundprinzip von \structure{Information Hiding} hängt an Namen.
      \ei
    }
    \ei
  \end{frame}

  \lstdefinestyle{defuse}{
    moredelim=**[is][{\btHL[fill=safegreen!50]<2-3>}]{!}{!},
    moredelim=**[is][{\btHL[fill=safeblue!50]<3>}]{@}{@},
    moredelim=**[is][{\btHL[fill=safeblue!50]<3->}]{^u}{^},
    moredelim=**[is][{\btHL[fill=safegreen!50]<3->}]{^d}{^},
    escapechar=`,
  }
  \begin{frame}[fragile]{"Motivierendes" Beispiel: C++}
    \def\p#1{\tikzmark{p#1}}
    \begin{columns}[t]
      \begin{column}{0.49\textwidth}
  \begin{code}[]
    \begin{CPP}[style=defuse]
      namespace `\p5`^dA^`\p{55}` {
        typedef int !type_t!;
        class ^dB^`\p6` {
          private:   @int@ !x!;
          protected: @int@ `\p7`^dy^;
          public:    @int@ !z!;
            virtual @type_t@ !func!();
        };
      }

      class `\p3`^dC^`\p{34}` : public `\p4`^uA::B^ {
        virtual @A::type_t@ !func!();
      };

      using !ret_t! = @A::type_t@;
    \end{CPP}
  \end{code}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \begin{code}[tag=C++]
          \begin{CPP}[style=defuse]
            @ret_t@ @A::B::@!func!() {
              return @this@->@x@;
            }

            @ret_t@ `\p2`^uC::^!func!() {
              return `\p1`^uy^`\p8`;
            }

            @int@ !main!() {
              @A::B@ *!obj! = new @C@();
              @obj@->@z@ = 42;
              return @obj@->@func@();
            }
          \end{CPP}
        \end{code}
      \end{column}
    \end{columns}
    \begin{tikzpicture}[remember picture,overlay]
      \only<4->{
        \draw[thick,srared,->] (pic cs:p1) --(pic cs:p2);
        \draw[thick,srared,->] (pic cs:p2) --($(pic cs:p34)+(up:2pt)$);
        \draw[thick,srared,->] (pic cs:p34) --(pic cs:p4);
        \draw[thick,srared,->] (pic cs:p4) --(pic cs:p55);
        \draw[thick,srared,->] (pic cs:p5) --(pic cs:p6);
        \draw[thick,srared,->] (pic cs:p6) --(pic cs:p7);
      }
      \only<5->{
        \draw[ultra thin] (pic cs:p8) -- ++(-45:2em) node[align=left,anchor=west,fill=badbee!50] {type = int\\addr = this + 4;};
      }
    \end{tikzpicture}
    \medskip
    \bi
    \ii Namen werden überall im Programm \strut\only<2->{\colorbox{safegreen!50}}{deklariert} und \only<3->{\colorbox{safeblue!50}}{referenziert}.
    \ii<4-> Die \textbf{Namensauflösung} verbindet den Namen mit dem Objekt.
    \ii<5-> \colorbox{badbee!50}{Information}sfluss entlang dieser Kanten quer zum AST
    \ei
  \end{frame}

  \begin{frame}{Grundbegriffe: Namen und Namensauflößung}
    \begin{center}
      \btImage[text width=0.8\textwidth,align=center,]{fig/04-objects}
    \end{center}

    \bi
    \ii \STRUCTURE{Name}: Symbolische und Statische Objektreferenz im Programmcode{
      \bi
      \ii \structure{Abstraktion}: Namen ersetzen die Verwendung konkreter Speicheradressen
      \ii \structure{Dokumentation}: Namen transportieren Informationen zwischen Entwicklern
      \ii \structure{Querverbindung}: Referenz von Deklarationen quer zum AST
      \ei
    }\medskip
    \ii<2-> \STRUCTURE{Namensauflösung}: Adresse für referenziertes Objekt berechnen. {
      \bi
      \ii Wird vom Übersetzer teilweise vorbereitet oder schon ganz durchgeführt.
      \ii Essentieller Teil der semantischen Analyse (\texttt{name 'x' is not defined})
      \ii Sowohl statischen (Bezeichner), als auch dynamische (Pointer), Informationen
      \ei
    }
    \ei

    \medskip
    \OrangeBox<3->{
      Im Übersetzer suchen wir (oft) nur die \textbf{Definitionstelle} einer Variable
    }
  \end{frame}
  #+end_src

#+begin_src latex
  \begin{frame}[t]{Grundbegriffe: Definition, Deklaration, Namensraum}
    \btAnimation[]{center,range=1-3:<1->}{fig/04-scopes}
    \bi
    \ii \structure{Definition} eines Namens für einen AST Knoten\hfill\only<2->{\texttt{\LET <NAME>}} {
      \bi
      \ii Um AST Knoten (Variable) wieder zu finden, geben wir ihnen \alert{einen} Namen.
      \ii Geht einher mit der Allokation eines Objekts (Variablendefinition).
      \ei
    }\smallskip
    \ii \structure{Deklaration} eines entfernten Namens\hfill\only<2->{\texttt{\DECL <NAME>}}{
      \bi
      \ii Bekanntmachung, dass es einen AST Knoten mit diesem Namen gibt.
      \ii Notwendig bei getrennter Übersetzung (C/C++) und mehreren Quelldateien.
      \ii Jede Definition ist auch eine Deklaration.
      \ei
    }\smallskip
    \ii \structure{Namensraum} ist ein Container für deklarierte Namen \hfill\only<2->{\texttt{\{...\}}}{
      \bi
      \ii Beschränken die Gültigkeit eines deklarierten Namens
      \ii \structure{Schachtelung}: Ein Namensraum kann auch weitere Namensräume beinhalten .
      \ei
    }
    \ei
  \end{frame}
#+end_src

* Statische Namensauflößung
** Implizite Namensauflösung
#+begin_src latex
\dividerframe{Statische Namensauflößung}
  \begin{frame}{Implizite Namensauflösung}
    \begin{columns}
      \begin{column}{0.3\textwidth}
        \btAnimation[width=\textwidth]{range=1-4:<1->}{fig/04-closest-match}
      \end{column}\hfill
      \begin{column}{0.65\textwidth}
        \bi
        \ii \enquote{Definition before Use}{
          \bi
          \ii Deklaration in einem umgebenden Namensraum.
          \ii Reihenfolge von Deklaration und Referenz teilweise egal.
          \ei
        }\medskip
        \ii<2-> \enquote{Closest-nested scope rule} (CNSR){
          \bi
          \ii Suche nach Deklarationen von Innen nach Außen
          \ii Bei mehreren Möglichkeiten: Nimm die Innerste.
          \ii Im AST: Wir suchen von unten nach oben.
          \ei
        }\medskip
        \ii<3-> Deklarationen können \structure{verdeckt} werden {
          \bi
          \ii Innere Deklarationen verdecken die Äußeren
          \ii Die äußere Deklaration bleibt \structure{gültig}, ist aber innen nicht mehr \structure{sichtbar}.
          \ei
        }
        \ei
      \end{column}
    \end{columns}
  \end{frame}
  #+end_src
** Explizite Namensräume
#+begin_src latex
  \begin{frame}[fragile]{Explizite Namensräume}
    \begin{btBlock}[type=alert]{\ALERT{Problem:} Referenzen nur entlang des ASTs möglich}
      Die implizite Namensauflösung erlaubt uns nur Namen zu referenzieren, die direkt über uns im AST sind. Namen aus einem anderen Namensraum (NS) sind nicht erreichbar
    \end{btBlock}
    \medskip
    \begin{columns}
      \begin{column}{0.25\textwidth}
        \btAnimation[width=\textwidth]{range=1-3:<1->,3:<4->}{fig/04-explicit-namespace}
      \end{column}\hfill
      \begin{column}{0.70\textwidth}
        \bi
        \ii<2-> NS bekommt Namen im umgebenden NS {
          \bi
          \ii Namen aus einem NS anfordern mit \enquote{\texttt{::}}
          \ii Der Trenner \texttt{::} ist wie das \enquote{\texttt{/}} bei Pfaden
          \ii \alert<2>{Grundlegende Erweiterung} des Namensraumkonzepts
          \ei
        }
        \ii<3-> Impliziter Wurzelnamensraum {
          \bi
          \ii Ermöglicht es alle Namensräume zu adressieren
          \ii Vollständig qualifizierter Pfad ist eindeutig
          \ei
        }
        \ii<4-> In C++: \enquote{\texttt{\LET <X>=...}} = \enquote{\texttt{namespace <X>}}{
          \begin{code}[tag=C++]
            \begin{CPP}
              namespace N { namespace M {
                  int A;
              } }
            \end{CPP}
          \end{code}
        }
        \ei
      \end{column}
    \end{columns}

  \end{frame}
#+end_src
- Expliziter Auflösungspfad (Qualified Name)

** Import von Namen
#+begin_src latex
  \begin{frame}[fragile]{Import von entfernten Namen}
    \begin{btBlock}[type=alert]{\ALERT{Problem:} Explizite Auflößungspfade sind zu lange}
      Ständig den vollständigen Namen (\texttt{::A::B::C}) einer entfernten Deklaration zu verwenden ist umständlich viel Schreibarbeit.
    \end{btBlock}
  \medskip
    \begin{columns}
      \begin{column}{0.29\textwidth}
        \btAnimation[width=\textwidth]{range=1-4:<1->,4:<5->}{fig/04-import}
      \end{column}\hfill
      \begin{column}{0.67\textwidth}
        \bi
        \ii Jeder NS hat verschiedene Namensmengen {
          \bi
          \ii Die direkt deklarierten Namen
          \ii Die implizit sichtbaren Namen
          \ii Den Wurzelnamensraum
          \ei
        }\smallskip
        \ii<2-> Viele Sprachen erlauben \structure{Import} von Namen{
          \bi
          \ii \codeinline{import <NAME>} erweitert die deklarierten Namen
          \ii Explizite Namensliste oder Importe mit \codeinline{*}
          \ii Importe geschehen oft implizit (z.B. Vererbung)
          \ei
        }\smallskip
        \ii<4-> Importe sind (erstmal) transitiv {
          \bi
          \ii Importiere Namen können importiert werden
          \ii \codeinline{import ::X::*} enthält auch \codeinline{::N::M::B}
          \ei
        }
        \ei
      \end{column}
    \end{columns}
  \end{frame}
#+end_src

** Einschränkung der Sichtbarkeit
#+begin_src latex
  \begin{frame}{Einschränkung der Sichtbarkeit}
    \begin{btBlock}[type=alert]{\ALERT{Ziel:} Wir wollen Interna der Implementierung verstecken}
      Zum Zwecke des \textbf{Information Hiding} wollen wir manche Namen nur \alert{innerhalb} eines Namensraumes sichtbar machen.
    \end{btBlock}
    \smallskip

    \bi
    \ii<2-> Definitionen bekommen ein weiteres Attribut\hfill\texttt{\LETi <NAME>}{
      \bi
      \ii Interne Definitionen können nur über implizite Auflösung gefunden werden.
      \ii Name wird unsichtbar für alles außerhalb des aktuellen NS
      \ii Wir können interne Namen ändern ohne externe Komponenten anzufassen.
      \ei
    }
    \ei
    \begin{columns}<3->
      \begin{column}{0.22\textwidth}
        \btAnimation[width=\textwidth]{center,range=1-2:<3->}{fig/04-private}
      \end{column}\hfill
      \begin{column}{0.72\textwidth}
        \bi
        \ii Zugriff auf einen internen Namen ist nicht erlaubt\\[0.5ex]{
          Übersetzer findet zwar die Definition, meldet aber aufgrund des Attributs einen Fehler.
          \smallskip
        }
        \ii Interne Namen werden beim Import übersprungen.
        \ii<4-> Namensräume können Standardattribute haben{
          \bi
          \ii \texttt{\LETi} macht einen Namen nur intern sichtbar
          \ii \texttt{\LETe} macht einen Namen auch extern sichtbar
          \ei
        }
        \ei
      \end{column}
    \end{columns}
  \end{frame}

  \begin{frame}[fragile]{Fallbeispiel: Java Packages}
    \begin{columns}
      \begin{column}{0.35\textwidth}
        \begin{code}[]
          \begin{java}
            package N;
            public class A {
              public static
                void f1() { }
            }
          \end{java}
        \end{code}

        \begin{code}[]
          \begin{java}
            package M;
            import N.A;

            class B {
              static void f2() {
                A.f1();
              }
            }
          \end{java}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.60\textwidth}
        \btAnimation[width=\textwidth]{1:<1>}{fig/04-java-packages}
      \end{column}
    \end{columns}

  \end{frame}
#+end_src
- introduce `export[public]', `export[protected]'
- Export und Importliste

- Erster Haltepunkt: Module

* Dynamische Namensauflösung
** Binding Time
#+begin_src latex
  \dividerframe{Dynamische Namensauflösung}
  \begin{frame}{Zeitpunkt der Namensbindung}
    \textbf{Bisher:} Zu einem Namen haben wir bisher nur die Definitionsstelle gefunden, nicht aber das Objekt bzw. seine Adresse.\\[2ex]

    \ALERT{Aber:} Nicht zu jedem Zeitpunkt ist mit einem Namen wirklich ein existierendes Objekt verbunden. \\[2ex]

    \pause
     \structure{Binding time:} Zeitpunkt der Bindung zwischen Name und Objekt{
      \btUseExtraItemSep
      \bii
      \ii<+-> \structure{Compile time:} Der Übersetzer kennt Adresse des Objekts bereits.\\
          \textit{Beispiel: Speicherbereich einer Hardwarekomponente.}
      \ii<+-> \structure{Link time:}    Die Adresse wird beim Erstellen der Binärdatei ermittelt.\\
          \textit{Beispiel: Funktionen und globale Variablen}
      \ii<.-> \structure{Load time:}    Die Adresse wird beim Starten des Prozesses festgelegt.\\
          \textit{Beispiel: Code in Bibliotheken}
      \ii<+-> \structure{Run time:}     Die Adresse wird erst zur Laufzeit ermittelt.\\
          \textit{Beispiel: Lokale Variablen und Objekte am Heap}
      \eii
    }
  \end{frame}

  \begin{frame}[fragile]{Zeitpunkt der Namensauflösung}
    \bi
    \ii Adressberechnung ist \ALERT{immer} erst nach der Binding Time möglich.{
      \bi
      \ii Wenn kein Objekt assoziiert ist, können wir auch keine Adresse ausrechnen.
      \ii \structure{Partielle Namensauflösung}: Vorschrift und Werte vorberechnen.
      \ei
    }
    \begin{columns}
      \begin{column}[b]{0.35\textwidth}
        \begin{code}[]
          \begin{C}
            struct foo {
              int  a;
              int *p;
            } obj;
            ...
            @*(obj.p)@ = ...
          \end{C}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.64\textwidth}
        \btAnimation[width=\textwidth]{range=1-8:<1->}{fig/04-binding-time}
      \end{column}
    \end{columns}

    \ei
  \end{frame}

#+end_src

** Instantiierbare Namensräume
#+begin_src latex
  \begin{frame}[fragile]{Instanziierbare Namensräume}

    \begin{columns}
      \begin{column}{0.35\textwidth}
        \begin{code}[tag=C++]
          \begin{CPP}
            namespace N {
              int a;
              int b;
            };
            N::a
          \end{CPP}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.64\textwidth}
        \textbf{Bisher} gab es von jedem Namensraum \alert{genau eine Instanz}.
        Daher kann jeder enthaltene Name nur ein Objekt referenzieren.
      \end{column}
    \end{columns}

    \bi
    \ii<2-> \structure{Namensräume} mehrfach als eigene Objekte instantiieren{
      \bi
      \ii Jedes Laufzeitobjekt enthält eine Bindung für die deklarierten Namen
      \ii Laufzeitdaten werden zur Unterscheidung gebraucht (Objektadresse)
      \ei
    }
    \ei
    \begin{columns}<3->
      \begin{column}{0.35\textwidth}
        \begin{code}[tag=C]
          \begin{C}
            struct N {
              int a;
              int b;
            };

            struct N objA;
            struct N objB;

          \end{C}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.63\textwidth}
        \btUseExtraItemSep
        \bii
        \ii \codebox{objA.a} und \codebox{objB.a} sind verschiedenen
        \ii \structure{Punktoperator} macht dynamische Auflösung\\{
          \texttt{<obj>.<name>}: \codeinline{&obj + offset(N::name))}
        }
        \ii Java unterscheidet syntaktisch nicht zwischen dynamischer und statischer Namensauflösung
        \eii
      \end{column}
    \end{columns}

    \medskip
    \bi
    \ii<4-> Instanziierbare Namensräume sind ein \structure{Schlüsselkonzept} der Informatik
    \ei
  \end{frame}


  \begin{frame}[fragile]{Instanziierbare Namensräume (II)}
    \begin{columns}
      \begin{column}{0.35\textwidth}
        \begin{code}
          \begin{C}
            struct N {
              int a;
              int b;
            };

            struct N objA;
          \end{C}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.35\textwidth}
        \includegraphics[width=\textwidth]{fig/04-instances}
      \end{column}\hfill
    \end{columns}
    \medskip
    \bi
    \ii In unserer minimalen Namensraumsprache führen wir \LETd ein. {
      \bi
      \ii \texttt{\LETd <DST> = <SRC>} kopiert den NS \texttt{SRC} unter dem Namen \texttt{DST}
      \ii Wir verwenden weiterhin nur den \texttt{::} Operator.
      \ii Die Auflösung in einem \texttt{\LETd} Namensraum erforder \textbf{D}ynamisches Wissen.
      \ei
    }
    \ei
  \end{frame}

#+end_src

#+begin_src latex
  \begin{frame}[fragile]{Fallbeispiel: Klassen in C++}
    \begin{columns}[t]
      \begin{column}{0.35\textwidth}
        \begin{code}[]
          \begin{CPP}
            class B {
              int a;
             public:
              int b;
              int f1(){
                return a+b;
              }
            };
            B objB;
          \end{CPP}
        \end{code}
        \begin{code}<2->[]
          \begin{CPP}
            class S : public B {
              int c;
            }
            S objS;
          \end{CPP}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.25\textwidth}
        \btAnimation[width=\textwidth]{raisebox,1:<1>,2:<2->}{fig/04-instances-cpp}
      \end{column}\hfill
      \begin{column}{0.30\textwidth}
        Kombination aus:
        \bii
        \ii Namensräumen
        \ii Sichtbarkeit
        \ii Instantiierbar
        \ii<2-> Import
        \eii

        \medskip

        \uncover<3->{
          Feinheiten:
          \bii
          \ii \texttt{protected} Deklarationen ändern ihre Sichtbarkeit beim vererben.
          \ii \texttt{struct} ist per default \texttt{[E]}.
          \ii Man kann \texttt{public}, \texttt{protected} und \texttt{private} erben.
          \eii
        }

      \end{column}

    \end{columns}
  \end{frame}

  \begin{frame}[fragile]{Statische Felder in Klassen}
    \textbf{Beichte des Dozenten}: Ich habe \texttt{static} lange nicht verstanden.\\[2ex]

    \bi
    \ii<2-> In Klassenobjekten wird jeder Name dynamisch aufgelöst. {
      \bi
      \ii Manchmal sollen Namen dennoch dasselbe Objekt referenzieren.
      \ii \texttt{\LETs} setzt die dynamische Namensauflösung außer Kraft
      \ei
      \btAnimation[width=0.9\textwidth]{center,padding,1:<1-2>,2:<3->}{fig/04-static}
    }
    \ii<4-> Statische lokale Variablen in C/C++ funktionieren genauso.{
      \bi
      \ii Die dynamische Information um die Call-Frame wird ignoriert.
      \ii Die Variable behält, weil sie immer das selbe Objekt referenziert, ihren Wert.\\[1ex]
      \codeinline[style=C]{int counter() { static int i = 0; return i++; }}
      \ei
    }
    \ei

    \end{frame}

#+end_src

** Function-Call Frames
#+begin_src latex
  \begin{frame}[fragile]{Funktionen und lokale Variablen}
    \begin{columns}
      \hfill
      \begin{column}{0.3\textwidth}
        \begin{code}[tag=C]
          \begin{C}
            int f1(int L) {
              return L+1;
            }
          \end{C}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.3\textwidth}
        \includegraphics[height=1.5cm]{fig/04-functions}
      \end{column}
      \hfill
    \end{columns}
    \smallskip
    \bi
    \ii Funktionen öffnen für ihren Rumpf einen eigenen Namensraum{
      \bi
      \ii Parameter\alert{deklarationen} werden zu Namen innerhalb der Funktion.
      \ii \structure{Lokale Variablen} (und Parameter) sind nur innerhalb der Funktion sichtbar.
      \ii Die Namen lokaler Variablen können Globale verdecken. (Folge von CNSR)
      \ei
    }
    \ei
    \begin{columns}[t]<2->
      \begin{column}{0.49\textwidth}
        \begin{code}[tag=C]
          \lstdefinestyle{defuse}{
            moredelim=**[is][{\btHL[fill=refcolor]<3->}]{^u}{^},
            moredelim=**[is][{\btHL[fill=letcolor]<3->}]{^d}{^}
          }
          \begin{C}[style=defuse]
            int ^dfak^(int n) {
              if (n < 1) {
                return 1;
              }
              int tmp = ^ufak^(n-1);

              return n * tmp;
            }
          \end{C}
        \end{code}
        \smallskip
        \OrangeBox{Geschachtelte Funktionen?}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \begin{code}[tag=JavaScript]
          \lstdefinestyle{defuse}{
            moredelim=**[is][{\btHL[fill=refcolor]<4->}]{^u}{^},
            moredelim=**[is][{\btHL[fill=letcolor]<4->}]{^d}{^},
            escapechar=`
          }
          \begin{JS}[style=defuse]
            function outer() {
              var ^dx^ = 0;
              function ^dinner^() {
                ``^ux^ = ^ux^ + 1;
                return ^ux^;
              }
              return ^uinner^;
            }
          \end{JS}
        \end{code}

        \smallskip\OrangeBox{Funktionen schateln?}
      \end{column}
    \end{columns}
  \end{frame}

  \begin{frame}{Function-Call Frames und Rekursive Funktionen}
    \textbf{Früher:} Keine Unterstützung für rekursiven Funktionen (z.B. Fortran 77) \medskip

    \bi
    \ii <2-> Funktionen werde instantiierbar; jeder Aufruf erzeugt einen \structure{Call Frame}.{
      \bi
      \ii<4-> Ein Call-Frame hat einen Zeiger auf seinen aufrufenden Namensraum (caller)
      \ii<5-> Dynamische Namensauflösung erfolgt \alert<4>{relativ zum Stackpointer} (SP)
      \ei
      \medskip
      \btAnimation[width=0.65\textwidth]{center,1:<1>,range=1-9:<2->}{fig/04-call-frame}
    }
    \ei
  \end{frame}


  \begin{frame}{Geschachtelte Funktionen und Closures}
    \bi
    \ii Funktionen in Funktionen lassen Fragen über die Bindung aufkommen.{
      \bi
      \ii Die Deklaration zu einer Referenz ist nach CNSR klar
      \ii \ALERT{Aber}: Wir brauchen einen \texttt{outer}-Call-Frame um \texttt{x} vollständig aufzulösen
      \ei
      \btAnimation[width=0.65\textwidth]{padding,center,range=1-9:<1->}{fig/04-closure}
    }
    \ii<2-> \structure{Lexikalisches Scoping}: Funktionen können \alert<5->{Zustand} halten{
      \bi
      \ii<3-> Bei der Definition von \texttt{inner} wird ein \structure{Closure} Objekt erstellt.
      \ii<4-> Die Closure speichert den Frame über die Ausführung von \texttt{outer()} hinaus.
      \ei
    }
    \ei
  \end{frame}
#+end_src
- Lokale Variablen
- Rekursive Funktionen
- Geschachtelte Funktionsdeklarationen

* Overloading und Dynamic Dispatch
** Uneindeutige Namensauflösung
#+begin_src latex
  \dividerframe{Überladene Funktionen}
  \begin{frame}[fragile]{Pointer, Aliase und Uneindeutigkeit}
    \textbf{Wiederholung:} Namensauflösung findet das Objekt zu einem Namen.\medskip
    \bi
    \ii<2-> Ein \structure{Zeiger} speichert das Ergebnis einer vollständigen Namensauflösung.{
      \bi
      \ii Der \codeinline{&(<Namenspfad>)}-Operator löst den Pfad auf und gibt eine Adrese zurück
      \ii<3-> Der \codeinline{(*<Name>)}-Operator macht das von Name referenzierte Objekt zugänglich
      \ei
      \begin{columns}
        \begin{column}{0.49\textwidth}
          \begin{code}[tag=C]
            \begin{C}
              struct N{
                int var;
              };
              struct N obj;
              int *ptr = &(obj.var);
              (*ptr)++;
            \end{C}
          \end{code}
        \end{column}\hfill
        \begin{column}<3->{0.49\textwidth}
          \begin{code}[tag=C]
            \begin{C}
              struct N {
                int var;
              };
              struct N obj;
              struct N* ptr = &obj;
              (*ptr).var;
            \end{C}
          \end{code}
        \end{column}
      \end{columns}
    }
    \ii<4-> \structure{Aliase}: Mehrere Namen (\codeinline{obj}, \codeinline{*ptr}) binden nun das gleiche Objekt.{\\
      \btAnimation[width=0.7\textwidth]{center,padding=1ex,1:<1-3>,range=1-2:<4->}{fig/04-aliase}
    }
    \ei
    \OrangeBox<5->{Wäre es nützlich, wenn ein Name mehrere Objekte meinen könnte?}
  \end{frame}

  \begin{frame}{Erinnerung: Arten des Polymorphismus}
     \btAnimation[width=\textwidth]{center, padding, 3:<1>}{fig/03-polymorphismus}
  \end{frame}


  \begin{frame}{Überladene Funktionen in a Nutshell}
    \begin{btBlock}{\textbf{Vorweg:} Vollständige Namensauflösung ist immer eindeutig!}
      Das Ergebnis ist \alert{immer} genau ein Objekt. Allerdings können wir die Berechnung, bis zur tatsächlich Verwendung, in die Laufzeit verschieben.
    \end{btBlock}
    \medskip
    \bi
    \ii<2-> Bei \structure{überladenen Funktionen} werden die Parametertypen Teil des Namens{
      \begin{columns}
        \hfill
        \begin{column}{0.49\textwidth}
          \begin{code}[tag=C++]
            \lstinputlisting[style=CPP,style=smaller,linerange={range0-range1}]{lst/04-overloading.cc}
          \end{code}
        \end{column}\hfill
        \begin{column}{0.35\textwidth}
          \btImage[draw,text width=2.5cm]{fig/04-overloading}
        \end{column}\hfill
      \end{columns}
      \bi
      \ii Alle Deklarationen sind weiterhin eindeutig.
      \ii Aber: Eine Referenz mit dem Namen \texttt{isNeg} ist (allein) \alert<2>{nicht mehr eindeutig}.
      \ei
    }
    \ii<3-> Die Namensauflösung wird erst im \structure{konkreten Aufrufkontext} eindeutig.{
      \begin{columns}
        \begin{column}{0.49\textwidth}
          \begin{code}[]
            \begin{code}[tag=C++]
              \lstinputlisting[style=CPP,style=smaller,linerange={range2-range3}]{lst/04-overloading.cc}
            \end{code}
          \end{code}
        \end{column}\hfill
        \begin{column}{0.49\textwidth}
          \centering
          \btImage[draw,text width=4cm,opts={page=2}]{fig/04-overloading}
        \end{column}
      \end{columns}
    }
    \ei
  \end{frame}

  \begin{frame}{Namensauflösung für überladene Funktionen}
    \begin{columns}[t]
      \begin{column}{0.38\textwidth}
        \btAnimation[width=\textwidth]{raisebox,range=1-6:<1->,6:<7->}{fig/04-overloading-resolution}
      \end{column}\hfill
      \begin{column}{0.59\textwidth}
        \vspace{-1cm}
        \begin{btBlock}{Vorläufige Annahme}
          \alert{Monomorphes} und statisches Typsystem
        \end{btBlock}
        \smallskip
        \be
        \ii Overload Set bestimmen{
          \bi
          \ii<2-> Suche mittels CSNR sichtbare Deklaration
          \ii<2-> \alert<2-3>{Abbruch} der Suche beim ersten Treffer\\[1ex]
          \OrangeBox<3->{\strut Java: Überladung vs. Überschreiben}
          \ei
        }\medskip
        \ii<4-> Typsignaturen durch Typsystem ermitteln{
          \bi
          \ii Definitionstelle und Aufrufstelle
          \ii Liste der Parameter und der Argumente
          \ei
        }\medskip
        \ii<5-> Einschränkung des Overload Sets{
          \bi
          \ii Übereinstimmung in Parameteranzahl
          \ii<6-> Typen müssen gleich sein\\[1ex]
          \OrangeBox<7>{\strut Statische Namensauflösung möglich!}
          \ei
        }
        \ee

      \end{column}
  \end{columns}
  \end{frame}

  \begin{frame}[fragile]{Fallbeispiel: Statische Überladung in C++}
    \begin{code}[tag=C++]
      \begin{CPP}[style=highlighting]
        bool isNeg(int x)    {...}
        bool @3isNeg(double x)@ {...}
        bool isNeg(int x, int y) {...}

        bool fn() {
          return @3isNeg(2.0)@;
        }
      \end{CPP}
    \end{code}

    \medskip
    \bii
    \ii<2-> \structure{Name Mangling}: Die Parameterliste wird in die Assemblernamen codiert
    \ii<3-> Der Übersetzer löst \codeinline{isNeg(2.0)} \alert{statisch} zu \codeinline{isNeg(double)} auf.
    \ii<4-> \codeinline{call} ruft einen \enquote{mangled name} auf; der Linker fügt die richtige Adresse ein.
    \eii

    \medskip

    \begin{columns}[t]
      \begin{column}<2->{0.49\textwidth}
        \structure{Symbole im ELF}

        \begin{code}[]
          \begin{codetext}[style=smaller,style=highlighting]
            > nm a.out | grep isNeg
            ....
            000000000000@411e4@ T @4_Z5isNegd@
            00000000000011d5 T _Z5isNeg@2i@
            0000000000001222 T _Z5isNeg@2ii@
            ....
          \end{codetext}
        \end{code}
      \end{column}\hfill
      \begin{column}<4->{0.49\textwidth}
        \structure{Assembler Code}

        \begin{code}[]
          \begin{codetext}[style=smaller,style=highlighting]
            _Z3fnv:
               push   %rbp
               mov    %rsp,%rbp
               mov    0xd0c(%rip),%rax
               movq   %rax,%xmm0
               callq  @411e4@ <@4_Z5isNegd@>
               pop    %rbp
               retq
          \end{codetext}
        \end{code}
      \end{column}
    \end{columns}

  \end{frame}
#+end_src

#+begin_src latex
  \begin{frame}[fragile]{Operatorüberladung}
    \bi
    \ii<1-> Arithmetische Operatoren (\texttt{+,-,*,/}) sind überladenen{
      \bi
      \ii Interpretation als Funktionsaufrufe: \codebox{2 + 3} $\rightarrow$ \codebox{+(2, 3)}
      \ii Der Operator (z.B., \texttt{+} oder \texttt{++}) wird zum Funktionsnamen: \texttt{\colorbox{badbee!50}{++}(a)}
      \ii Sprachen definieren bereits mehrere überladene Implementierungen:{\\
        \btSetNamedTab[1cm]{\first}%
        \btSetNamedTab[4.5cm]{\second}%
        \first \siginline{+}{(int, int)}{int}       \second Addition von Ganzzahlen\\
        \first \siginline{+}{(float, float)}{float} \second Addition von Gleitkommazahlen\\
        \first \siginline{+}{(string, string)}{string} \second Konkatenierung von Zeichenketten
      }
      \ii[$\Rightarrow$] Der Übersetzer braucht bereits Infrastruktur zur Überladungsauflösung
      \ei
    }\smallskip
    \ii<2-> Manche Sprachen erlauben eigene Operatorüberladungen{
      \bi
      \ii Die selbst-definierten Überladungen müssen \enquote{magischen} Namen tragen
      \ii Overload Set enthält Eingebaute und selbst-definierte Operatoren
      \ei
    }
    \begin{code}[tag=C++]
      \begin{CPP}[style=highlighting,style=smaller]
        struct complex {
          int real, imag;
          complex(int r, int i)  {real = r;   imag = i;} // Konstruktor
        };

        complex @2operator+@ (complex c1, complex c2) {
          return complex(c1.real + c2.real, c1.imag + c2.imag);
        }
      \end{CPP}
    \end{code}
    \ei


  \end{frame}

#+end_src


** Überladung und Polymorphismus
#+begin_src latex
\begin{frame}{Erinnerung: Arten des Polymorphismus}
\btAnimation[width=\textwidth]{center, padding, 5:<1>}{fig/03-polymorphismus}
\end{frame}

  \begin{frame}[fragile]{Interaktion zwischen Überladung und Subtypen}
    \textbf{Erinnerung}: Subtyping ist eine Form des universellen Polymorphismus. Bei Vererbung ist die Kindsklasse ein Subtyp  der Elternklasse .

    \begin{btBlock}{}
      Ein polymorphes Typssystem führt Typkomptaibilität ein und erzeugt damit \structure{Uneindeutigkeit}. Diese muss die Sprache eindeutig auflösen.
    \end{btBlock}\medskip

    \begin{columns}[t]
      \begin{column}<2->{0.49\textwidth}
        \STRUCTURE{An der Definitionsstelle}\\[1ex]

        \begin{code}[tag=C++]
          \begin{CPP}[style=highlighting,style=smaller]
            class S : public B {}
            void @+3f(B * obj)@ {...}
            void @+3f(S * obj)@ {...}
            ...
            S * obj = new S();
            f(obj); // f(S *)
          \end{CPP}
        \end{code}

        \bii
        \ii Subtyp \texttt{S} kompatibel zu \texttt{B}
        \ii Beide Defs. passen  zum Aufruf
        \ii Welche Definition wählen wir?
        \eii
        \smallskip
        \alert{$\Rightarrow$ Berechnung der Spezfifizät}

      \end{column}\hfill
      \begin{column}<4->{0.49\textwidth}
        \STRUCTURE{An der Aufrufstelle}\\[1ex]

        \begin{code}[tag=C++]
          \begin{CPP}[style=highlighting,style=smaller]
            // wie links
            void f(@+5B * this@, int x) {...}
            void f(@+5S * this@, int x) {...}
            ...
            @+5B *obj@ = new S();
            f(@+5obj@, 23);
          \end{CPP}
        \end{code}
        \bii
        \ii Variablendeklaration vs. Objekt
        \ii Statischer Typ != Dynamischer Typ
        \ii Welchen Typen sollen wir beachten?
        \eii
        \smallskip
        \alert{$\Rightarrow$ Dynamischer Dispatch}
      \end{column}
    \end{columns}
  \end{frame}


  \begin{frame}{Auswahl der spezifischsten Überladung}
    \btAnimation[width=0.9\textwidth]{range=1-8:<1->}{fig/04-overloading-subtypes}

    \medskip
    {\small \textbf{Intuition:} Umso mehr Casts notwendig sind, umso schlechter die \structure{Spezifität}.}

    \bii
    \ii<2-> Bestimmung der Argument--Parameter \alert<2>{Distanz} in der Vererbungshierarchie
    \ii<3-> Inkompatible Typen erzeugen eine Distanz von $\infty$
    \ii<7-> Der niedrigste Score ist die höchste Spezifität
    \eii
  \end{frame}
#+end_src

#+begin_src latex
  %%ONLY%%
  \begin{frame}[fragile]{Dynamischer Dispatch anhand des dynamischen Typs}
    \begin{center}
      \begin{minipage}{0.6\textwidth}
      \begin{code}[]
        \begin{CPP}
          Base * obj = new Derived();
          f(obj); // statisch: f(Base); dynamisch: f(Derived)
        \end{CPP}
      \end{code}
    \end{minipage}
  \end{center}

    \textbf{Bisher} haben wir nur den statischen Typen der Argumente betrachtet.
    \medskip

    \bi
    \ii \structure{Dynamic Dispatch}: Überladungsauswahl Wir beachten den dynamischen Typen bei der Überladungsauflösung
    \ei
  \end{frame}

#+end_src

* Summary
