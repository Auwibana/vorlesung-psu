#+TITLE: Programmiersprachen und Übersetzer
#+SUBTITLE: 04 - Namen
#+SETUPFILE: setup.org
#+INCLUDE: export-prologue.org
#+PROPERTY: header-args:latex :tangle yes :noweb yes :tangle-macros yes :tangle-prologue topic :tangle-epilogue endtopic :exports none

#+NAME: topic
#+BEGIN_SRC latex :tangle no
\psuSectionStart{{{{property(ITEM)}}}}{{{{n(block)}}}}
#+END_SRC

#+NAME: endtopic
#+BEGIN_SRC latex :tangle no
\psuSectionStop{{{{property(ITEM)}}}}{{{{n(block,-)}}}}
#+END_SRC

* Gedanken zu dieser Vorlesung                                     :noexport:

Was lernt man aus dieser Vorlesung für die Ziele effektiv und effizient?
 - Die Regeln der Namensauflösung etablieren die Links zwischen Deklaration und  Benutzung [effektiv]
 - Dynamische Namensauflösung kostet immer Laufzeit                                       [effizient]


* Was ist ein "Name"?
:PROPERTIES:
:CUSTOM_ID: 04-einleitung
:END:
#+begin_src latex
  \subtitle{{{{subtitle()}}}}
  \begin{frame}
    \maketitle
  \end{frame}

  \begin{frame}{Wieso sollte ich mich mit Namen beschäftigen?}
    \begin{center}
      \includegraphics[page=11,width=0.6\linewidth]{fig/01-overview-small}
    \end{center}
    \bi
    \ii Die Namensauflösung ist grundlegend für das Programmverständnis{
      \bi
      \ii Namen etablieren kontextsensitive \structure{Querverbindungen} zu Deklarationen.
      \ii Das informatische Grundprinzip von \structure{Information Hiding} hängt an Namen.
      \ei
    }
    \ei
  \end{frame}

  \lstdefinestyle{defuse}{
    moredelim=**[is][{\btHL[fill=safegreen!50]<2-3>}]{!}{!},
    moredelim=**[is][{\btHL[fill=safeblue!50]<3>}]{@}{@},
    moredelim=**[is][{\btHL[fill=safeblue!50]<3->}]{^u}{^},
    moredelim=**[is][{\btHL[fill=safegreen!50]<3->}]{^d}{^},
    escapechar=`,
  }
  \begin{frame}<handout:2,5>[fragile]{"Motivierendes" Beispiel: C++}
    \def\p#1{\tikzmark{p#1}}
    \begin{columns}[t]
      \begin{column}{0.49\textwidth}
  \begin{code}[]
    \begin{CPP}[style=defuse]
      namespace `\p5`^dA^`\p{55}` {
        typedef int !type_t!;
        class ^dB^`\p6` {
          private:   @int@ !x!;
          protected: @int@ `\p7`^dy^;
          public:    @int@ !z!;
            virtual @type_t@ !func!();
        };
      }

      class `\p3`^dC^`\p{34}` : public `\p4`^uA::B^ {
        virtual @A::type_t@ !func!();
      };

      using !ret_t! = @A::type_t@;
    \end{CPP}
  \end{code}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \begin{code}[tag=C++]
          \begin{CPP}[style=defuse]
            @ret_t@ @A::B::@!func!() {
              return @this@->@x@;
            }

            @ret_t@ `\p2`^uC::^!func!() {
              return `\p1`^uy^`\p8`;
            }

            @int@ !main!() {
              @A::B@ *!obj! = new @C@();
              @obj@->@z@ = 42;
              return @obj@->@func@();
            }
          \end{CPP}
        \end{code}
      \end{column}
    \end{columns}
    \begin{tikzpicture}[remember picture,overlay]
      \only<4-|handout:5>{
        \draw[thick,srared,->] (pic cs:p1) --(pic cs:p2);
        \draw[thick,srared,->] (pic cs:p2) --($(pic cs:p34)+(up:2pt)$);
        \draw[thick,srared,->] (pic cs:p34) --(pic cs:p4);
        \draw[thick,srared,->] (pic cs:p4) --(pic cs:p55);
        \draw[thick,srared,->] (pic cs:p5) --(pic cs:p6);
        \draw[thick,srared,->] (pic cs:p6) --(pic cs:p7);
      }
      \only<5-|handout:5>{
        \draw[ultra thin] (pic cs:p8) -- ++(-45:2em) node[align=left,anchor=west,fill=badbee!50] {type = int\\addr = this + 4;};
      }
    \end{tikzpicture}
    \medskip
    \bi
    \ii Namen werden überall im Programm \strut\only<2->{\colorbox{safegreen!50}}{deklariert} und \only<3->{\colorbox{safeblue!50}}{referenziert}.
    \ii<4-> Die \textbf{Namensauflösung} verbindet den Namen mit dem Objekt.
    \ii<5-> \colorbox{badbee!50}{Information}sfluss entlang dieser Kanten quer zum AST
    \ei
  \end{frame}

  #+end_src

In dieser Vorlesung soll es um das Konzept von *Namen* und *Namensauflösung* im Kontext von Programmiersprachen gehen.
Dieses Kapitel ist der zweite Teil der Top-Down Betrachtung von Programmiersprachen, bei der wir aus Anwendersicht auf Konstrukte und grundlegende Prinzipien schauen, die in vielen Programmiersprachen vorkommen.
Jede Programmiersprache muss eine Antwort darauf haben, wie sie Dinge (Objekte, Typen, Funktionen) an einer Stelle im Programm benennt um sie an anderer Stelle wieder zu verwenden.
In dieser Vorlesung wollen wir uns damit beschäftigen, wie solche Antworten aussehen können und welche Prinzipien der Benennung und der Namensorganisation ersonnen wurden.
Dabei wird keine Sprache alle der hier vorgestellten Prinzipien auch anwenden, sondern es wird immer nur eine Untermenge zu Anwendung kommen.

Auf Seite des Übersetzers ist die Verbindung zwischen der Stelle an der ein Name eingeführt wird (*Deklaration*) und seinen Verwendungen (*Referenzierung*) eine wichtige Querverbindung, die das Programm zusammenhält.
Zu jeder Verwendung eines Namens muss der Übersetzer die passende Deklaration finden; diesen Prozess, von der Verwendung zum Deklaration, nennen wir (partielle) *Namensauflösung*[fn::
Partiell deswegen, weil wir im Übersetzer nur die Deklaration und nicht in jedem Fall das dahinterliegende Laufzeitobjekt finden.
Vollständige Namensauflösung verbindet einen Namen mit der Speicheradresse eines Objekts.
Dazu aber später mehr.].
Entlang dieser Verbindungen, die quer zu den Ästen und Blättern des abstrakten Syntaxbaums (AST) gezogen werden, können Informationen zwischen der Deklarationsstelle und der Verwendungsstelle fließen.
Die wichtigste Art von transportierten Information sind die der Typen.

Im Beispiel (auf den Folien), etabliert die Namensauflösung einen Link (die roten Pfeile) zwischen der Verwendungstelle ~y~ und der Deklarationsstelle ~int y~ in Klasse ~B~.
Entlang dieses Links fließt zum einen die Information, dass ~y~ vom Typ Ganzzahl ist, aber auch dass das Feld ~y~ mit einem relativen Offset (zum ~this~ Zeiger) von 4 zu finden ist.
Mit diesem Wissen kann der Übersetzer in der Funktion ~func()~ zum einen prüfen, dass nur valide Operationen auf ~y~ ausgeführt werden und zum anderen kann er Code erzeugen, der das Feld, relativ zu einem ~this~ Zeiger, lesen und schreiben kann.

In diese Vorlesung werde ich mich hauptsächlich auf solche Deklarationen konzentrieren, hinter denen ein zur Laufzeit ein Objekt steht, welches eine Speicheradresse hat.
Allerdings gilt dies nicht für jede Deklaration.
So haben, in übersetzten Sprachen, *Typdeklarationen* oft kein Pendant zur Laufzeit (es gibt keine Typobjekte), sondern nur die angehefteten Informationen an der Deklarationsstelle (z.B., der Typausdruck) is von Relevanz.
Allerdings gelten auch für diese Deklarationen die selben Regeln und Prinzipien zur Namensauflösung, sie ist nur schon an der Deklarationsstelle beendet und muss/kann nicht bis zu einer Speicheradresse fortgeführt werden.

Auf Seiten des Sprachdesigns haben die Regeln zur Namensauflösung auch eine zentrale Rolle:
Eines der Kernprinzipien der Softwaretechnik ist das *Information Hiding*, bei der man sein Programm in Komponenten[fn::Komponenten kein allgemein definierter Begriff, und kann in unterschiedlichen Kontexten unterschiedliches bedeuten. Das grundlegende Merkmal von Komponenten ist aber, dass es ein "Innen" und ein "Außen" gibt, zwischen denen eine Schnittstelle definiert wird.] aufteilt (z.B.
Klassen).
Diese Komponenten haben einen internen Aufbau, den wir vor der Außenwelt verstecken, und ein externes Interface (die ~public~ Attribute und Methoden), welches die Außenwelt verwenden kann.
Durch diese Trennung ist es möglich die Interna zu ändern, ohne alle Benutzer der Komponente anzupassen.
Hier helfen die Sprachkonstrukte der Namensdeklaration dabei, Komponenten entlang von *hierarchischen Namensräumen* zu strukturieren und die *Sichtbarkeit von Namen* zwischen Komponenten einzuschränken.

#+begin_src latex
\begin{frame}{Grundbegriffe: Namen und Namensauflößung}
    \begin{center}
      \btImage[text width=0.8\textwidth,align=center,]{fig/04-objects}
    \end{center}

    \bi
    \ii \STRUCTURE{Name}: Symbolische und Statische Referenz im Programmcode{
      \bi
      \ii \structure{Abstraktion}: Namen ersetzen die Verwendung konkreter Speicheradressen
      \ii \structure{Dokumentation}: Namen transportieren Informationen zwischen Entwicklern
      \ii \structure{Querverbindung}: Referenz von Deklarationen quer zum AST
      \ei
    }\medskip
    \ii<2-> \STRUCTURE{Namensauflösung}: Auffinden des referenzierten Objekts. {
      \bi
      \ii Wird vom Übersetzer teilweise vorbereitet oder schon ganz durchgeführt.
      \ii Essentieller Teil der semantischen Analyse (\texttt{name 'x' is not defined})
      \ii Sowohl statischen (Bezeichner), als auch dynamische (Pointer), Informationen
      \ei
    }
    \ei

    \medskip
    \OrangeBox<3->{
      Im Übersetzer suchen wir (oft) nur die \textbf{Deklarationsstelle} des Namens
    }
  \end{frame}

  \begin{frame}<1-4|handout:1-4>[t]{Grundbegriffe: Deklaration, Definition, Namensraum}
    \setbeamercovered{transparent=40}
    \btAnimation[]{center,padding,range=1-3:<1->,3:<4->}{fig/04-scopes}
    \bi
    \ii \structure{Deklaration} eines Namens für einen AST Knoten\hfill\only<2-|handout:2->{\texttt{\LET <NAME>}} {
      \bi
      \ii Um AST Knoten wieder zu finden, geben wir ihnen \alert{einen} Namen.
      \ii Viele Konstrukte deklarieren einen Namen (Typen, Variablen, Funktionen).
      \ei
    }\smallskip
    \ii<-3|handout:-3> \structure{Definition} von benannten Objekten {
      \bi
      \ii Jede Definition is auch eine Deklaration und führt einen Namen ein.
      \ii Geht einher mit der Allokation eines Objekts (z.B. Definition einer Variablen)
      \ii Wichtige Unterscheidung bei separater Übersetzung (C/C++).
      \ei
    }\smallskip
    \ii \structure{Namensraum} ist ein Container für deklarierte Namen \hfill\only<2-|handout:2->{\texttt{\{...\}}}{
      \bi
      \ii Beschränken die Gültigkeit eines deklarierten Namens
      \ii \structure{Schachtelung}: Ein Namensraum kann auch weitere Namensräume beinhalten .
      \ei
    }
    \ei
  \end{frame}
#+end_src

Nach diesem sehr groben Überblick über den ganzen Bereich der Namen, möchte ich einige Grundbegriffe genauer definieren, damit ich für den Rest dieses Skripts auf eine möglichst wohldefinierte Nomenklatur zurückgreifen kann.
Der erste Begriff ist der des *Namens*:
Ein Name ist eine symbolische und statische Referenz im Programmcode.
Sie sind *statisch*, weil Namen direkt im Quelltext vorkommen und nicht erst zur Laufzeit erzeugt werden. Ein Name kann also nur etwas sein, was wir mit dem Editor sehen können, wie ein Bezeichner (~obj~) oder ein komplexerer Ausdruck (~obj.x~).
Namen sind darüber hinaus aber auch *symbolisch*, weil sie abstrakte Stellvertreter für konkrete Objekte sind.
Bei Variablen können wir, mit ihnen, symbolischen ~obj.x~ notieren können, anstatt ganz konkret ~0x1004~ schreiben zu müssen.
Bei Typdeklarationen, die ja keine Laufzeitadresse haben, erlauben Namen es uns ~object_t obj~ anstatt ~<Typ in Zeile 30> obj~
zu schreiben.

Der zweite wichtige Begriff ist die *Namensauflösung*, bei der die symbolischen Namen durch die konkreten Objekte bzw. die konkreten Adressen ersetzt werden.
Dazu müssen wir alle Namen, die stellvertretend für das gleiche sind, miteinander verbunden (Querverbindungen).
Inbesondere wollen wir alle Verwendung eines Namens (Referenzen) mit jener Programmstelle verbinden, die den Namen zum ersten mal eingeführt hat (Deklaration).
Falls es zu einem Namen tatsächlich ein Objekt zur Laufzeit gibt, so ist die *Adressberechnung* der abschließende Teil der Namensauflösung.

Bereits erwähnt haben ich den Begriff der *Deklaration*.
Deklarationen sind jene Stellen im Quellcode, die einen Namen einführen und damit dem Übersetzer bekannt machen.
Für jede Verwendung eines Namens wird der Übersetzer die, im referenzierenden Kontext gültige, Deklaration suchen; gibt es keine gültige Deklaration, so ist das Programm fehlerhaft.
In Sprachen gibt es viele Konstrukte, die benannt sind und daher einen Namen deklarieren.

Der Begriff der *Definition* ist eine Erweiterung der Deklaration.
Neben der Einführung eines neuen Namens, gehen Definitionen mit der Erstellung (Allokation) des konkreten Objekts einher.
Daher kann es zu einem Namen auch immer nur *eine Definition*, aber *viele Deklarationen* geben.
Besonders auffällig ist der Unterschied zwischen Deklaration und Definition beim Sprachen mit separater Übersetzung (C/C++).
Dort kann immer nur eine Übersetzungseinheit einen Namen definieren (die globale Variable ~int B~), aber viele Übersetzungseinheiten können diesen Namen deklarieren (~extern int B~).
Da wir uns in dieser Vorlesungseineit mit Namen und nicht mit Objekten und ihrer Erstellung auseinander setzen wollen, werden wir im folgenden Definitionen weitgehend ignorieren und so tun als gäbe es nur Deklarationen.

Der letzte wichtige Begriff ist der des *Namensraums*.
Ein Namensraum ist, ganz generell, ein Container für Namensdeklarationen.
Namensräume strukturieren die Menge aller deklarierten Namen und schränken ihre Gültigkeit ein.
Ohne Namensräume müsste jeder Name einen programmweit-eindeutigen Identifier haben und es gäbe genau eine lokale Variable mit dem Bezeichner ~i~. Das wäre eher unpraktisch.

Für weitere Betrachtung von Namen, werde ich eine minimale, domänen-spezifische, Sprache {{{wikipedia_de(Domänenspezifische_Sprache)}}} entwickeln, um die wichtigsten Namenskonzepte konzentriert erklären zu können.
Diese Sprache ist nicht dazu da tatsächlich übersetzt zu werden, sondern sie soll nur jene Aspekte herausarbeiten, die relevant für die Namensauflösung sind.
Die Grammatik dieser Sprache ist denkbar einfach und sie kennt nur Deklarationen (~let <NAME>~), Referenzen (~<NAME>~), und geschachtelte Namensräume (~{...}~). Im weiteren Verlauf werden wir sie allerdings noch minimal erweitern.

#+begin_example
PROG  -> STMT*
STMT  -> SCOPE | DECL | REF
SCOPE -> '{' STMT* '}' // Namensräume können geschachtelt sein
DECL  -> 'let' NAME    // Deklaration eines Namens
REF   -> NAME          // Verwendung  eines Namens
#+end_example

* Statische Namensauflößung

Als erstes werden wir uns mit den Regel der Namensauflösung in geschachtelten Namensräumen beschäftigen.
Dabei wollen wir uns zunächst nur mit statischer Namensauflösung beschäftigen, bei der hinter jeder Namensdeklaration maximal ein Laufzeitobjekt sein kann.
Der Gegensatz zu dieser *statischen Namensauflösung*, ist die dynamische Namensauflösung, bei der es zu einer Deklaration mehrere Objekte[fn::Hinter einem Attribut in einer Klasse, steht in jeder Instanz ein anderes Objekt.
Der ~this~ Zeiger dient zur Unterscheidung.]geben kann, zwischen denen wir mit zusätzlichem Laufzeitwissen unterscheiden werden.
Dazu aber später mehr.

** Implizite Namensauflösung
:PROPERTIES:
:CUSTOM_ID: 04-implicit-resolution
:END:

#+begin_src latex
\dividerframe{Statische Namensauflößung}
  \begin{frame}{Implizite Namensauflösung}
    \begin{columns}
      \begin{column}{0.3\textwidth}
        \btAnimation[width=\textwidth]{range=1-4:<1->}{fig/04-closest-match}
      \end{column}\hfill
      \begin{column}{0.65\textwidth}
        \bi
        \ii \enquote{Declaration before Use}{
          \bi
          \ii Deklaration in einem umgebenden Namensraum.
          \ii Reihenfolge von Deklaration und Referenz teilweise egal.
          \ei
        }\medskip
        \ii<2-|handout:2-> \enquote{Closest-nested scope rule} (CNSR){
          \bi
          \ii Suche nach Deklarationen von Innen nach Außen
          \ii Bei mehreren Möglichkeiten: Nimm die Innerste.
          \ii Im AST: Wir suchen von unten nach oben.
          \ei
        }\medskip
        \ii<3-|handout:3-> Deklarationen können \structure{verdeckt} werden {
          \bi
          \ii Innere Deklarationen verdecken die Äußeren
          \ii Die äußere Deklaration bleibt \structure{gültig}, ist aber innen nicht mehr \structure{sichtbar}.
          \ei
        }
        \ei
      \end{column}
    \end{columns}
  \end{frame}
  #+end_src

Die wichtigste Art der Namensauflösung ist die *implizite Namensauflösung*, bei der der Übersetzer automatisch die "nächste" gültige Deklaration findet.
Dabei sucht er für jede Referenz in einem Namensraum eine Deklaration im gleichen oder einem umgebenden Namensraum.
Findet er bei dieser impliziten Suche keine Deklaration, so gibt es einen Übersetzerfehler.
Im Folienbeispiel gibt es für die zweite Verwendung von A zunächst keine passende Deklaration.
Die einzige Deklaration von A ist in einem Namensraum, der bereits geschlossen ist und daher die Gültigkeit des Namens beendet hat.
Erst mit der Deklaration eines zweiten Namens mit dem Bezeichner ~A~, kann die zweite Referenz aufgelöst werden.

Es ist Sprachabhängig, ob eine Deklaration im selben Namensraum wirklich vor der ersten Verwendung auftreten muss, oder ob ich alle Deklaration an das Ende eines Block packen kann.
Sollte sich eine Sprache für eine strikte Auslegung der "Declaration before use" Regel entscheiden, so hat dies den historischen Hintergrund, dass es früher, aufgrund von schwachbrüstigen Maschinen, erstrebenswert war einen single-pass Übersetzer bauen zu können.
Solche single-pass Übersetzer gehen nur ein einziges mal über den Quelltext und erzeugen den Binärcode direkt beim Lexen/Parsen.
Für solche Übersetzer ist es dann natürlich unmöglich einen Namen aufzulösen, der lexikalisch nach der Verwendung deklariert wird; dazu müsste man zwei mal über den Quelltext gehen und zunächst alle Deklarationen einsammeln, bevor man die Referenzen auflöst.

Sollte bei der impliziten Namensauflösung mehrere Deklarationen in umgebenden Namensräumen gefunden werden, so verwendet man jene Deklaration die der Verwendung am "nächsten" bzw.
die am innersten ist.
Dazu beginnen wir unsere Suche nach der Deklaration bei dem Namensraum der die Verwendung umschließt und arbeiten uns solange von innen nach außen, bis wir eine passende Deklaration gefunden haben.
Diese Regel heißt die "Closest-nested scope rule" (CNSR).

Eine Folge der CNSR ist, dass Deklarationen in untergeordneten Namensräumen *verdeckt* werden können.
Dabei bleibt die äußere Deklaration weiterhin gültig, aber wir können sie mittels der impliziten Namensauflösung nicht mehr referenzieren; sie verliert ihre *Sichtbarkeit*.
Nachdem der Namensraum der inneren Deklaration geschlossen wurde, wird die äußere Deklaration wieder sichtbar und kann referenziert werden.
Erst nachdem auch der letzte Namensraum geschlossen wurde, verliert auch die letzte Deklaration von A ihre Gültigkeit.

** Explizite Namensräume
:PROPERTIES:
:CUSTOM_ID: 04-explicit-namespaces
:END:

#+begin_src latex
  \begin{frame}<handout:1-3>[fragile]{Explizite Namensräume}
    \begin{btBlock}[type=alert]{\ALERT{Problem:} Referenzen nur entlang des ASTs möglich}
      Die implizite Namensauflösung erlaubt uns nur Namen zu referenzieren, die direkt über uns im AST sind. Namen aus einem anderen Namensraum (NS) sind nicht erreichbar
    \end{btBlock}
    \medskip
    \begin{columns}
      \begin{column}{0.25\textwidth}
        \btAnimation[width=\textwidth]{range=1-3:<1->,3:<4->}{fig/04-explicit-namespace}
      \end{column}\hfill
      \begin{column}{0.70\textwidth}
        \bi
        \ii<2-|handout:2-> NS bekommt Namen im umgebenden NS {
          \bi
          \ii Namen aus einem NS anfordern mit \enquote{\texttt{::}}
          \ii Der Trenner \texttt{::} ist wie das \enquote{\texttt{/}} bei Pfaden
          \ii \alert<2>{Grundlegende Erweiterung} des Namensraumkonzepts
          \ei
        }
        \ii<3-|handout:2-> In C++: \enquote{\texttt{\LET <X>=...}} = \enquote{\texttt{namespace <X>}}{
          \begin{code}[tag=C++]
            \begin{CPP}
              namespace N { namespace M {
                  int A;
              } }
            \end{CPP}
          \end{code}
          \vspace{-1ex}
        }
        \ii<4-|handout:3-> Impliziter Wurzelnamensraum {
          \bi
          \ii Ermöglicht es alle Namensräume zu adressieren
          \ii Vollständig qualifizierter Name ist eindeutig
          \ei
        }
        \ei
      \end{column}
    \end{columns}

  \end{frame}
#+end_src

Mit der CNSR können wir bereits einen großen Teil der Namen auflösen und mit den zugehörigen Referenzen verbinden.
Allerdings sind die Namensräume, sofern sie nicht ineinander geschachtelt sind, voneinander abgeschottet.
Ich kann keine Namen aus einem anderen, bereits geschlossenen Namensraum mittels CNSR referenzieren, da dieser hierarchisch nicht über mir ist.
Wenn wir allerdings Namensräume dazu verwenden wollen um Komponenten abzubilden, wäre es durchaus wünschenswert in einen, bereits geschlossenen, Namensraum hinein greifen zu können.

Das grundlegende Problem, wenn wir bereits geschlossene Namensräume referenzieren wollen ist, dass sie bisher anonyme Konstrukte sind, also keinen eigenen Namen haben.
Wir lösen dieses Problem, indem wir die Möglichkeit eröffnen Namensräume an Namen zu binden und eine Möglichkeit geben einem benannten Namensraum (nach unten) zu suchen.

#+begin_example
DECL -> let NAME = SCOPE // Explizite, benannte Namensräume
#+end_example

Das erste bekommen wir in unserer domänenspezifischen Sprache hin, wenn wir die Grammatik um eine Regel zu *expliziten Namensräume* erweitern, welche dem folgenden Namensraum einen eigenen Namen geben.
Dieser Name ist dann an seiner Deklarationsstelle genauso gültig und sichtbar, wie das jeder andere Namen auch ist.
Allerdings schaffen wir mit dem ~::~ Operator die Möglichkeit einen Namen innerhalb eines expliziten Namensraums zu suchen.   Diese explizite bzw. *qualifizerte Referenzierung* sucht dabei nur in dem gegebenen Namensraum und führt keine CNSR Suche durch.
Im Beispiel bedeutet der Ausdruck ~M::A~, dass wir den Namen ~A~ im expliziten Namensraum ~M~ referenzieren wollen.

Da wir mit dem ~::~ Operator nur in einem Namensraum suchen können den wir mittels CSNR adressieren können, müssen wir einen impliziten *Wurzelnamensraum* einführen, in dem die Top-Level Deklarationen gespeichert werden.
Nur so können wir uns, von der Wurzel abwärts, über explizite Namensräume zu allen erreichbaren Deklarationen referenzieren.

Wir können uns den Doppelpunktoperator als einen Trenner in einem Zugriffspfad vorstellen.
Das Pendant auf Dateisystemebene, auch einem hierarchischen Namensraum (siehe GBS), ist der Slash (~/~).
Ein Reihung von Bezeichnern, die durch Doppelpunkte getrennt sind, ist daher eine Art expliziter Pfad im hierarchischen Namensraum.
Fängt dieser Pfad mit ~::~ an, so haben wir einen *vollständig qualifizierten Namen* (=absoluter Pfad), ansonsten haben wir einen relativ qualifizierten Namen (=relativer Pfad).

Explizite Namensräume sind eine grundlegende Erweiterung des Namensraumkonzepts, da sie es uns erlauben  kontrolliert auf Unternamensräume zugreifen zu können und nicht nur auf die CNSR angewiesen zu sein.
Sehr nah an dieser Erweiterung ist das C++ Konstrukt ~namespace~, welches einem Namensraum wirklich nur einen eigenen Namen gibt, und sonst nichts weiteres tut.

Noch eine spannende Bemerkung zum impliziten Wurzelnamensraum:
Wenn eine Sprache keine Möglichkeit bietet auf diese Wurzel zugreifen zu können, so kann man einen Namensraum vom Rest des Programms isolieren.
Innerhalb des Namensraums hat man keine Möglichkeit Namen zu notieren, die auf Deklarationen von außerhalb referenzieren.
Nur jene Objekte, die wir (dynamisch) in diesen Namensraum hinein geben erlauben dem enthaltenen Code auf die Außenwelt zuzugreifen.

** Import von Namen
:PROPERTIES:
:CUSTOM_ID: 04-import
:END:

#+begin_src latex
  \begin{frame}[fragile]{Import von entfernten Namen}
    \begin{btBlock}[type=alert]{\ALERT{Problem:} Explizite Auflößungspfade sind zu lange}
      Ständig den vollständigen Namen (\texttt{::A::B::C}) einer entfernten Deklaration zu verwenden ist umständlich viel Schreibarbeit.
    \end{btBlock}
    \medskip
    \begin{columns}
      \begin{column}{0.29\textwidth}
        \btAnimation[width=\textwidth]{range=1-4:<1->}{fig/04-import}
      \end{column}\hfill
      \begin{column}{0.67\textwidth}
        \bi
        \ii Jeder NS hat verschiedene Namensmengen {
          \bi
          \ii Die direkt deklarierten Namen ($N_d$)
          \ii Die implizit sichtbaren Namen ($N_v$)
          \ii Den Wurzelnamensraum
          \ei
        }\smallskip
        \ii<2-|handout:2-> Viele Sprachen erlauben \structure{Import} von Namen{
          \bi
          \ii \codeinline{import <PFAD>} erweitert die Namensmengen
          \ii Explizite Namensliste oder Importe mit \codeinline{*}
          \ii Importe geschehen oft implizit (z.B. Vererbung)
          \ei
        }\smallskip
        \ii<4-|handout:4-> Importe nach $N_d$ sind transitiv {
          \bi
          \ii Importiere in die Namen können importiert werden
          \ii \codeinline{import ::X::*} enthält auch \codeinline{::N::M::B}
          \ei
        }
        \ei
      \end{column}
    \end{columns}
  \end{frame}
#+end_src

Mit expliziten Namensräumen und dem ~::~ Operator haben wir die Möglichkeit geschaffen Namen zu referenzieren, die quer zur hierarchischen Namensraumstruktur deklariert wurde.
Allerdings führt die Verwendung von qualifizieren Namen zu schwer lesbarem Code, da die Zugriffspfade lang und länger werden.
Würde eine Sprache keine weiteren Mittel anbieten dieses Boilerplate Problem zu lösen, Programmierer würden sich einfach weigern ihre Namen in eine hierarchisch, anhand der logischen Komponentenstruktur, zu deklarieren.
Da wollen wir den Entwicklern natürlich entgegen kommen!
Viele Sprachen bieten die Möglichkeit Deklarationen von einem Namensraum in einen anderen Namensräumen zu *importieren*.

Um den Import von Namen zu verstehen müssen wir zunächst definieren, was in einem Namensraum überhaupt sichtbar ist.
Zum einen hat jeder Namensraum eine Menge von Namen die direkt in ihm deklariert sind.
Im Folienbeispiel deklariert der Namensraum N die Namen ~{A, M}~.
Zweitens hat jeder Namensraum eine Menge von sichtbaren Namen, welche die, zusätzlich zur Menge der direkt deklarierten Namen, alle Namen enthält, die durch die CNSR erreichbar sind.
Mit dem Import von Namen können wir, je nach Sprache und verwendetem Konstrukt, die eine oder die andere Menge manipulieren.
Da die Unterscheidung zwischen beiden fällen, nur in Randfällen wirklich relevant ist, werde ich im folgenden (und auf den Folien) so tun, als würden wir immer in die Menge der direkt-deklarierten Namen importieren.

In unserer Mini-Sprache, können wir mit dem Import Statement (~import <PFAD>~) Namen aus einem explizit benanntem Namensraum importieren.
Dabei erlauben wir nicht nur Importe einzelner Namen (~::N::A~), sondern auch Wildcard Importe (~::N::M::*~).
Letztere haben den Vorteil, dass wir das Import Statement nicht anpassen müssen, wenn wir im exportierenden Namensraum neue Namen deklarieren[fn::Für eine Diskussion von Wildcard importen bei Python Modulen, können Sie einen Blick in [[https://www.python.org/dev/peps/pep-0008/#id23][PEP8]] werden].

Wie bereits gesagt, importieren wir, der Einfachheit halber, nur in die Menge der direkt-deklarierten Namen.
Das Import Statement wird also quasi zur Deklaration (oder, bei Wildcard Importen, zu vielen Deklarationen).
Daher können wir die importierten Namen, von dritter Stelle wiederum importieren, falls wir den umgebenden Namensraum referenzieren können.
Im Beispiel können wir, nachdem wir den Namen ~X~ vergeben haben, alle auf alle Deklarationen (~A,B,C~) zugreifen, wenn wird die ~import ::X::*~ schreiben.

Manchmal ist der Import von Namen ein Seiteneffekt von anderen Sprachkonstrukten und nicht mit einem expliziten ~import~ Statement verbunden.
So werden bei der Vererbung alle Namen aus dem Namensraum der Elternklasse in den Namensraum der Kindsklasse importiert.




** Einschränkung der Sichtbarkeit
:PROPERTIES:
:CUSTOM_ID: 04-limited-visibility
:END:

#+begin_src latex
  \begin{frame}{Einschränkung der Sichtbarkeit}
    \begin{btBlock}[type=alert]{\ALERT{Ziel:} Wir wollen Interna der Implementierung verstecken}
      Zum Zwecke des \textbf{Information Hiding} wollen wir manche Namen nur \alert{innerhalb} eines Namensraumes sichtbar machen.
    \end{btBlock}
    \smallskip

    \bi
    \ii<2-|handout:2-> Deklarationen bekommen ein weiteres Attribut\hfill\texttt{\LETi <NAME>}{
      \bi
      \ii Interne Deklarationen können nur über implizite Auflösung gefunden werden.
      \ii Name wird unsichtbar für alles außerhalb des aktuellen NS
      \ii Wir können interne Namen ändern ohne externe Komponenten anzufassen.
      \ei
    }
    \ei
    \begin{columns}<3-|handout:3->
      \begin{column}{0.22\textwidth}
        \btAnimation[width=\textwidth]{center,range=1-2:<3->}{fig/04-private}
      \end{column}\hfill
      \begin{column}{0.72\textwidth}
        \bi
        \ii Zugriff auf einen internen Namen ist nicht erlaubt\\[0.5ex]{
          Übersetzer findet zwar die Deklaration, meldet aber aufgrund des Attributs einen Fehler.
          \smallskip
        }
        \ii Interne Namen werden beim Import übersprungen.
        \ii<4-|handout:4-> Namensräume können Standardattribute haben{
          \bi
          \ii \texttt{\LETi} macht einen Namen nur intern sichtbar
          \ii \texttt{\LETe} macht einen Namen auch extern sichtbar
          \ei
        }
        \ei
      \end{column}
    \end{columns}
  \end{frame}

  #+end_src

Ein Ziel von hierarchischen Namensräumen war, dass wir unseren Code anhand der Komponenten strukturieren wollen.
Um allerdings richtiges *Information Hiding* betreiben zu können müssen wir es noch möglich machen, dass nicht jeder daher gelaufene Programmierer unsere Komponenten-internen Variablen und Funktionen verwenden und verändern kann.
Bisher kann man an jeder Stelle des Programms mittels vollständig qualifizierten Namen (~::module::internal::my_precious~) auf alles zugreifen.
Wir müssen also eine Möglichkeit schaffen, dass unterschiedlich Zugriffsrechte gelten, je nachdem von wo wir eine Deklaration referenzieren wollen.

Um diese Ziel zu erreichen führen wir das Konzept von ~internen Deklarationen~ (auch private Deklarationen) ein.
Diese internen Namen können nur durch die implizite Namensauflösung, jedoch nicht durch einen qualifizierten Namen, referenziert werden können.
Des Weiteren werden interne (oder private) Deklarationen bei einem Import Statement übersprungen.
Durch diese Festlegung ist es nur noch von innerhalb eines Namensraums, mittels impliziter Namensauflösung, möglich Referenzen zu einem Namen zu notieren.
Von außerhalb, wo wir qualifizierte Pfade brauche, schlägt die Namensauflösung mit einem fehl (siehe ~M::A~).

In unserer Mini-Sprache führen wir ein optionales Attribut ~I~ ein[fn::Fun Fact am Rande:
Die gewählt Notation ist die Notation für optionale Parameter bei Latex Macros.
Die Notation soll andeuten, dass das I ein optionales Attribut für die Deklaration ist.], welches bei der Deklaration angegeben werden kann um sie zu intern zu machen.
Per Default sind alle Namen von überall sichtbar (~[E]~) und nur ausgewählte Deklarationen werden privat.
Wir erlauben allerdings auch, diese default Sichtbarkeit am Beginn eines Namensraums zu ändern.

In richtigen Programmiersprachen gibt es noch fein-granularere Abstufungen von Sichtbarkeit.
Zum Beispiel regelt das Sichtbarkeitsattribut ~protected~ bei Java, wie sich die Sichtbarkeit einer Deklaration beim Import durch Vererebung ändert.
Aber solche Feinheiten sind immer spezifisch für eine Sprache.
Nur das Prinzip, das die Sichtbarkeit einer Deklaration, je nach Referenzstelle, unterschiedlich sein kann, die bleibt.

#+begin_src latex
  \begin{frame}[fragile]{Fallbeispiel: Java Packages}
    \begin{columns}
      \begin{column}{0.35\textwidth}
        \begin{code}[]
          \begin{java}
            package N;
            public class A {
              public static
                void f1() { }
            }
          \end{java}
        \end{code}

        \begin{code}[]
          \begin{java}
            package M;
            import N.A;

            class B {
              static void f2() {
                A.f1();
              }
            }
          \end{java}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.60\textwidth}
        \btAnimation[width=\textwidth]{1:<1>}{fig/04-java-packages}
      \end{column}
    \end{columns}

  \end{frame}
#+end_src

An dieser Stelle wollen wir kurz innehalten und alle Konzepte zusammentragen, die wir bereits kennen gelernt haben.
An dieser Stelle können wir Namensräume erzeugen, die Deklarationen enthalten.
Diese Namensräume können selbst wieder einen Namen im übergeordneten Namensraum haben und wir können mittels qualifizierten Namen beliebig entfernte Deklarationen referenzieren.
Mit einem Import Statement können wir Namen aus anderen Namensräumen in unseren eigenen Namensraum importieren und wir können die Sichtbarkeit von Deklarationen einschränken.

Mit diesen Prinzipien können wir schon einige Programmkonstrukte in ihrer Funktion erklären und in unserer Mini-Sprache abbilden.
Wir wollen dies, beispielhaft, anhand von Java Paketen tun.
Java Pakete stellen Namensräume für Klassen dar, sodass ein Klassename nur innerhalb eines Pakets eindeutig sein muss.
Außerdem erlauben es Java Pakete die Sichtbarkeit von Klassen zwischen Paketen zu steuern.

Im Beispiel sehen wir, dass Pakete, die durch das ~package <NAME>;~ "betreten" werden, eigene Namespaces sind.
Dadurch erklärt sich bereits, wie es sein kann, dass in unterschiedlichen Paketen der gleiche Klassenname verwendet werden kann.
Außerdem vererben Pakete ein interne Standardsichtbarkeit an die darin enthaltenen Klassen.
Dies ist, im übrgien bei Klassen ebenso, auch dort ist die Standardsichtbarkeit private.
Die Klassen A und B haben unterschiedliche Sichtbarkeiten und nur die Klasse A kann von außerhalb ihres Pakets referenziert werden.
Daher ist es möglich, dass wir die Klasse N.A in das Paket M importieren.
Der einzige Unterschied zu unserer Mini-Sprache ist, dass Java an jeder Stelle den ~.~ zum trennen von Namen nimmt und nicht ~::~.
Die Klasse B ist tatsächlich intern deklariert und kann daher nur von anderen Klassen aus dem Paket M verwendet werden.
Wir sehen, ganz nebenbei, in dem Beispiel auch, dass Funktionen Namensräume sind, die per default ~[I]~ sind; lokale Variablen sind nicht von außen zugreifbar.


* Dynamische Namensauflösung
** Binding Time
#+begin_src latex
  \dividerframe{Dynamische Namensauflösung}
  \begin{frame}{Zeitpunkt der Namensbindung}
    \textbf{Bisher:} Zu einem Namen haben wir bisher nur die Deklaration gefunden, nicht aber das Objekt bzw. seine Adresse.\\[2ex]

    \ALERT{Aber:} Nicht zu jedem Zeitpunkt ist mit einem Namen wirklich ein existierendes Objekt verbunden. \\[2ex]

    \pause
     \structure{Binding time:} Zeitpunkt der Bindung zwischen Name und Objekt{
      \btUseExtraItemSep
      \bii
      \ii<+-> \structure{Compile time:} Der Übersetzer kennt Adresse des Objekts bereits.\\
          \textit{Beispiel: Speicherbereich einer Hardwarekomponente.}
      \ii<+-> \structure{Link time:}    Die Adresse wird beim Erstellen der Binärdatei ermittelt.\\
          \textit{Beispiel: Funktionen und globale Variablen}
      \ii<.-> \structure{Load time:}    Die Adresse wird beim Starten des Prozesses festgelegt.\\
          \textit{Beispiel: Code in Bibliotheken}
      \ii<+-> \structure{Run time:}     Die Adresse wird erst zur Laufzeit ermittelt.\\
          \textit{Beispiel: Lokale Variablen und Objekte am Heap}
      \eii
    }
  \end{frame}

  \begin{frame}[fragile]{Zeitpunkt der Adressberechnung}
    \bi
    \ii Adressberechnung ist \ALERT{immer} erst nach der Binding Time möglich.{
      \bi
      \ii Wenn kein Objekt assoziiert ist, können wir auch keine Adresse ausrechnen.
      \ii \structure{Partielle Namensauflösung}: Vorschrift und Werte vorberechnen.
      \ei
    }
    \begin{columns}
      \begin{column}[b]{0.35\textwidth}
        \begin{code}[]
          \begin{C}
            struct foo {
              int  a;
              int *p;
            } obj;
            ...
            @*(obj.p)@ = ...
          \end{C}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.64\textwidth}
        \btAnimation[width=\textwidth]{range=1-8:<1->}{fig/04-binding-time}
      \end{column}
    \end{columns}

    \ei
  \end{frame}

#+end_src

** Instantiierbare Namensräume
#+begin_src latex
  \begin{frame}[fragile]{Instanziierbare Namensräume}

    \begin{columns}
      \begin{column}{0.35\textwidth}
        \begin{code}[tag=C++]
          \begin{CPP}
            namespace N {
              int a;
              int b;
            };
            N::a
          \end{CPP}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.64\textwidth}
        \textbf{Bisher} gab es von jedem Namensraum \alert{genau eine Instanz}.
        Daher kann jeder enthaltene Name nur ein Objekt referenzieren.
      \end{column}
    \end{columns}

    \bi
    \ii<2-> \structure{Namensräume} mehrfach als eigene Objekte instantiieren{
      \bi
      \ii Jedes Laufzeitobjekt enthält eine Bindung für die deklarierten Namen
      \ii Laufzeitdaten werden zur Unterscheidung gebraucht (Objektadresse)
      \ei
    }
    \ei
    \begin{columns}<3->
      \begin{column}{0.35\textwidth}
        \begin{code}[tag=C]
          \begin{C}
            struct N {
              int a;
              int b;
            };

            struct N objA;
            struct N objB;

          \end{C}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.63\textwidth}
        \btUseExtraItemSep
        \bii
        \ii \codebox{objA.a} und \codebox{objB.a} sind verschiedenen
        \ii \structure{Punktoperator} macht dynamische Auflösung\\{
          \texttt{<obj>.<name>}: \codeinline{&obj + offset(N::name))}
        }
        \ii Java unterscheidet syntaktisch nicht zwischen dynamischer und statischer Namensauflösung
        \eii
      \end{column}
    \end{columns}

    \medskip
    \bi
    \ii<4-> Instanziierbare Namensräume sind ein \structure{Schlüsselkonzept} der Informatik
    \ei
  \end{frame}


  \begin{frame}[fragile]{Instanziierbare Namensräume (II)}
    \begin{columns}
      \begin{column}{0.35\textwidth}
        \begin{code}
          \begin{C}
            struct N {
              int a;
              int b;
            };

            struct N objA;
          \end{C}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.35\textwidth}
        \includegraphics[width=\textwidth]{fig/04-instances}
      \end{column}\hfill
    \end{columns}
    \medskip
    \bi
    \ii In unserer minimalen Namensraumsprache führen wir \LETd ein. {
      \bi
      \ii \texttt{\LETd <DST> = <SRC>} kopiert den NS \texttt{SRC} unter dem Namen \texttt{DST}
      \ii Wir verwenden weiterhin nur den \texttt{::} Operator.
      \ii Die Auflösung in einem \texttt{\LETd} Namensraum erforder \textbf{D}ynamisches Wissen.
      \ei
    }
    \ei
  \end{frame}

#+end_src

#+begin_src latex
  \begin{frame}[fragile]{Fallbeispiel: Klassen in C++}
    \begin{columns}[t]
      \begin{column}{0.35\textwidth}
        \begin{code}[]
          \begin{CPP}
            class B {
              int a;
             public:
              int b;
              int f1(){
                return a+b;
              }
            };
            B objB;
          \end{CPP}
        \end{code}
        \begin{code}<2->[]
          \begin{CPP}
            class S : public B {
              int c;
            }
            S objS;
          \end{CPP}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.25\textwidth}
        \btAnimation[width=\textwidth]{raisebox,1:<1>,2:<2->}{fig/04-instances-cpp}
      \end{column}\hfill
      \begin{column}{0.30\textwidth}
        Kombination aus:
        \bii
        \ii Namensräumen
        \ii Sichtbarkeit
        \ii Instantiierbar
        \ii<2-> Import
        \eii

        \medskip

        \uncover<3->{
          Feinheiten:
          \bii
          \ii \texttt{protected} Deklarationen ändern ihre Sichtbarkeit beim vererben.
          \ii \texttt{struct} ist per default \texttt{[E]}.
          \ii Man kann \texttt{public}, \texttt{protected} und \texttt{private} erben.
          \eii
        }

      \end{column}

    \end{columns}
  \end{frame}

  \begin{frame}[fragile]{Statische Felder in Klassen}
    \textbf{Beichte des Dozenten}: Ich habe \texttt{static} lange nicht verstanden.\\[2ex]

    \bi
    \ii<2-> In Klassenobjekten wird jeder Name dynamisch aufgelöst. {
      \bi
      \ii Manchmal sollen Namen dennoch dasselbe Objekt referenzieren.
      \ii \texttt{\LETs} setzt die dynamische Namensauflösung außer Kraft
      \ei
      \btAnimation[width=0.9\textwidth]{center,padding,1:<1-2>,2:<3->}{fig/04-static}
    }
    \ii<4-> Statische lokale Variablen in C/C++ funktionieren genauso.{
      \bi
      \ii Die dynamische Information um die Call-Frame wird ignoriert.
      \ii Die Variable behält, weil sie immer das selbe Objekt referenziert, ihren Wert.\\[1ex]
      \codeinline[style=C]{int counter() { static int i = 0; return i++; }}
      \ei
    }
    \ei

    \end{frame}

#+end_src

** Function-Call Frames
#+begin_src latex
  \begin{frame}[fragile]{Funktionen und lokale Variablen}
    \begin{columns}
      \hfill
      \begin{column}{0.3\textwidth}
        \begin{code}[tag=C]
          \begin{C}
            int f1(int L) {
              return L+1;
            }
          \end{C}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.3\textwidth}
        \includegraphics[height=1.5cm]{fig/04-functions}
      \end{column}
      \hfill
    \end{columns}
    \smallskip
    \bi
    \ii Funktionen öffnen für ihren Rumpf einen eigenen Namensraum{
      \bi
      \ii Parameter\alert{deklarationen} werden zu Namen innerhalb der Funktion.
      \ii \structure{Lokale Variablen} (und Parameter) sind nur innerhalb der Funktion sichtbar.
      \ii Die Namen lokaler Variablen können Globale verdecken. (Folge von CNSR)
      \ei
    }
    \ei
    \begin{columns}[t]<2->
      \begin{column}{0.49\textwidth}
        \begin{code}[tag=C]
          \lstdefinestyle{defuse}{
            moredelim=**[is][{\btHL[fill=refcolor]<3->}]{^u}{^},
            moredelim=**[is][{\btHL[fill=letcolor]<3->}]{^d}{^}
          }
          \begin{C}[style=defuse]
            int ^dfak^(int n) {
              if (n < 1) {
                return 1;
              }
              int tmp = ^ufak^(n-1);

              return n * tmp;
            }
          \end{C}
        \end{code}
        \smallskip
        \OrangeBox{Geschachtelte Funktionen?}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \begin{code}[tag=JavaScript]
          \lstdefinestyle{defuse}{
            moredelim=**[is][{\btHL[fill=refcolor]<4->}]{^u}{^},
            moredelim=**[is][{\btHL[fill=letcolor]<4->}]{^d}{^},
            escapechar=`
          }
          \begin{JS}[style=defuse]
            function outer() {
              var ^dx^ = 0;
              function ^dinner^() {
                ``^ux^ = ^ux^ + 1;
                return ^ux^;
              }
              return ^uinner^;
            }
          \end{JS}
        \end{code}

        \smallskip\OrangeBox{Funktionen schateln?}
      \end{column}
    \end{columns}
  \end{frame}

  \begin{frame}{Function-Call Frames und Rekursive Funktionen}
    \textbf{Früher:} Keine Unterstützung für rekursiven Funktionen (z.B. Fortran 77) \medskip

    \bi
    \ii <2-> Funktionen werde instantiierbar; jeder Aufruf erzeugt einen \structure{Call Frame}.{
      \bi
      \ii<4-> Ein Call-Frame hat einen Zeiger auf seinen aufrufenden Namensraum (caller)
      \ii<5-> Dynamische Namensauflösung erfolgt \alert<4>{relativ zum Stackpointer} (SP)
      \ei
      \medskip
      \btAnimation[width=0.65\textwidth]{center,1:<1>,range=1-9:<2->}{fig/04-call-frame}
    }
    \ei
  \end{frame}


  \begin{frame}{Geschachtelte Funktionen und Closures}
    \bi
    \ii Funktionen in Funktionen lassen Fragen über die Bindung aufkommen.{
      \bi
      \ii Die Deklaration zu einer Referenz ist nach CNSR klar
      \ii \ALERT{Aber}: Wir brauchen einen \texttt{outer}-Call-Frame um \texttt{x} vollständig aufzulösen
      \ei
      \btAnimation[width=0.65\textwidth]{padding,center,range=1-9:<1->}{fig/04-closure}
    }
    \ii<2-> \structure{Lexikalisches Scoping}: Funktionen können \alert<5->{Zustand} halten{
      \bi
      \ii<3-> Bei der \textbf{Definition} von \texttt{inner} wird ein \structure{Closure} Objekt erstellt.
      \ii<4-> Die Closure speichert den Frame über die Ausführung von \texttt{outer()} hinaus.
      \ei
    }
    \ei
  \end{frame}
#+end_src
- Lokale Variablen
- Rekursive Funktionen
- Geschachtelte Funktionsdeklarationen

* Overloading und Dynamic Dispatch
** Uneindeutige Namensauflösung
#+begin_src latex
  \dividerframe{Überladene Funktionen}
  \begin{frame}[fragile]{Pointer, Aliase und Uneindeutigkeit}
    \textbf{Wiederholung:} Namensauflösung findet das Objekt zu einem Namen.\medskip
    \bi
    \ii<2-> Ein \structure{Zeiger} speichert das Ergebnis einer vollständigen Namensauflösung.{
      \bi
      \ii Der \codeinline{&(<Namenspfad>)}-Operator löst den Pfad auf und gibt eine Adrese zurück
      \ii<3-> Der \codeinline{(*<Name>)}-Operator macht das von Name referenzierte Objekt zugänglich
      \ei
      \begin{columns}
        \begin{column}{0.49\textwidth}
          \begin{code}[tag=C]
            \begin{C}
              struct N{
                int var;
              };
              struct N obj;
              int *ptr = &(obj.var);
              (*ptr)++;
            \end{C}
          \end{code}
        \end{column}\hfill
        \begin{column}<3->{0.49\textwidth}
          \begin{code}[tag=C]
            \begin{C}
              struct N {
                int var;
              };
              struct N obj;
              struct N* ptr = &obj;
              (*ptr).var;
            \end{C}
          \end{code}
        \end{column}
      \end{columns}
    }
    \ii<4-> \structure{Aliase}: Mehrere Namen (\codeinline{obj}, \codeinline{*ptr}) binden nun das gleiche Objekt.{\\
      \btAnimation[width=0.7\textwidth]{center,padding=1ex,1:<1-3>,range=1-2:<4->}{fig/04-aliase}
    }
    \ei
    \OrangeBox<5->{Wäre es nützlich, wenn ein Name mehrere Objekte meinen könnte?}
  \end{frame}

  \begin{frame}{Erinnerung: Arten des Polymorphismus}
     \btAnimation[width=\textwidth]{center, padding, 3:<1>}{fig/03-polymorphismus}
  \end{frame}


  \begin{frame}{Überladene Funktionen in a Nutshell}
    \begin{btBlock}{\textbf{Vorweg:} Vollständige Namensauflösung ist immer eindeutig!}
      Das Ergebnis ist \alert{immer} genau ein Objekt. Allerdings können wir die Berechnung, bis zur tatsächlich Verwendung, in die Laufzeit verschieben.
    \end{btBlock}
    \medskip
    \bi
    \ii<2-> Bei \structure{überladenen Funktionen} werden die Parametertypen Teil des Namens{
      \begin{columns}
        \hfill
        \begin{column}{0.49\textwidth}
          \begin{code}[tag=C++]
            \lstinputlisting[style=CPP,style=smaller,linerange={range0-range1}]{lst/04-overloading.cc}
          \end{code}
        \end{column}\hfill
        \begin{column}{0.35\textwidth}
          \btImage[draw,text width=2.5cm]{fig/04-overloading}
        \end{column}\hfill
      \end{columns}
      \bi
      \ii Alle Deklarationen sind weiterhin eindeutig.
      \ii Aber: Eine Referenz mit dem Namen \texttt{isNeg} ist (allein) \alert<2>{nicht mehr eindeutig}.
      \ei
    }
    \ii<3-> Die Namensauflösung wird erst im \structure{konkreten Aufrufkontext} eindeutig.{
      \begin{columns}
        \begin{column}{0.49\textwidth}
          \begin{code}[]
            \begin{code}[tag=C++]
              \lstinputlisting[style=CPP,style=smaller,linerange={range2-range3}]{lst/04-overloading.cc}
            \end{code}
          \end{code}
        \end{column}\hfill
        \begin{column}{0.49\textwidth}
          \centering
          \btImage[draw,text width=4cm,opts={page=2}]{fig/04-overloading}
        \end{column}
      \end{columns}
    }
    \ei
  \end{frame}

  \begin{frame}{Namensauflösung für überladene Funktionen}
    \begin{columns}[t]
      \begin{column}{0.38\textwidth}
        \btAnimation[width=\textwidth]{raisebox,range=1-6:<1->,6:<7->}{fig/04-overloading-resolution}
      \end{column}\hfill
      \begin{column}{0.59\textwidth}
        \vspace{-1cm}
        \begin{btBlock}{Vorläufige Annahme}
          \alert{Monomorphes} und statisches Typsystem
        \end{btBlock}
        \smallskip
        \be
        \ii Overload Set bestimmen{
          \bi
          \ii<2-> Suche mittels CSNR sichtbare Deklaration
          \ii<2-> \alert<2-3>{Abbruch} der Suche beim ersten Treffer\\[1ex]
          \OrangeBox<3->{\strut Java: Überladung vs. Überschreiben}
          \ei
        }\medskip
        \ii<4-> Typsignaturen durch Typsystem ermitteln{
          \bi
          \ii Deklaration und Aufrufstelle
          \ii Liste der Parameter und der Argumente
          \ei
        }\medskip
        \ii<5-> Einschränkung des Overload Sets{
          \bi
          \ii Übereinstimmung in Parameteranzahl
          \ii<6-> Typen müssen gleich sein\\[1ex]
          \OrangeBox<7>{\strut Statische Namensauflösung möglich!}
          \ei
        }
        \ee

      \end{column}
  \end{columns}
  \end{frame}

  \begin{frame}[fragile]{Fallbeispiel: Statische Überladung in C++}
    \begin{code}[tag=C++]
      \begin{CPP}[style=highlighting]
        bool isNeg(int x)    {...}
        bool @3isNeg(double x)@ {...}
        bool isNeg(int x, int y) {...}

        bool fn() {
          return @3isNeg(2.0)@;
        }
      \end{CPP}
    \end{code}

    \medskip
    \bii
    \ii<2-> \structure{Name Mangling}: Die Parameterliste wird in die Assemblernamen codiert
    \ii<3-> Der Übersetzer löst \codeinline{isNeg(2.0)} \alert{statisch} zu \codeinline{isNeg(double)} auf.
    \ii<4-> \codeinline{call} ruft einen \enquote{mangled name} auf; der Linker fügt die richtige Adresse ein.
    \eii

    \medskip

    \begin{columns}[t]
      \begin{column}<2->{0.49\textwidth}
        \structure{Symbole im ELF}

        \begin{code}[]
          \begin{codetext}[style=smaller,style=highlighting]
            > nm a.out | grep isNeg
            ....
            000000000000@411e4@ T @4_Z5isNegd@
            00000000000011d5 T _Z5isNeg@2i@
            0000000000001222 T _Z5isNeg@2ii@
            ....
          \end{codetext}
        \end{code}
      \end{column}\hfill
      \begin{column}<4->{0.49\textwidth}
        \structure{Assembler Code}

        \begin{code}[]
          \begin{codetext}[style=smaller,style=highlighting]
            _Z3fnv:
               push   %rbp
               mov    %rsp,%rbp
               mov    0xd0c(%rip),%rax
               movq   %rax,%xmm0
               callq  @411e4@ <@4_Z5isNegd@>
               pop    %rbp
               retq
          \end{codetext}
        \end{code}
      \end{column}
    \end{columns}

  \end{frame}
#+end_src

#+begin_src latex
  \begin{frame}[fragile]{Operatorüberladung}
    \bi
    \ii<1-> Arithmetische Operatoren (\texttt{+,-,*,/}) sind überladenen{
      \bi
      \ii Interpretation als Funktionsaufrufe: \codebox{2 + 3} $\rightarrow$ \codebox{+(2, 3)}
      \ii Der Operator (z.B., \texttt{+} oder \texttt{++}) wird zum Funktionsnamen: \texttt{\colorbox{badbee!50}{++}(a)}
      \ii Sprachen deklarieren bereits mehrere überladene Implementierungen:{\\
        \btSetNamedTab[1cm]{\first}%
        \btSetNamedTab[4.5cm]{\second}%
        \first \siginline{+}{(int, int)}{int}       \second Addition von Ganzzahlen\\
        \first \siginline{+}{(float, float)}{float} \second Addition von Gleitkommazahlen\\
        \first \siginline{+}{(string, string)}{string} \second Konkatenierung von Zeichenketten
      }
      \ii[$\Rightarrow$] Der Übersetzer braucht bereits Infrastruktur zur Überladungsauflösung
      \ei
    }\smallskip
    \ii<2-> Manche Sprachen erlauben eigene Operatorüberladungen{
      \bi
      \ii Die selbst-deklarierte Überladungen müssen \enquote{magischen} Namen tragen
      \ii Overload Set enthält Eingebaute und selbst-deklarierten Operatoren
      \ei
    }
    \begin{code}[tag=C++]
      \begin{CPP}[style=highlighting,style=smaller]
        struct complex {
          int real, imag;
          complex(int r, int i)  {real = r;   imag = i;} // Konstruktor
        };

        complex @2operator+@ (complex c1, complex c2) {
          return complex(c1.real + c2.real, c1.imag + c2.imag);
        }
      \end{CPP}
    \end{code}
    \ei


  \end{frame}

#+end_src

** Überladung und Polymorphismus
#+begin_src latex
\begin{frame}{Erinnerung: Arten des Polymorphismus}
\btAnimation[width=\textwidth]{center, padding, 5:<1>}{fig/03-polymorphismus}
\end{frame}

  \begin{frame}[fragile]{Interaktion zwischen Überladung und Subtypen}
    \textbf{Erinnerung}: Subtyping ist eine Form des universellen Polymorphismus. Bei Vererbung ist die Kindsklasse ein Subtyp  der Elternklasse .

    \begin{btBlock}{}
      Ein polymorphes Typssystem führt Typkomptaibilität ein und erzeugt damit \structure{Uneindeutigkeit}. Diese muss die Sprache eindeutig auflösen.
    \end{btBlock}\medskip

    \begin{columns}[t]
      \begin{column}<2->{0.49\textwidth}
        \STRUCTURE{An der Deklarationsstelle}\\[1ex]

        \begin{code}[tag=C++]
          \begin{CPP}[style=highlighting,style=smaller]
            class S : public B {}
            void @+3f(B * obj)@ {...}
            void @+3f(S * obj)@ {...}
            ...
            S * obj = new S();
            f(obj); // f(S *)
          \end{CPP}
        \end{code}

        \bii
        \ii Subtyp \texttt{S} kompatibel zu \texttt{B}
        \ii Beide Dekls.. passen  zum Aufruf
        \ii Welche Deklaration wählen wir?
        \eii
        \smallskip
        \alert{$\Rightarrow$ Berechnung der Spezfifizät}

      \end{column}\hfill
      \begin{column}<4->{0.49\textwidth}
        \STRUCTURE{An der Aufrufstelle}\\[1ex]

        \begin{code}[tag=C++]
          \begin{CPP}[style=highlighting,style=smaller]
            // wie links
            void f(@+5B * this@, int x) {...}
            void f(@+5S * this@, int x) {...}
            ...
            @+5B *obj@ = new S();
            f(@+5obj@, 23);
          \end{CPP}
        \end{code}
        \bii
        \ii Variablendeklaration vs. Objekt
        \ii Statischer Typ != Dynamischer Typ
        \ii Welchen Typen sollen wir beachten?
        \eii
        \smallskip
        \alert{$\Rightarrow$ Dynamischer Dispatch}
      \end{column}
    \end{columns}
  \end{frame}


  \begin{frame}{Auswahl der spezifischsten Überladung}
    \btAnimation[width=0.9\textwidth]{range=1-8:<1->}{fig/04-overloading-subtypes}

    \medskip
    {\small \textbf{Intuition:} Umso mehr Casts notwendig sind, umso schlechter die \structure{Spezifität}.}

    \bii
    \ii<2-> Bestimmung der Argument--Parameter \alert<2>{Distanz} in der Vererbungshierarchie
    \ii<3-> Inkompatible Typen erzeugen eine Distanz von $\infty$
    \ii<7-> Der niedrigste Score ist die höchste Spezifität
    \eii
  \end{frame}
#+end_src

#+begin_src latex
  \begin{frame}[fragile]{Dynamischer Dispatch anhand des dynamischen Typs}
    \begin{columns}[b]
      \begin{column}{0.49\textwidth}
      \begin{code}[tag=Java]
        \begin{java}
          Base obj = new Derived();
          func(obj);
          // dynamisch: func(Derived)
          // statisch:  func(Base)


        \end{java}
      \end{code}
      \end{column}\hfill
      \begin{column}<3->{0.49\textwidth}
        \begin{code}[tag=Py]
          \begin{py}[style=smaller]
            def f(self, obj):
               if isinstance(obj, Derived):
                   return f_Derived(obj)
               elif isinstance(obj, Base):
                   return f_Base(obj)
               raise TypeError()
          \end{py}
        \end{code}
      \end{column}
    \end{columns}

    \textbf{Bisher} haben wir nur den statischen Typen der Argumente betrachtet.
    \medskip

    \bi
    \ii<2-> \structure{Dynamic Dispatch}: Überladungsauswahl anhand des dynamischen Typs{
      \be
      \ii Vorberechnung eines eingeschränkten Overload Sets
      \ii Zur Laufzeit: Extraxtion des dynamischen Typs \alert{aller} Argumente
      \ii Berechnung und Aufruf der spezifischsten Überladung
      \ee
    }\smallskip
    \ii<3-> \structure{Multiple Dynamic Dispatch}: Dynamischer Dispatch allen Argumenten {
      \bi
      \ii Wird nur von wenige Sprachen direkt unterstützt (Common Lisp, Julia)
      \ii Auswahl der passendsten Variante erzeugt hohen  Aufwand zur Laufzeit
      \ii Emulation mit Hilfskonstrukten, wie \texttt{isinstance} Kaskaden.
      \ei
    }
    \ei
    \uncover<4->{
      \medskip
      \alert{$\Rightarrow$ Eingeschränkte Form (single dynamic dispatch) wird häufig angeboten.}
    }
  \end{frame}

  \begin{frame}[fragile]{Single Dynamic Dispatch: Virtuelle Methoden}
    \OrangeBox{Virtuelle Methoden sind eine Form von Dynamic Dispatch.}
    \medskip
    \begin{columns}
      \begin{column}{0.6\textwidth}
        \begin{code}[tag=Java]
          \begin{java}[style=smaller,escapechar=`]
            class Base {
              public void foo(int x, int y){...}
            }
          \end{java}
          \begin{java}[style=smaller,escapechar=`]
            class Derived extends Base {
             `\tikzmark{def}`public void foo(int x, int y){...}
            }
            ...
            Base obj = new Derived();
            `\tikzmark{callsite}`obj.foo(1, 1);
          \end{java}
        \end{code}
        \begin{tikzpicture}[remember picture,overlay,visible on=<2->]
          \draw[->,safegreen,thick] (pic cs:callsite)++(up:.5ex) -- ++(west:1em) |- ($(pic cs:def)+(up:0.5ex)$);
        \end{tikzpicture}
      \end{column}\hfill
      \begin{column}{0.39\textwidth}
        \btAnimation[width=\textwidth]{range=1-2:<1->}{fig/04-dynamic-dispatch}
      \end{column}
    \end{columns}

    \bi
    \ii \structure{Methoden} werden im Kontext einer Klasse deklariert.{
      \bi
      \ii Methoden werden \enquote{auf einem Objekt} aufgerufen: \codebox{obj.foo(1,1)}
      \ii Das Objekt wird zu einem impliziten Argument (\texttt{this := obj})
      \ii Bei \structure{statischen Methoden} wird nur der statische Typ beachtet.
      \ei
    }\medskip
    \ii<2-> \structure{Virtuelle Methoden}: dynamischer Dispatch auf dem \texttt{this} Argument{
      \bi
      \ii Die passende Überladung hängt am Objekt, nicht an der Variable.
      \ii Effizient implementierbar mit virtuellen Funktionstabellen (vtable).
      \ii In Java ist jede Methode, per default, eine virtuelle Methode.
      \ei
    }
    \ei

  \end{frame}

#+end_src
* Summary
#+begin_src latex
  \begin{frame}{Zusammenfassung}
    \bi
    \ii \structure{Namen} sind symbolische und statische Objektreferenzen {
      \bi
      \ii Bei der \structure{Deklaration} können Namen mit (Typ)information versehen werden
      \ii Deklarationen werden in hierarchischen \structure{Namensräumen} strukturiert.
      \ii Eingeschränkte Sichtbarkeit und Import von Namen möglich
      \ei
    }\medskip
    \ii \structure{Namensauflösung} berechnet aus einem Namen die Objektadresse{
      \bi
      \ii Vollständige Auflösung ist nur nach der \structure{Binding Time} eines Namens möglich
      \ii \structure{Partielle Auflösung} kann bereits vorgezogen werden (Variablendeklaration)
      \ei
    }\medskip
    \ii \structure{Instantiierbare Namensräume} führen zu dynamischer Namensauflösung {
      \bi
      \ii Eine Deklaration beschreibt viele Laufzeitobjekte (\texttt{struct}, \texttt{class})
      \ii Laufzeitwissen wird zur vollständigen Namensauflösung benötigt (\texttt{this})
      \ei
    }\medskip
    \ii \structure{Überladene Funktionen} werden mit Typinformationen aufgelöst {
      \bi
      \ii Neben dem Funktionsnamen wird auch die \structure{Typsignatur} einbezogen.
      \ii Bei Subtyping: Auswahl zwischen statischem und \structure{dynamischem Dispatch}.
      \ei
    }

    \ei
  \end{frame}

#+end_src
