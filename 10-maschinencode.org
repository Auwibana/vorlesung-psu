#+TITLE: Programmiersprachen und Übersetzer
#+SUBTITLE: 10 - Maschinencode
#+SETUPFILE: setup.org
#+INCLUDE: export-prologue.org
#+PROPERTY: header-args:latex :tangle yes :noweb yes :tangle-macros yes :tangle-prologue topic :tangle-epilogue endtopic :exports none

#+NAME: topic
#+BEGIN_SRC latex :tangle no
\psuSectionStart{{{{property(ITEM)}}}}{{{{n(block)}}}}
#+END_SRC

#+NAME: endtopic
#+BEGIN_SRC latex :tangle no
\psuSectionStop{{{{property(ITEM)}}}}{{{{n(block,-)}}}}
#+END_SRC

* Gedanken zu dieser Vorlesung                                     :noexport:
- Endgültiges Lowering auf Maschinencode
  - Call-Frame und Call-Sequenzen
  - Instruktionen als Snippets auswählen
  - Spilling und Registerauswahl
  - [Graphfärben]?
- Tooling
  - Assembler
  - ELF
  - Dynamische Libraries

Effektive  Programmierer: 
Effiziente Programmierer: 

* Was leistet die "Maschinencodeerzeugung"?
:PROPERTIES:
:CUSTOM_ID: 10-einleitung
:END:

#+begin_src latex
  \subtitle{{{{subtitle()}}}}
  \begin{frame}
    \maketitle
  \end{frame}

  \begin{frame}{Einordnung in die Vorlesung: Maschinencodeerzeugung}
    \begin{center}
      \includegraphics[page=8,width=0.9\linewidth]{fig/01-overview-small}
    \end{center}
    \bi
    \ii Zwischencode der virtuellen Maschine auf eine \structure{reale Maschine} abbilden{%
      \bi
      \ii Verbleibende \alert{semantische Lücken}: Funktionsaufrufe, lokale Variablen, Befehle
      \ii Application Binary Interface (ABI), Registervergabe, Binärformat (ELF),
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[fragile,t]{Wo stehen wir? Wo wollen wir hin?}
    \vspace{-1em}
    \begin{columns}[t]
    \begin{column}{0.49\textwidth}
      \columntitle{Zwischencode-Maschine}
      \vspace{-1em}
      \btAnimation[width=0.7\textwidth]{center,raisebox,1:<1->}{10-motivation}
      \bii
      \ii Speicherabstraktion\tikzmark{left-memory}{
        \bi
        \ii unendlich viele Parameter
        \ii unendlich viele Variablen
        \ei
      }
      \ii Befehle \tikzmark{left-befehle}{
        \bi
        \ii Meist 3-Adress-Befehle
        \ii \ircmd{Call}: Beliebige Argumentzahl
        \ei
      }
      \ii Speicherung des Programms\tikzmark{left-program} {
        \bi
        \ii Objekte im Übersetzerzustand
        \ii Basisblöcke sind ungeordnet
        \ei
      }
      \eii
    \end{column}\hfill
    \begin{column}{0.49\textwidth}
      \columntitle{Reale Maschine (z.B. IA-32)}


      {\ttfamily\footnotesize
        \def\OPB{\bfseries\let\OP\OPA}
        \def\OPA{\mdseries\let\OP\OPB}
        \let\OP\OPA
        \renewcommand{\baselinestretch}{0.8}
        \newcommand{\B}{{\let\kern\hskip\,}}
        \begin{minipage}{1.0\linewidth}
          \hspace{-1ex}\textbf{foo:}\\
          \OP c8\B 0c\B 00\B  00\B%
          \OP 8b\B 45\B 08\B%
          \OP bb\B 03\B 00\B 00\B00\B%
          \OP 01\B c3\B%
          \OP 89\B 5d\B fc\B%
          \OP b8\B 04\B 00\B 00\B 00\B%
          \OP 0f\B af\B d8\B%
          \OP 89\B 5d\B f8\B%
          \OP b8\B 13\B 00\B 00\B 00\B%
          \OP 50\B%
          \OP 53\B%
          \OP 8b\B 4d\B 08\B%
          \OP 51\B%
          \OP e8\B bb\B ff\B ff\B ff\B%
          \OP 83\B c4\B 0c\B%
          \OP 89\B 45\B f4\B%
          \OP c9\B%
          \OP c3\B%
        \end{minipage}
      }{\\[1ex]\scriptsize (Keine Sorge. Wir gehen nur bis Assembler)}
      \medskip
      \bii
          \ii \tikzmark{right-memory}Speicherabstraktion {
        \bi
        \ii 6 Ganzzahl-Register (32-Bit)
        \ii Endlicher Speicher (ausreichend)
        \ei
      }\medskip
      \ii \tikzmark{right-befehle}Befehle {
        \bi
        \ii 2 Operanden, Zeitgleich Quelle+Ziel
        \ii \ircmd{call} transportiert keine Argumente
        \ii Verschiedene Adressierungsmodi
        \ii Komplexe Befehle (CISC)
        \ei
      }\medskip
      \ii \tikzmark{right-program}Speicherung des Programms {
        \bi
        \ii Binärformat des Betriebssystems
        \ii Lineare Sequenz von Befehlen
        \ei
      }
      \eii

    
    \end{column}
  \end{columns}

  \only<2->{\AtBeginShipoutNext{%
      \AtBeginShipoutUpperLeftForeground{%
        \begin{tikzpicture}[remember picture, overlay]%
          \draw[ultra thick,srared,->] ($(pic cs:left-befehle)+(up:3pt)$) -- ($(pic cs:right-befehle)+(-1pt,3pt)$);
          \draw[ultra thick,srared,->] ($(pic cs:left-memory)+(up:3pt)$) --node[fill=white,draw,align=center,anchor=south east,pos=0.8,yshift=-2ex]{Wir verwenden IA-32\\als Beispiel}  ($(pic cs:right-memory)+(-1pt,3pt)$);
          \draw[ultra thick,srared,->] ($(pic cs:left-program)+(up:3pt)$) -- ($(pic cs:right-program)+(-1pt,3pt)$);
        \end{tikzpicture}
      }
    }
  }
  \end{frame}
#+end_src

* Speicherabstraktion: Call-Frames

#+begin_src latex
  %%ONLY%%
  \dividerframe{Speicherabstraktion:\\Call-Frames}
  \begin{frame}{Funktionsaufrufe auf Maschinenebene}
    \btAnimation[width=0.8\textwidth]{center,1:<1->}{fig/10-call-terms}

    \bi
    \ii \structure{Funktionsaufruf}: Argumente werden als Parameter übertragen {
      \bi
      \ii IR-Ebene: Beliebig viele Parameter kommen \enquote{magisch} beim Callee an
      \ii \textbf{Erinnerung}: Aufrufe erzeugen \alert{Funktionsinstanz mit eigenem Call-Frame}
      \ii Call-Frame enthält Parameter, Rücksprungadresse und lokale Variablen
      \ei
    }\medskip
    \ii<2-> Für die reale Maschine müssen wir einige \textbf{Entscheidungen} treffen:{%
      \bi
      \ii \structure{Daten-Layout}: Welches Datum liegt an welcher Stelle?
      \ii \structure{Verantwortung}: Wer legt den Call-Frame an und füllt ihn mit Daten?
      \ii \structure{Invarianten}: \btSetTab Welche Teile des Maschinenzustandes bleiben über einen\\
                                   \btUseTab Funktionsaufruf hinweg erhalten?\\[1ex]
      \ii[$\Rightarrow$] Die Antworten hierauf ergeben die \structure{Aufrufkonvention}.
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[fragile]{Aufrufkonventionen}
    \begin{btBlock}{Definition:  Die Aufuf\textbf{konvention} bestimmt,\ldots}
      \ldots wie \structure{Argumente} an Funktionen übergeben werden und\\
      \ldots welche Teile des \structure{Maschinenzustands} der Callee erhalten muss und\\
      \ldots wo der Caller den \structure{Rückggabewert} auslesen kann.
    \end{btBlock}

    \bi
    \ii Das Betriebssystem und Übersetzer bestimmen die Aufrufkonvention {
      \bi
      \ii Funktionen können unabhängig voneinander übersetzt werden.
      \ii Interoperabilität zwischen verschiedenen Übersetzern und Sprachen
      \ei
    }\medskip
    \ii<2-> Beispiel: Sys-V Calling Convention für C auf IA-32/GNU Linux{
      \bi
      \ii Callee legt Call-Frame auf dem Stack an und räumt ihn wieder weg
      \ii Argumente werden von \textbf{rechts-nach-links} auf den Stack gelegt
      \ii Rückggabewerte: \btSetTab \texttt{\%eax} für \lstinline[style=C]{int}, \texttt{\%st0} für \lstinline[style=C]{double}\\
                          \btUseTab Größere Argumente/Rückggabewerte: Wie in Vorlesung 8
      \ii \structure{Callee-saved Register}: \texttt{\%esp, \%ebp, \%ebx, \%esi, \%edi}
      \ei
    }
    \ei
    \medskip
    \uncover<3->{Andere Konvention (auf IA-32): \btSetTab syscall, optlink, pascal, stdcall, fastcall,\\
                                                \btUseTab vectorcall, safecall, thiscall, \ldots}
  \end{frame}


  \begin{frame}{Call-Frame auf IA-32/Linux}

    \begin{columns}
      \begin{column}{0.4\textwidth}
        \btAnimation[width=\textwidth]{range=1-7:<1->}{fig/10-stack}%
        \btAnimation[width=\textwidth]{5:<8>,4:<9>,1:<10>}{fig/10-stack}

      \end{column}\hfill
      \begin{column}{0.6\textwidth}
        \bii
        \ii Auf der IA-32 Plattform wächst der Stack von den hohen zu den niedrigen Adressen
        \ii Der \structure{Stackpointer} is in \texttt{\%esp}
        \eii
        \medskip

        \columntitle{Aufrufsequenz}

        \bi\ii[]\be
        \ii<2-> Argumente von \textbf{rechts nach links} ermöglicht Funktionen mit variabler Argumentenzahl {
          \bi
          \ii \texttt{\texttt{push arg2}; \only<3->{\texttt{push arg1}; }\only<4->{\texttt{push arg0};}}
          \ei
        }
        \ii<5-> CPU legt Rücksprungaddresse auf den Stack{
          \bi
          \ii \texttt{call bar}
          \ei
        }
        \ii<7-> Konstante Offsets durch Basiszeiger{
          \bi
          \ii \texttt{push \%ebp; mov \%esp, \%ebp;}
          \ei
        }
        \ii<6-> Callee kann Raum für lokale Daten anlegen{
          \bi
          \ii sub x, \%esp
          \ei
        }
        \ii<8-> Return: in umgekehrter Reihenfolge
        \ee\ei
      \end{column}
    \end{columns}


  \end{frame}

  \begin{frame}{Unterschiede der Aufrufkonventionen}
    \bi
    \ii Übergabe von \structure{Argumenten in Registern} {
      \bi
      \ii Die ersten N Argumente können in Registern übergeben werden
      \ii Spart Speicherzugriffe  beim Funktionsaufruf 
      \ei
    }\bigskip
    \ii<2-> \textbf{Trade-Off} zwischen Caller-save/Callee-save Register Mengen {
      \bi
      \ii Wenige Caller-save Register: Wenig unnötige Register-Sicherungen
      \ii Wenige Callee-save Register: Blattfunktionen können in Registern arbeiten
      \ei
    }\bigskip
    \ii<3-> Zusätzliche Parameter liefern Aufrufkontext {
      \bi
      \ii \textbf{thiscall}: In C++ wird der this-Zeiger in \texttt{\%ecx} übergeben
      \ii Zieladdresse für Rückgabe-Objekte im  0. Parameter
      \ei
    }
    \ei
  \end{frame}
#+end_src

http://www.sco.com/developers/devspecs/abi386-4.pdf ab Seite 35
- Call-Frames
- Application-Binary Interface
- Slots für lokale Variablen


* Befehle: Codierung und Registerallokation

* Speicherung des Programms: ELF
