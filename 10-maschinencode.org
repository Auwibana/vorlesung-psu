#+TITLE: Programmiersprachen und Übersetzer
#+SUBTITLE: 10 - Maschinencode
#+SETUPFILE: setup.org
#+INCLUDE: export-prologue.org
#+PROPERTY: header-args:latex :tangle yes :noweb yes :tangle-macros yes :tangle-prologue topic :tangle-epilogue endtopic :exports none

#+NAME: topic
#+BEGIN_SRC latex :tangle no
\psuSectionStart{{{{property(ITEM)}}}}{{{{n(block)}}}}
#+END_SRC

#+NAME: endtopic
#+BEGIN_SRC latex :tangle no
\psuSectionStop{{{{property(ITEM)}}}}{{{{n(block,-)}}}}
#+END_SRC

* Gedanken zu dieser Vorlesung                                     :noexport:
- Endgültiges Lowering auf Maschinencode
  - Call-Frame und Call-Sequenzen
  - Instruktionen als Snippets auswählen
  - Spilling und Registerauswahl
  - [Graphfärben]?
- Tooling
  - Assembler
  - ELF
  - Dynamische Libraries

Effektive  Programmierer: 
Effiziente Programmierer: 

* Was leistet die "Maschinencodeerzeugung"?
:PROPERTIES:
:CUSTOM_ID: 10-einleitung
:END:

#+begin_src latex
  \subtitle{{{{subtitle()}}}}
  \begin{frame}
    \maketitle
  \end{frame}

  \begin{frame}{Einordnung in die Vorlesung: Maschinencodeerzeugung}
    \begin{center}
      \includegraphics[page=8,width=0.9\linewidth]{fig/01-overview-small}
    \end{center}
    \bi
    \ii Zwischencode der virtuellen Maschine auf eine \structure{reale Maschine} abbilden{%
      \bi
      \ii Verbleibende \alert{semantische Lücken}: Funktionsaufrufe, lokale Variablen, Befehle
      \ii Application Binary Interface (ABI), Registervergabe, Binärformat (ELF),
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[fragile,t]{Wo stehen wir? Wo wollen wir hin?}
    \vspace{-1em}
    \begin{columns}[t]
    \begin{column}{0.49\textwidth}
      \columntitle{Zwischencode-Maschine}
      \vspace{-1em}
      \btAnimation[width=0.7\textwidth]{center,raisebox,1:<1->}{10-motivation}
      \bii
      \ii Speicherabstraktion\tikzmark{left-memory}{
        \bi
        \ii unendlich viele Parameter
        \ii unendlich viele Variablen
        \ei
      }
      \ii Befehle \tikzmark{left-befehle}{
        \bi
        \ii Meist 3-Adress-Befehle
        \ii \ircmd{Call}: Beliebige Argumentzahl
        \ei
      }
      \ii Speicherung des Programms\tikzmark{left-program} {
        \bi
        \ii Objekte im Übersetzerzustand
        \ii Basisblöcke sind ungeordnet
        \ei
      }
      \eii
    \end{column}\hfill
    \begin{column}{0.49\textwidth}
      \columntitle{Reale Maschine (z.B. IA-32)}


      {\ttfamily\footnotesize
        \def\OPB{\bfseries\let\OP\OPA}
        \def\OPA{\mdseries\let\OP\OPB}
        \let\OP\OPA
        \renewcommand{\baselinestretch}{0.8}
        \newcommand{\B}{{\let\kern\hskip\,}}
        \begin{minipage}{1.0\linewidth}
          \hspace{-1ex}\textbf{foo:}\\
          \OP c8\B 0c\B 00\B  00\B%
          \OP 8b\B 45\B 08\B%
          \OP bb\B 03\B 00\B 00\B00\B%
          \OP 01\B c3\B%
          \OP 89\B 5d\B fc\B%
          \OP b8\B 04\B 00\B 00\B 00\B%
          \OP 0f\B af\B d8\B%
          \OP 89\B 5d\B f8\B%
          \OP b8\B 13\B 00\B 00\B 00\B%
          \OP 50\B%
          \OP 53\B%
          \OP 8b\B 4d\B 08\B%
          \OP 51\B%
          \OP e8\B bb\B ff\B ff\B ff\B%
          \OP 83\B c4\B 0c\B%
          \OP 89\B 45\B f4\B%
          \OP c9\B%
          \OP c3\B%
        \end{minipage}
      }{\\[1ex]\scriptsize (Keine Sorge. Wir gehen nur bis Assembler)}
      \medskip
      \bii
          \ii \tikzmark{right-memory}Speicherabstraktion {
        \bi
        \ii 6 Ganzzahl-Register (32-Bit)
        \ii Endlicher Speicher (ausreichend)
        \ei
      }\medskip
      \ii \tikzmark{right-befehle}Befehle {
        \bi
        \ii 2 Operanden, Zeitgleich Quelle+Ziel
        \ii \ircmd{call} transportiert keine Argumente
        \ii Verschiedene Adressierungsmodi
        \ii Komplexe Befehle (CISC)
        \ei
      }\medskip
      \ii \tikzmark{right-program}Speicherung des Programms {
        \bi
        \ii Binärformat des Betriebssystems
        \ii Lineare Sequenz von Befehlen
        \ei
      }
      \eii

    
    \end{column}
  \end{columns}

  \only<2->{\AtBeginShipoutNext{%
      \AtBeginShipoutUpperLeftForeground{%
        \begin{tikzpicture}[remember picture, overlay]%
          \draw[ultra thick,srared,->] ($(pic cs:left-befehle)+(up:3pt)$) -- ($(pic cs:right-befehle)+(-1pt,3pt)$);
          \draw[ultra thick,srared,->] ($(pic cs:left-memory)+(up:3pt)$) --node[fill=white,draw,align=center,anchor=south east,pos=0.8,yshift=-2ex]{Wir verwenden IA-32\\als Beispiel}  ($(pic cs:right-memory)+(-1pt,3pt)$);
          \draw[ultra thick,srared,->] ($(pic cs:left-program)+(up:3pt)$) -- ($(pic cs:right-program)+(-1pt,3pt)$);
        \end{tikzpicture}
      }
    }
  }
  \end{frame}
#+end_src

* Speicherabstraktion: Call-Frames

#+begin_src latex
  \dividerframe{Speicherabstraktion:\\Call-Frames}
  \begin{frame}{Funktionsaufrufe auf Maschinenebene}
    \btAnimation[width=0.8\textwidth]{center,1:<1->}{fig/10-call-terms}

    \bi
    \ii \structure{Funktionsaufruf}: Argumente werden als Parameter übertragen {
      \bi
      \ii IR-Ebene: Beliebig viele Parameter kommen \enquote{magisch} beim Callee an
      \ii \textbf{Erinnerung}: Aufrufe erzeugen \alert{Funktionsinstanz mit eigenem Call-Frame}
      \ii Call-Frame enthält Parameter, Rücksprungadresse und lokale Variablen
      \ei
    }\medskip
    \ii<2-> Für die reale Maschine müssen wir einige \textbf{Entscheidungen} treffen:{%
      \bi
      \ii \structure{Daten-Layout}: Welches Datum liegt an welcher Stelle?
      \ii \structure{Verantwortung}: Wer legt den Call-Frame an und füllt ihn mit Daten?
      \ii \structure{Invarianten}: \btSetTab Welche Teile des Maschinenzustandes bleiben über einen\\
                                   \btUseTab Funktionsaufruf hinweg erhalten?\\[1ex]
      \ii[$\Rightarrow$] Die Antworten hierauf ergeben die \structure{Aufrufkonvention}.
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[fragile]{Aufrufkonventionen}
    \begin{btBlock}{Definition:  Die Aufuf\textbf{konvention} bestimmt,\ldots}
      \ldots wie \structure{Argumente} an Funktionen übergeben werden und\\
      \ldots welche Teile des \structure{Maschinenzustands} der Callee erhalten muss und\\
      \ldots wo der Caller den \structure{Rückggabewert} auslesen kann.
    \end{btBlock}

    \bi
    \ii Das Betriebssystem und Übersetzer bestimmen die Aufrufkonvention {
      \bi
      \ii Funktionen können unabhängig voneinander übersetzt werden.
      \ii Interoperabilität zwischen verschiedenen Übersetzern und Sprachen
      \ei
    }\medskip
    \ii<2-> Beispiel: Sys-V Calling Convention für C auf IA-32/GNU Linux{
      \bi
      \ii Callee legt Call-Frame auf dem Stack an und räumt ihn wieder weg
      \ii Argumente werden von \textbf{rechts-nach-links} auf den Stack gelegt
      \ii Rückggabewerte: \btSetTab \texttt{\%eax} für \lstinline[style=C]{int}, \texttt{\%st0} für \lstinline[style=C]{double}\\
                          \btUseTab Größere Argumente/Rückggabewerte: Wie in Vorlesung 8
      \ii \structure{Callee-saved Register}: \texttt{\%esp, \%ebp, \%ebx, \%esi, \%edi}
      \ei
    }
    \ei
    \medskip
    \uncover<3->{Andere Konvention (auf IA-32): \btSetTab syscall, optlink, pascal, stdcall, fastcall,\\
                                                \btUseTab vectorcall, safecall, thiscall, \ldots}
  \end{frame}


  \begin{frame}{Call-Frame auf IA-32/Linux}

    \begin{columns}
      \begin{column}{0.4\textwidth}
        \btAnimation[width=\textwidth]{range=1-7:<1->}{fig/10-stack}%
        \btAnimation[width=\textwidth]{5:<8>,4:<9>,1:<10>}{fig/10-stack}

      \end{column}\hfill
      \begin{column}{0.6\textwidth}
        \bii
        \ii Auf der IA-32 Plattform wächst der Stack von den hohen zu den niedrigen Adressen
        \ii Der \structure{Stackpointer} is in \texttt{\%esp}
        \eii
        \medskip

        \columntitle{Aufrufsequenz}

        \bi\ii[]\be
        \ii<2-> Argumente von \textbf{rechts nach links} ermöglicht Funktionen mit variabler Argumentenzahl {
          \bi
          \ii \texttt{\texttt{push arg2}; \only<3->{\texttt{push arg1}; }\only<4->{\texttt{push arg0};}}
          \ei
        }
        \ii<5-> CPU legt Rücksprungaddresse auf den Stack{
          \bi
          \ii \texttt{call bar}
          \ei
        }
        \ii<7-> Konstante Offsets durch Basiszeiger{
          \bi
          \ii \texttt{push \%ebp; mov \%esp, \%ebp;}
          \ei
        }
        \ii<6-> Callee kann Raum für lokale Daten anlegen{
          \bi
          \ii sub x, \%esp
          \ei
        }
        \ii<8-> Return: in umgekehrter Reihenfolge
        \ee\ei
      \end{column}
    \end{columns}


  \end{frame}

  \begin{frame}{Unterschiede der Aufrufkonventionen}
    \bi
    \ii Übergabe von \structure{Argumenten in Registern} {
      \bi
      \ii Die ersten N Argumente können in Registern übergeben werden
      \ii Spart Speicherzugriffe  beim Funktionsaufruf 
      \ei
    }\bigskip
    \ii<2-> \textbf{Trade-Off} zwischen Caller-save/Callee-save Register Mengen {
      \bi
      \ii Wenige Caller-save Register: Wenig unnötige Register-Sicherungen
      \ii Wenige Callee-save Register: Blattfunktionen können in Registern arbeiten
      \ei
    }\bigskip
    \ii<3-> Zusätzliche Parameter liefern Aufrufkontext {
      \bi
      \ii \textbf{thiscall}: In C++ wird der this-Zeiger in \texttt{\%ecx} übergeben
      \ii Zieladdresse für Rückgabe-Objekte im  0. Parameter
      \ei
    }
    \ei
  \end{frame}
#+end_src

http://www.sco.com/developers/devspecs/abi386-4.pdf ab Seite 35


#+begin_src latex
  \begin{frame}[fragile]{Lokale Variablen}
    \begin{btBlock}{Die Welt am Beginn einer Funktion\hfill Parameter: \checkmark}\small
      \begin{columns}
        \begin{column}{0.7\textwidth}
          Nachdem Sicherung des \alert{alten Basiszeigers}, sind die Parameter mit einem \structure{konstanten, positiven Offset} zum \advantage{neuen Basiszeiger} adressierbar.       
        \end{column}\hfill
        \hspace{-3ex}\begin{column}{0.3\textwidth}\ttfamily
          bar:\\
          \ \alert{push \%ebp}\\
          \ \advantage{mov \%esp, \%ebp}\\
          \ mov \structure{8(\%ebp)}, \%eax
        \end{column}
      \end{columns}
    \end{btBlock}

    \bi
    \ii<2-> Unendlicher virtueller Registersatz (IR) vs. endlicher realer Registersatz{
      \bi
      \ii IR-Variablen müssen auf Speicherstellen im Call-Frame abgebildet werden
      \ii Einfachste Variante: Jede Variable $\rightarrow$ ein \structure{Slot} im Call-Frame{\\[1ex]
        \begin{columns}
          \hfill\begin{column}{0.7\textwidth}
            \begin{code}[tag=Python]
              \begin{py}
                for idx, var in enumerate(function.variables):
                   var.slot       = idx
                   var.ebp_offset = -4 + (-4 * idx)
              \end{py}
            \end{code}
          \end{column}\hfill
        \end{columns}\mbox{}\\[1ex]
      }
      \ii Variablen-Slots werden relativ zum Basiszeiger adressiert
      \ei
    }\medskip
    \ii<3-> Komplexer: Colokation von Variablen in Slots + kluge \structure{Registerallokation}
    \ei
  \end{frame}


#+end_src

* Befehlsauswahl und Registerallokation

#+begin_src latex
  \dividerframe{Befehlsauswahl\\und\\Registerallokation}

  \begin{frame}{Übersetzung des IR-Programms}
    \vspace{-2em}
    \begin{columns}[t]
      \begin{column}{0.49\textwidth}
        \begin{btBlock}{\hfill Befehlsauswahl\tikzmark{A}\hfill\mbox{}}
          Wähle für jeden IR-Befehl eine einzelne oder einer Sequenz aus Maschinenbefehlen aus.        
        \end{btBlock}

        \bii
        \ii<2-> Abbildung meinst nicht eindeutig {\\[1ex]
          \enquote{AMD64 kennt 36 \texttt{mov}-Varianten}\\[1ex]
          \bi
          \ii Unterschiedliche Programmgröße
          \ii Unterschiedlich Laufzeit
          \ii Unterschiedlicher Energieverbrauch
          \ei
        }\medskip
        \ii<2-> Betrachtung mehrerer IR-Befehle verbessert die Befehlsauswahl
        \eii

      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \begin{btBlock}{\hfill\tikzmark{B}Registerallokation\hfill\mbox{}}
          Bestimme in welchen Abschnitten eine IR-Variable in ihrem Slot oder in einem CPU Register lebt.
        \end{btBlock}

        \bii
        \ii<3-> Problem bei \#Variablen$>$\#Register
        \ii<3-> Konsistent für alle Kontrollflüsse
        \ii<3-> Massive Performance-Auswirkung {
          \bi
          \ii CPU-Register: \hspace{1em}\btSetTab 1 Zyklen
          \ii L1-Cache (Hit):     \btUseTab 4 Zyklen
          \ii L2-Cache (Hit):     \btUseTab 10 Zyklen
          \ii Speicher:     \btUseTab 60-100 Zyklen
          \ei
        }
        \eii
      \end{column}
    \end{columns}
    \begin{columns}
      \begin{column}<2->{0.49\textwidth}
        \bii
        \ii[$\Rightarrow$] Für sich: \ALERT{NP-Vollständig}
        \eii
      \end{column}\hfill
      \begin{column}<3->{0.49\textwidth}
        \bii
        \ii[$\Rightarrow$] Für sich: \ALERT{NP-Vollständig}
        \eii
      \end{column}
    \end{columns}

    \bigskip
    \uncover<4->{\hspace{-1em}\ALERT{Alles noch schlimmer}: Befehlsauswahl und Registerallokation beeinflussen sich gegenseitig und sind Abhängig von der CPU-Mikroarchitektur.}
  

      \only<4>{\AtBeginShipoutNext{%
        \AtBeginShipoutUpperLeftForeground{%
          \begin{tikzpicture}[remember picture, overlay]%
            \draw[ultra thick,srared,<->] ($(pic cs:A)+(up:3pt)$) -- node[above]{Interaktion}($(pic cs:B)+(-1pt,3pt)$);
          \end{tikzpicture}
        }
      }
    }
  
  \end{frame}

  \begin{frame}{Minimale Maschinencodeerzeugung}
    \vspace{-1em}
    \begin{btBlock}{}
      Wenn alles zu kompliziert ist, überlegt man sich den einfachsten Basisfall.
    \end{btBlock}
    \medskip

    \begin{columns}
      \begin{column}{0.6\textwidth}
    \bi
    \ii \structure{Befehlsauswahl}: Macroexpansion {
      \bi
      \ii<2-> Jeder IR-Befehl wird zu einer festen Assembler-Sequenz
      \ii<2-> Platzhalter für Registeroperanden
      \ii<3-> Zusätzliche Anweisungen wo und wie die Operanden vorliegen müssen
      \ii<4-> Muster für jede Instruktion instantiieren
      \ei
    }\medskip
    \ii \structure{Registerallokation}: Eager Spilling {
      \bi
      \ii<5-> \structure{Spilling}: Variable-Wert aus einem Register in den Speicher schreiben.\\[1ex]
      \ii<5-> Variablen immer neuladen
      \ii<5-> Ergebnisse direkt spillen
      \ii<6-> Jede Variable hat einen Speicher-Slot
      \ei
    }
    \ei
      \end{column}\hfill
      \begin{column}{0.4\textwidth}
        { \btAnimation[width=0.6\textwidth]{center,padding,1:<1->}{fig/10-operation-selection}
          \Large $\Downarrow$
          \medskip
        
        }
        \uncover<2->{\btAnimation[width=0.8\textwidth]{center,padding,2:<1>,range=2-6:<2->}{fig/10-operation-selection}}
      \end{column}
    \end{columns}
  \end{frame}

#+end_src

https://www.usenix.org/legacy/events/hotos09/tech/full_papers/baumann/baumann_html/index.html
https://stackoverflow.com/questions/4087280/approximate-cost-to-access-various-caches-and-main-memory#4087315

#+begin_src latex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \tikzset{solution/.style={
      inner xsep=2em,fill=white,
      fill opacity=0.8,
      label={[draw=safegreen, thick, minimum width=8cm,fill=white]center:{\Large\advantage{\textbf{#1}}}}
    }
  }


  \begin{frame}[fragile]{Probleme der Minimallösung}
    \textbf{3 Probleme}: \ALERT{\uncover<2->{Ineffizient}\uncover<3->{, Ineffizient}\uncover<4->{, Ineffizient.}}
    \bigskip

    \begin{tikznodeenv}[name=A]\begin{minipage}{\textwidth}
    \bi
    \ii<4-> Ständig werden Register, völlig ohne Not, \alert{gesichert und geladen}{
      \begin{columns}
        \begin{column}{0.75\textwidth}
          \btUseExtraItemSep[-\smallskipamount]\vspace{-1em}%
          \bi
          \ii Bereits in Registern vorgeladene Variablen werden veworfen
          \ii Hauptteil des Programs macht nur noch Spilling
          \ii Speicherzugriffe sind, trotz Cache, langsamer
          \ei
        \end{column}\hfill
        \begin{column}{0.25\textwidth}
          \begin{code}[]
            \begin{asm}[style=smaller]
              ...
              mov %ebx, -8(%ebp)
            \end{asm}
            \vspace{1pt}\hrule\vspace{1pt}
            \begin{asm}[style=smaller]
              mov -8(%ebp), %eax
              ...
            \end{asm}
          
          \end{code}
        \end{column}
      \end{columns}

    }
    \ei
    \end{minipage}\end{tikznodeenv}


    \begin{tikznodeenv}[name=B]\begin{minipage}{\textwidth}
    \bi
    \ii<5-> Starre Ersetzungsmuster nutzen \alert{komplexe CPU Befehle} nicht{
      \begin{columns}
        \begin{column}{0.7\textwidth}
          \btUseExtraItemSep[-\smallskipamount]\vspace{-1em}%
          \bi
          \ii Besonders bei CISC sind Befehle oft sehr mächtig
          \ii IR-Ops sind absichtlich einfach und HW-unabhängig
          \ii Ein Befehl überdeckt mehrere IR-Befehle
          \ei
        \end{column}\hfill
        \begin{column}{0.30\textwidth}
          \begin{code}[]
            \begin{asm}[style=smaller]
              imul %ebx, 8
              add %eax, %ebx
              mov (%ebx), %eax
            \end{asm}
          \end{code}%
          \vspace{2pt}%
          \begin{code}
            \begin{asm}[style=smaller]
              mov (%eax,%ebx,8), %eax
            \end{asm}
          \end{code}
        \end{column}
      \end{columns}
    }
    \ei
    \end{minipage}\end{tikznodeenv}

  \begin{tikznodeenv}[name=C]\begin{minipage}{\textwidth}
    \bi
    \ii<6-> Starre Befehlsreihenfolge \alert{ignorieren moderne Mikroarchitekturen}{
      \bi
      \ii Moderne Prozessoren arbeiten Pipelined, Out-of-Order und Superskalar
      \ii Befehle können im \enquote{Windschatten} anderer Befehle ausgeführt werden
      \ii Reihenfolge der Befehle hat massiven Einfluss auf die Ausführungszeit
      \ei
    }
    \ei
  \end{minipage} \end{tikznodeenv}

          
    \only<7->{\AtBeginShipoutNext{%
        \AtBeginShipoutUpperLeftForeground{%
          \begin{tikzpicture}[remember picture, overlay]
            %
            \node[fit=(A),solution={Globale(re) Registerallokation}]{};
            \node[fit=(B),solution={Peephole-Optimizer}]{};
            \node[fit=(C),solution={Instruktions-Scheduling}]{};
          \end{tikzpicture}
        }
      }
    }
  \end{frame}
#+end_src

#+begin_src latex
  \begin{frame}[fragile]{Ein Registerallokator mit Gedächtnis}
    \OrangeBox{Die Minimallösung vergisst nach jeder Instruktion alles.}
    \medskip
    \bi
    \ii \textbf{Idee}: Der Registersatz ist \structure{Cache} für die Speicher-Variablen-Slots{
      \bi
      \ii Bereits in Register geladene Variablen sollen wiederverwendet werden
      \ii Veränderte Variablen werden erst verzögert zurück geschrieben
      \ii Variablen \structure{leben} in ihrem Slot \textbf{oder} in einem Register
      \ei
    }\medskip
    \ii<2-> Registerallokation auf Granularität eines Basisblocks {
      \bi
      \ii Verschränkung von Registerallokation (RA) und Makroexpansion (ME)
      \ii ME weist  RA an Variablen zu laden bzw. Register zurückzuschreiben
      \ii RA führt währenddessen Buch über den Zustand des Registersatzes\\[1ex]{
        \begin{code}[]
          \begin{py}
            def emit_Add(self, instr):  # Makroexpansion für dst := Add lhs, rhs
               lhs = self.RA.load(instr.lhs)
               rhs = self.RA.load(instr.rhs, modify=True)
               self.emit_instr("add", lhs, rhs)
               self.RA.write(rhs, instr.dst)
          \end{py}
        \end{code}
      }
      \ii LLVM bietet mit \texttt{RegAllocFast.cpp} eine ähnliche Heuristik
      \ei
    }
    \ei
  \end{frame}


  \begin{frame}[fragile]{Interface des Allokators}
    \bi
    \ii Synchronisation zwischen Allokator und Expansion mittels \structure{Hooks} {
      \bi
      \ii \codeinline[style=py]{def before_Function(func)} -- Variablenslots festlegen
      \ii \codeinline[style=py]{def before_BasisBlock(bb)} -- Zurücksetzen des Allokatorzustandes
      \ii \codeinline[style=py]{def before_Instruction(instr)} -- Sonderbehandlung von \ircmd{Call}, \ircmd{Goto}...
      \ei
    }\medskip
    \ii Allokieren eines leeren Registers: \codeinline[style=py]{def alloc_register(reg=None)}{
      \bi
      \ii Wenn kein Register vorgegeben wird, wählt der Allokator eines aus
      \ii Noch ungesicherte Ergebnisse werden ggf. in den Variablen-Slot gespeichert
      \ei
    }\medskip
    \ii Lade Variable nach Register: \codeinline[style=py]{def load(src, dst_reg=None, modify=False)}{%
      \bi
      \ii Sorgt dafür dass \texttt{src} in einem Register vorliegt
      \ii Mit \texttt{dst\_reg} können wir ein spezifisches Register verlangen
      \ii Mit \texttt{modify} zeigen wir an, ob wir das Register verändern werden
      \ei
    }\medskip
    \ii Schreibe Register nach Variable: \codeinline[style=py]{def write(src_reg, dst_var)}{%
      \bi
      \ii \texttt{dst\_var} wird zukünftig den Wert \texttt{src\_reg} haben
      \ii Das Schreiben in den Speicher kann verzögert erfolgen
      \ei
    }
    \ei
  \end{frame}


  \begin{frame}{Zustand des Allokators}
    \btAnimation[width=0.6\textwidth]{center, padding, range=1-2:<1->}{fig/10-allocator}
    \bi
    \ii Während seiner Arbeit, trackt der Allokator den Registerzustand{
      \bi
      \ii \texttt{free}:  Wurde das Register für die aktuelle Instruktion schon benuzt?
      \ii \texttt{value}: Welche Variable lebt aktuell in diesem Register?
      \ii \texttt{dirty}: Muss der Wert noch in den Slot zurück geschrieben werden?
      \ei
    }\medskip
    \ii<2-> \textbf{Beispielbelegung} {
      \bi
      \ii[\structure{eax}] Nicht Herausgegeben; \btSetTab Nichts geladen
      \ii[\structure{ebx}] Herausgegeben; \btUseTab Variable a geladen; Synchronisiert mit Speicher
      \ii[\structure{ecx}] Nicht Herausgegeben; \btUseTab Variable b geladen; Rückschreiben erforderlich
      \ii[\structure{edx}] Herausgegeben; \btUseTab Variable c geladen; Synchronisiert mit Speicher

      \ei
    }
    \ei
  
  \end{frame}
#+end_src


#+begin_src latex

  \begin{frame}{\texttt{alloc\_register()}}
    \btAnimation[width=0.6\textwidth]{center, padding, 2:<1>, 3:<2-3>, range=4-7:<4->}{fig/10-allocator}

    \bi
    \ii \textbf{Vorbereitung}: Vor jeder Instruktion setzen wir \texttt{free} zurück{
      \bi
      \ii Jedes Register kann in jeder Instruktion verwendet werden
      \ii Herausgabe eines Registers erzeugt \structure{Kosten} für Spilling und Neuladen
      \ei
    }\medskip
    \ii<3-> \structure{Priorisierte Allokation} von Registern für die Befehlsauswahl {
      \bi
      \ii<4-> Leere Register erzeugen keine Folgekosten                     \hfill (Kosten: 0 \texttt{mov})
      \ii<5-> Wert-Neuladen für saubere, aber belegte Register    \hfill (Kosten: 1 \texttt{mov})\\
              Wissen um aktuellen Wert wird gelöscht \\[1ex]
      \ii<7-> Spilling und Wert-Neuladen für dreckige Register              \hfill (Kosten: 2 \texttt{mov})\\
              Der Allokator emitiert direkt einen Spill-Befehl für das Register
      \ei
    }
    \ei
  
  \end{frame}


  \begin{frame}[fragile]{\texttt{write(src\_reg, dst)}}
    \uncover<2->{\btAnimation[width=0.6\textwidth]{center, padding, 8:<1-2>, 9:<3>, 10:<4-5>,11:<6->}{fig/10-allocator}}
    \bi
    \ii Befehlsauswahl hat Befehle emitiert die \texttt{src\_reg} beschrieben haben{
      \bi
      \ii Registerinhalt soll in Zukunft als \texttt{dst}-Variable verfügbar sein
      \ii Verzögertes Rausschreiben der Variable in ihren Speicher-Slot
      \ei
    }\medskip
    \ii<2-> \textbf{Beispiel}: Zuweisung zwischen zwei Variablen \hfill \texttt{b := \ircmd{Assign} a}\\{
      \begin{columns}
        \begin{column}{0.49\textwidth}
          \begin{code}[]
            \begin{py}[style=highlighting]
              def emit_Assign(instr):
                 @3src = self.RA.load(instr.src)@
                 @4dst = self.RA.alloc_register()@
                 @5self.emit_instr("mov", src, dst)@
                 @6self.RA.write(src, instr.dst)@
            \end{py}
          \end{code}
        \end{column}\hfill
        \begin{column}{0.49\textwidth}
          \begin{code}[]\ttfamily
            \uncover<3->{mov -8(\%ebp), \%eax}\\
            \uncover<5->{mov \%eax, \%ebx}
          \end{code}
          \vspace{-1em}%
          \bi
          \ii<6-> \texttt{write()} setzt nur \texttt{value} und \texttt{dirty}\\[-1ex]
          \ii<6-> \codeinline[style=asm,style=smaller]{mov %ebx, -12(%ebx)} geschiet später
          \ei

        \end{column}
      \end{columns}

    }
    \ei
  \end{frame}

  \begin{frame}{\texttt{load(src)}}
    \btAnimation[width=0.6\textwidth]{center, padding, range=12-16:<1->, 16:<6->}{fig/10-allocator}
    \bi
    \ii Laden einer Variable in ein beliebiges Register {
      \bi
      \ii<2-> \structure{Basisfall}: Variable ist nicht geladen $\rightarrow$ \texttt{alloc\_register()} + Ladebefehl
      \ii<3-> Bereits geladen und sauber $\rightarrow$ Register allokiert markieren und herausgeben
      \ii<4-> Variable bereits geladen, aber dreckig{
        \bi
        \ii Der Aufrufer will die Variable nicht verändern \btSetTab $\rightarrow$ wie geladen und sauber
        \ii<5-> \texttt{load(src, modify=True)} \btUseTab $\rightarrow$ Register vorher spillen
        \ei
      }
      \ei
    }\medskip
    \ii<6-> Laden einer Variable in ein spezifisches Register{
      \bi
      \ii Manchmal brauchen wir etwas in einem spezifischen Register \hfill\texttt{ret/\%eax}
      \ii Bereits geladenen Wert mit \texttt{xchg} austauschen 
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{Besondere Situationen für den Allokator}
    \bi
    \ii \structure{Datenflüsse} die die Grenzen der Basisblöcke überschreiten{
      \bi
      \ii Basisblock-Übergreifende Registervergabe ist \alert{viel schwieriger}
      \ii Werte müssten in allen Vorgängern in den gleichen Registern sein\\[1ex]
      \ii[$\Rightarrow$] Wir starten jeden Basisblock mit einem leeren Zustand
      \ei
    }\medskip
    \ii<2-> \structure{Funktionsaufrufe} und \structure{Sprünge}{
      \bi
      \ii Funktionen/andere Basisblöcke könnten die Variablen aus dem Speicher lesen
      \ii Funktionen können Speicher verändern\\[1ex]
      \ii[$\Rightarrow$] Alle Register sichern und Zustand zurücksetzen
      \ei
    }\medskip
    \ii<3-> \structure{Speicheroperationen} haben wieder ein \textbf{Alias-Problem}{
      \bi
      \ii Wir wissen nicht ob der gelesene/geschriebene Zeiger auf eine Variable zeigt
      \ii \ircmd{Store} könnte Register-Werte invalidieren, \ircmd{Load} könnte alte Werte lesen\\[1ex]
      \ii[$\Rightarrow$] Wir sichern/invalidieren Register, die jemals referenzierte Variablen enthält.\\
          \hfill      \texttt{ptr := \ircmd{Reference} var}
      \ei
    }
    \ei
  
  \end{frame}

  \begin{frame}{Benchmark}
    \btAnimation{center,range=1-4:<1->}{fig/10-eval}

    \bi
    \ii Evaluation der beiden Allokatoren und Gegenüberstellung mit GCC{
      \bi
      \ii Benchmark: Iterativer Fibonacci,  \texttt{fib\_iter(100000000)}
      \ii Evaluationssystem: i7 6600 @ 2.60 Ghz, 32-Bit Modus
      \ii Test-Setup: \texttt{perf stat -r 10 ./a.out}
      \ei
    }
    \ii[$\Rightarrow$]<3-> PSÜ-Übersetzer mit Optimierungen ist Vergleichbar mit \texttt{gcc -O0}
    \ii[$\Rightarrow$]<4-> GCC kann natürlich noch viel besseren Code erzeugen
    \ei


  \end{frame}
#+end_src
* Programme und Prozesse
#+begin_src latex
  %%ONLY%%
  \dividerframe{Programme und Prozesse}

  \begin{frame}{Übersicht des restlichen Übersetzungsvorgang}
    \begin{btBlock}{}\small
      In den letzten 10 Vorlesungen haben wir gelernt aus Quellcode Assembler zu machen.
      Daraus muss noch ein \structure{Programm} erzeugt werden, dass als \structure{Prozess} gestartet und ausgeführt wird.
    \end{btBlock}

    \btAnimation[width=\textwidth]{range=1-4:<1->}{fig/10-linking-overview}


    \bi
    \ii<2-> Aber da ist noch mehr\ldots {
      \bi
      \ii \structure{Seperate Übersetzung} ermöglicht inkrementelles neuübersetzen
      \ii<3-> Der \structure{Loader} bringt die Binärdatei in den Speicher
      \ii<4-> \structure{Dynamische Bibliotheken} erlauben es Binärcode zu sharen
      \ei
    }
    \ei
  \end{frame}
#+end_src

