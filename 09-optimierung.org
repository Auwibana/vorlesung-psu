#+TITLE: Programmiersprachen und Übersetzer
#+SUBTITLE: 09 - Optimierung
#+SETUPFILE: setup.org
#+INCLUDE: export-prologue.org
#+PROPERTY: header-args:latex :tangle yes :noweb yes :tangle-macros yes :tangle-prologue topic :tangle-epilogue endtopic :exports none

#+NAME: topic
#+BEGIN_SRC latex :tangle no
\psuSectionStart{{{{property(ITEM)}}}}{{{{n(block)}}}}
#+END_SRC

#+NAME: endtopic
#+BEGIN_SRC latex :tangle no
\psuSectionStop{{{{property(ITEM)}}}}{{{{n(block,-)}}}}
#+END_SRC

* Gedanken zu dieser Vorlesung                                     :noexport:
- Was darf Optimierung machen?
- Block-Lokale Optimierungen
  - Konstantenfaltung
  - Konstanten- und Kopiepropagation
  - Alias-Problematik
- Optimierung des Kontrollflusses
  - Redundante Jumps entfernen
  - Blöcke verschmelzen
- Müll aufräumen
  - Dead-Code Elimination
  - Dead-Store Elimination

* Was leistet die "Optimierung"?
:PROPERTIES:
:CUSTOM_ID: 09-einleitung
:END:

#+begin_src latex
  \subtitle{{{{subtitle()}}}}
  \begin{frame}
    \maketitle
  \end{frame}

  \begin{frame}{Einordnung in die Vorlesung: Optimierung}
    \begin{center}
      \includegraphics[page=7,width=0.9\linewidth]{fig/01-overview-small}
    \end{center}
    \bi
    \ii \structure{Hadwareunabhängige Optimierung} auf dem Zwischencode {
      \bi
      \ii IR-Code wurde \alert{ohne Rücksicht} auf die effizienzte Ausführbarkeit erstellt.
      \ii \structure{Effektive Entwickler}: Welche Arbeiten kann er dem Optimierer überlassen.
      \ii \structure{Effiziente Entwickler}: Wie lege ich dem Optimierer keine Steine in den Weg.
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[t,fragile]{Motivation: Da geht noch was!}
    \vspace{-2em}
    \begin{columns}[t]

    
      \begin{onlyenv}<handout:1-2|1-2>
        \begin{column}{0.49\textwidth}
          \begin{code}[tag=L0]
          \lstinputlisting[style=lzero]{lst/09-example.l0}
        \end{code}
      
        Bei genauer Betrachtung, sehen wir, dass dieses Programm \ALERT{immer 0} zurück geben wird.

        \bigskip
        \uncover<handout:2|2>{Dafür wird echt viel gerechnet!}
      \end{column}

    \end{onlyenv}
    \begin{onlyenv}<handout:3-|3->
      \begin{column}{0.49\textwidth}
        \mbox{}\par\bigskip
        \enquote{Der Übersetzer schaut genau hin}
        \medskip
        \be
        \ii {Konstante Auswertung} {
          \\[0.5ex]\enquote{Bekanntes Vorrausberechnen}\\[0.5ex]
          \bi
          \ii<handout:4-|4-> Arithmetische Berechnungen
          \ii<handout:5-|5-> Konstante Sprungbedingungen
          \ei
        }
        \ii<handout:6-|6-> {Konstanten- und Kopiepropagation}
        \ii<handout:7-|7-> Goto-auf-Goto  eliminieren
        \ii<handout:8-|8-> {Dead-Code Elimination}
        \ii<handout:9-|9-> {Basic-Block Merge}\\[2ex]
        \ii<handout:10-|10-> \ldots repeat, until no change.
        \ee
      \end{column}
    \end{onlyenv}
    \begin{column}<handout:2-|2->{0.49\textwidth}\centering
      \only<handout:1-3|1-3>{\btAnimation[height=0.9\textheight,width=\textwidth,keepaspectratio]{raisebox,1:<1->}{fig/09-example-unoptimized}}%
        \btAnimation[height=0.9\textheight,width=\textwidth,keepaspectratio]{raisebox,1:<4>}{fig/09-example-cf1}%
        \btAnimation[height=0.9\textheight,width=\textwidth,keepaspectratio]{raisebox,1:<5>}{fig/09-example-cf2}%
        \btAnimation[height=0.9\textheight,width=\textwidth,keepaspectratio]{raisebox,1:<6>}{fig/09-example-cvp}%
        \btAnimation[height=0.9\textheight,width=\textwidth,keepaspectratio]{raisebox,1:<7>}{fig/09-example-jumps}%
        \btAnimation[height=0.9\textheight,width=\textwidth,keepaspectratio]{raisebox,1:<8>}{fig/09-example-dce}%
        \btAnimation[height=0.9\textheight,width=\textwidth,keepaspectratio]{raisebox,1:<9>}{fig/09-example-merge}%
        \btAnimation[width=0.5\textwidth]                                  {raisebox, 1:<10>}{fig/09-example-repeat}
      \end{column}
    \end{columns}
  \end{frame}
#+end_src

In der letzten Vorlesung haben wir den abstrakten Sytntaxbaum zu einem IR-Programm übersetzt.
Dabei haben wir den AST linearisiert und uns auf eine Ausführungsreihenfolge von Befehlen fest gelegt.
Bei diesem Prozess der Codeerzeugung haben wir darauf verzichtet super performanten und effizienten Zwischencode zu erzeugen, der, beispielweise, minimal viele virtuelle Register verwendet.
Ich habe ganz absichtlich eine Trennung der Belange von Codeerzeugung und Optimierung vorgenommen um die Prinzipien des einen Bereichs nicht mit Prinzipien des anderen Bereichs zu vermengen.
In dieser Vorlesung wollen wir einen kurzen Blick auf den Bereich der Optimierung werfen.

Dazu will ich als erstes den Umfang den wir hier, aufgrund der Kürze der Zeit, gleich einmal einschränken:
Ganz generell ist die Optimierung von Programmen ein breites und altes Feld.
Optimierungen können im Übersetzer in jedem Zwischenschritt durchgeführt werden.
Der Übersetzer kann bereits beim Parsen Ausdrücke die ein konstantes Ergebnis liefern (~2+3~) durch das Ergebnis (~5~) ersetzen[fn::GCC tut dies, Clang nicht. Daher ist Clang leichter für Source-to-Source Transformationen anwendbar.]. Aber auch der Zwischencode oder der bereits erstelle Assembler können optimiert werden. 
So breit können wir dieses Thema einfach nicht besprechen und ich werde mich daher auf einige relativ einfache Optimierungen auf der IR-Ebene konzentrieren. 
Jedoch werden Sie dennoch einen Eindruck und, hoffentlich, eine gewisse Intuition bekommen, welche Fähigkeiten ein Übersetzer haben *kann* und wie Sie, als Entwickler, diesen Mechanismen möglichst wenig im Weg stehen.

Als einleitendes Beispiel sehen Sie auf den Folien eine Funktion, die auf sehr komplizierte Art und Weise die Zahl 0 berechnet.
Immer.
Die gezeigte ~main()~-Funktion wird immer damit Enden, dass die Variable ~a~ den Wert 0 hat.
Prüfen Sie es nach, verfolgen Sie den Kontrollfluss, es wird immer 0 dabei heraus kommen.
Wenn wir uns aber den Kontrollflussgraphen anschauen, den die Codeerzeugung produziert hat, so spiegelt sich darin genau die Struktur wieder, die der Entwickler notiert hat.

Geben wir dieses IR-Programm an den Optimierer, so wendet dieser eine Reihe von Optimierungsroutinen an, die zum Ziel haben die Anzahl der ausgeführten IR-Befehle zu verringern.
Jede der im Beispiel aufgeführten Routinen, werden wir in dieser Vorlesung besprechen und Sie finden im Übersetzer der Übung eine beispielhafte Implementierung.
Daher können Sie sich an dieser Stelle zurück lehnen und das Schauspiel genießen, wie Instruktionen sich verändern und verschwinden, und wie Blöcke und Kanten verschoben, verschmolzen und weggeräumt werden.
Wie wunderschön:
Eine Programm, das ein Programm verkürzt, ganz ohne menschliches Zutun und ohne dabei seine Semantik zu verändern.
Die Kontrollflussgraphen auf den Folien sind im übrigen Echt und stammen aus dem Übungsübersetzer.

* Voraussetzungen und Ziele
:PROPERTIES:
:CUSTOM_ID: 09-goals-and-means
:END:

#+begin_src latex
  \dividerframe{Ziele und Vorraussetzungen\\der Optimierung}

  \begin{frame}{Ziele bei IR-Level Optimierung}
    \begin{btBlock}[type=example]{Allgemeine Optimierungsziele}
      Ziel jeder Programm-Optimierung ist es, die \textbf{nicht-funktionalen} Eigenschaften, unter Beibehaltung der \textbf{erwarteten Funktionalität}, zu verbessern.
    \end{btBlock}

    \bi
    \ii Nicht-Funktionale Eigenschaften nach denen wir optimieren {
      \bi
      \ii \structure{Ausführungszeit}: Abbildung auf weniger oder schnellere Instruktionen
      \ii \structure{Programmgröße}: Veringerung der Binärgröße (eingebettete Systeme)
      \ii \structure{Energieverbrauch}: Verlängerung der Batterielaufzeit
      \ei
    }\medskip
    \ii<2-> Auf der Hardware-unabhängigen IR-Ebene fehlt das \alert{Kostenmodell}{
      \bi
      \ii Wir wissen nicht wie schnell, groß, oder Energie-hungrig einzelne Instruktionen auf der Zielplattform sein werden.
      \ii \structure{Heuristik}: \enquote{Speicherzugriffe und Sprünge sind teuer.}
      \medskip
      \ii<3->[$\Rightarrow$] Generelle Reduktion der Anzahl der Instruktionen und Basisblöcke
      \ei
    }
    \ei
  
  \end{frame}
#+end_src

Bevor wir zu einzelnen Optimierungsroutinen kommen, müssen wir genauer definieren, was die Ziele und Mittel sind, die ein Optimierer hat und die er einsetzen darf.
Das Ziel muss klar sein, genauso wie die Werkzeuge die angewendet und die nicht angewendet werden dürfen.

Unser Startpunkt bei dieser Überlegung ist, wie immer im Übersetzerbau, der Entwickler und seine *Intention*. Verändern wir das Programm so, dass es nicht mehr dieser Intention entspricht, werden wir kein großes Glück in die Welt bringen. Die Art und Weise, wie diese Intention notiert wurde, ist der Programmtext der nach den semantischen Regeln der Sprache zu Papier (oder eher zu Datei) gebracht wurde. Der Entwickler bedient der Regeln der Sprache und formuliert sein Programm entlang der Garantien, welche die Sprache bietet. 

Eine Verletzung einer solche Regel würde Sie wirklich unglücklich machen. Ein Beispiel hierzu: Jede Programmiersprache verspricht, dass Sie jenen Wert aus einer Variable wieder auslesen können, den Sie bei der letzten Zuweisung hinein geschrieben haben. Würde beim wieder auslesen ein anderer Wert herauskommen, wären Sie *maximal überrascht*[fn::Das Prinzip der *minimalen Überraschung* ist ein wichtiges Prinzip in der Informatik. Da in den abstrakt konstruierten Gedankengebäuden alles möglich ist, jedes Verhalten codierbar ist, ist es wichtig sich diesem Prinzip unterzuordnen. Überraschen Sie weder ihr zukünftiges Ich noch andere!]. Etwas formaler ausgedrückt würden wir sagen, dass ein Optimierer das Programm nur so verändern darf, dass seine erwartete Funktionalität, die von den Sprachregeln, hoch und heilig, versprochen wurden, unberührt bleiben. 

Aber wozu das alles?
Was bedeutet es ein Programm "besser" zu machen?
Um dies zu verstehen müssen wir uns die *nicht-funktionalen Eigenschaften* des Programms anschauen.
Nicht-funktional bedeutet, dass diese Eigenschaften nicht Teil des Zweckes des Programm sind.
Selbst wenn die nicht-funktionalen Eigenschaften sehr sehr schlecht sind, könnten wir es benutzen um einen gewissen Zweck zu verfolgen.
Jedoch würde es vielleicht sehr lange dauern[fn::Hundertausend Jahre], viel Energie benötigen[fn::Mehrere Sonnen], oder viel Speicherplatz belegen[fn::Aller jemals hergestellte RAM].

Da ein Programm eine Vielzahl an nicht-funktionalen Eigenschaften hat, gibt es auch eine Vielzahl an unterschiedlichen *Optimierierungszielen*.
Sie könnten sich vom Übersetzer wünschen, dass er das Programm dahingehend transformiert, dass es möglichst schnell ist (Ausführungszeit).
Sie könnten aber auch ein möglichst kleines Programm haben wollen, was gerade noch in ihren Mikrocontroller passt (Programmgröße).
Manche dieser Optimierungziele gehen Hand in Hand und weisen eine Korrelation auf.
So ist Energieverbrauch und Ausführungszeit häufig (aber nicht immer!) stark miteinander korreliert. Manchmal ist diese Korrelation aber auch invers, wie dies bei Programmgröße und Ausführungszeit der Fall sein kann.
Daher ist es wichtig sich *vorher* zu überlegen, was die Eigenschaft ist die man optimieren will.

Um bei dieser Verbesserung wirklich eine Verbesserung und keine Verschlimmbesserung durchzuführen benötigt man eine Idee davon welche statische Änderung am Programmtext welche dynamische Änderungen zur Laufzeit bewirkt:
"Sollte ich jene Instruktion durch diese andere Instruktion ersetzen um das Programm schneller zu machen, oder benötigt die neue Instruktion mehr Takte?"
Um solche Fragen beantworten zu können braucht man eigentlich ein detailiertes *Kostenmodell* für die konkrete Zielplattform.
Allerdings gibt es häufig ein solches Modell für den einen Prozessor, der in einer gewissen Generation aus einer bestimmten Herstellungscharge kommt, nicht.
Daher greifen Übersetzer normalerweise auf gröbere Heuristiken zurück um Optimierungsentscheidungen zu treffen.
Beispielsweise sind solche Heursitiken, dass Speicherzugriffe zu vermeiden sind und das Sprünge negative Auswirkungen auf das Pipelining haben.

Für unser Vorhaben, das Optimieren auf IR-Ebene, gibt es noch ein weiteres Problem.
Denn wir wissen bei IR-Optimierungen ja garnicht für welche Prozessorarchitektur das Progamm am Ende zu Assembler übersetzt wird.
Wir müssen also noch allgemeiner das Programm "besser" machen.
Daher werden wir versuchen ganz generell das Programm kleiner zu machen (weniger Instruktionen, weniger Basisblöcke) und Instruktionen zu vermeiden die in jedem Fall teurer in der Ausführung sind (weniger Sprünge).

#+begin_src latex
\begin{frame}{Wiederholung (1. Vorlesung): Korrekte Übersetzung}
    \bi
    \ii Die Programmiersprache definiert die \alert{beobachtbaren} Zustände. {
      \bi
      \ii Ein- und Ausgabe ist immer beobachtbar, oft aber auch Teile des Speichers
      \ii Bei C: Nur das Schreiben von globalen Variablen, nicht aber von lokalen.
      \ei
    }\bigskip
    \ii Ein \advantage{korrekter} Übersetzer erhält alle beobachtbaren Zustände.{
      \bi
      \ii Parsing+Code-Erzeugung ist eine \textbf{Abbildungsfunktion}:\\[2ex]{
        \includegraphics[page=2,width=0.9\textwidth]{fig/01-zustand}
      }
      \ei
    }\bigskip
    \ii[$\Rightarrow$] Funktionen \advantage{dürfen verändert werden}, solange sie außen gleich aussehen {
      \bi
      \ii Im IR-Code: lokalen und temporären Variablen sind nicht sichtbar
      \ii Von Außen sichtbar sind: \ircmd{Store}, \ircmd{Call}, \ircmd{Return}
      \ei
    }
    \ei
  \end{frame}
#+end_src  

In der erstem Vorlesung habe ich bereits darüber gesprochen, das eine korrekte Übersetzung die *beobachtbaren Zustände* eines Programms nicht verändern darf. Diese beobachtbaren Zustände sind genau jenes, vom Entwickler, erwartete Verhalten. Wie das Programm diese beobachtbaren Zustände generiert ist aber im Grunde egal.

Für unser Vorhaben, die Optimierung auf IR-Ebene, gibt es erstmal nur zwei Dinge die für ein Programm beobachtbar sind, weil sie Daten aus dem Programm an die Außenwelt transportieren können: Der Rückgabewert der ~main()~-Funktion und schreibende Speicherzugriffe.
Lassen wir es zusätzlich zu, dass unser Programm Ausgabe machen kann (indem es einen Systemaufruf absetzt), so wären auch diese beobachtbar.

Diese minimale Definition von beobachtbar (Rückgabewert, Schreibzugriffe, Systemaufrufe) ist allerdings nur dann von nutzen, wenn wir das gesamte Programm (== alle Funktionen) auf einmal optimieren.
Allerdings ist eine so weitreichende Optimierung meist viel zu umfassend um handhabbar zu sein, weswegen wir die Optimierung einzelner Funktionen in Isolation anstreben.
In diesem Fall müssen wir die beobachtbaren Zustände strenger definieren:
Betrachten wir das Verhalten einer einzelnen Funktion, so können wir (von Außen), den Rückgabewert der Funktion (~Return~), die getätigten Schreibzugriffe (~Store~), und der Aufruf weiterer Funktionen (~Call~) beobachten.

Würden wir zwei Kontrollflüsse, einmal vom optimierten Programm und einmal vom Unoptimierten, aufzeichnen und nach diesen drei IR-Befehlen filtern, so müssten beide Sequenzen exakt gleich sein. Es dürften keine Umsortierungen stattgefunden haben und die  Operanden müssten genau übereinstimmen.

#+begin_src latex
  \begin{frame}{Phasen und Umfang der Optimierung}
    \begin{center}
      \includegraphics{fig/09-analyse}
    \end{center}
    \bi
    \ii Optimierung besteht immer aus \textbf{zwei Schritten} {
      \bi
      \ii \structure{Analyse} des Programms generiert Wissen anhand dessen wir entscheiden können, ob wie \alert{eine Optimierung anwenden dürfen}.
      \ii \structure{Transformation} in ein semantisch äquivalentes, aber \enquote{besseres} Programm.
      \ei
    }\medskip
    \ii Optimierungen analysieren und transformieren \textbf{Programmausschnitte} {
      \bi
      \ii Wie groß ist der Ausschnitt über den wir wissen extrahieren?
      \ii Instruktionen, einzelne Basisblöcke, eine ganze Funktion, eine Aufrufhierarchie, mehrere interagierende Threads
      \ei
    }
    \ei
  \end{frame}
#+end_src

Im Allgemeinen zerfallen alle Optimierungenroutinen in zwei Schritte:
Bei der *Analyse* finden der Übersetzer berechnet der Übersetzer alle, für diese Optimierung relevanten, Informationen aus dem Programm.
Aufgrund dieser Wissensbasis wird dann entschieden ob die intendierte Optimierung auf den vorliegende Programmabschnitt überhaupt anwendbar ist, oder ob eine Optimierung das beobachtbare Verhalten verändern würde.
Ist die Entscheidung getroffen, dass optimiert werden soll, geht es zur *Transformation* des Programms. Dabei wird das IR-Programm, unter zur Hilfenahme der extrahierten Informationen, modifiziert.

Auf den Folien kann man beide Phasen deutlich getrennt voneinander sehen:
Wir schieben zwei einzelne Instruktionen in die Analyse, in der wir sehen, dass das ~IfGoto~ immer dasselbe tut und zu L0 springen wird (die Bedingung ist immer wahr).
Für das ~Add~ können keinen solchen Fakt generieren.
Aufgrund dieses Wissens tauscht die Transformation das ~IfGoto~ durch ein entsprechendes ~Goto~ aus, lässt aber das ~Add~ völlig unverändert.
Von den beobachtbaren Zuständen kann sich das Programm nicht geändert haben.

Wie groß die Abschnitte sind die wir analysieren bzw. transformieren hängt von der Optimierung ab.
Für manche Optimierungen genügt es auf eine einzelne Instruktion zu blicken und genau diese Instruktion zu modifizieren.
Für andere Optimierungen müssen wir die ganze Funktion analysieren um herauszufinden, dass wir einzelne Instruktionen verändern dürfen. Aber Transformationen können auch Basisblöcke und Kontrollflusskanten verändern.

* Optimierungen
** Instruktions- und Block-lokale Optimierungen
#+begin_src latex
\dividerframe{Lokale Optimierungen}

  \begin{frame}{Algebraische Identitäten}
    \OrangeBox{Ersetzung von Instruktionen durch algebraisch-äquivalente Instruktionen}

    \bi
    \ii<1-> \structure{Konstantenfaltung} ist eine Instruktions-lokale Optimierung\\[1ex]{
      \hfill\fbox{\texttt{a := \ircmd{Add} 1, 2}}\hfill$\Rightarrow$\hfill\fbox{\texttt{a := Assign 3}}\hfill\mbox{}\\[1ex]
      \bi
      \ii \textbf{Ziel}: Ersetzung von Instruktionen mit ausschließlich konstanten Operanden
      \ii Sprach-Semantik muss erhalten (32-Bit Programm vs. 64-Bit Übersetzer)
      \ei
    }\medskip
    \ii<2-> \structure{Strength-Reduction} veringert die Ausdruckstärke einer Instruktion\\[1ex]{
      \hfill\fbox{\texttt{a := \ircmd{Mul} x, 2}}\hfill$\Rightarrow$\hfill\fbox{\texttt{a := Add x, x}}\hfill\mbox{}\\[1ex]
      \bi
      \ii Arithmetische Operationen haben unterschiedliche theoretische Komplexitäten
      \ii Multiplikation: $\mathcal{O}(n\cdot\log(n)\cdot\log(\log(n)))$ (FFT) vs. Addition: $\mathcal{O}(n)$
      \ii Ausdrucksstärke: Potenzierung $\gg$ Multiplikation $\gg$ Addition $\gg$ Bit-Shift
      \ei
    }\medskip
    \ii<3-> \structure{Technische Umsetzung}: Wende Ersetzungsregeln auf jede Instruktion an{
      \bi
      \ii \structure{Ersetzungsmuster} gibt Bedingungen vor, die Operanden erfüllen müssen
      \ii Ersetze die Instruktion im umgebenden Basisblock
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[fragile]{Algebraische Identitäten: Beispielhafte Ersetzugsmustern}
    \def\Var#1{\colorbox{safegreen!40}{#1}}
    \def\Const#1{\colorbox{badbee!40}{#1}}
    \def\Label#1{\colorbox{luhblue!40}{#1}}

    \centering
    \OrangeBox{Variablen: \Var{A}, Konstanten: \Const{x}, Labels: \Label{L}}\\[1ex]

    { \ttfamily
      \begin{tabular}{l|c|l}\toprule
        Orginal                                        & Bedingungen      & Ersetzung                              \\\midrule
        \multicolumn{3}{l}{\structure{Null-Operationen}}                                             \\
        \hspace{2em}\Var{A} := \ircmd{Add} \Var{B}, \Const{0}   & --               & \Var{A} := \ircmd{Assign} \Var{B}  \\
        \hspace{2em}\Var{A} := \ircmd{Mul} \Var{B}, \Const{1}   & --               & \Var{A} := \ircmd{Assign} \Var{B}  \\
        \hspace{2em}\Var{A} := \ircmd{Sub} \Var{B}, \Var{B}     & --               & \Var{A} := \ircmd{Assign} \Const{0}  \\\midrule
        \multicolumn{3}{l}{\structure{Konstantenfaltung}}                                             \\
        \hspace{2em}\Var{A} := \ircmd{Add} \Const{b}, \Const{c}    & --               & \Var{A} := \ircmd{Assign} \Const{b+c}  \\
        \hspace{2em}\ircmd{IfGoto} \Const{x}, \Label{A}, \Label{B} & \Const{x}!=0     & \ircmd{Goto} \Label{A}                 \\
        \hspace{2em}\ircmd{IfGoto} \Const{x}, \Label{A}, \Label{B} & \Const{x}==0     & \ircmd{Goto} \Label{B}                 \\\midrule
        \multicolumn{3}{l}{\structure{Strength-Reduction}}                                            \\
        \hspace{2em}\Var{A} := \ircmd{Pow} \Var{B}, \Const{2}      & --               & \Var{A} := Mul \Var{B}, \Var{B}        \\
        \hspace{2em}\Var{A} := \ircmd{Mul} \Var{B}, \Const{n}      & \Const{n}==$2^x$ & \Var{A} := LShift \Var{B}, \Const{x} \\
        \bottomrule
      \end{tabular}
    }
  \end{frame}
#+end_src

#+begin_src latex
  \begin{frame}{Konstanten- und Kopiepropagation}
    \begin{columns}
      \begin{column}{0.35\textwidth}
        \btAnimation[width=\textwidth]{range=1-3:<1->,3:<4->}{fig/09-cvp}
      \end{column}\hfill
      \begin{column}{0.60\textwidth}
        \begin{btBlock}{}\small
          Durch die einfache Codeerzeugung und bei der Optimierung enstehen konstante oder redundante Zuweisungen.
        \end{btBlock}
      \end{column}
    \end{columns}
    \medskip

    \bi
    \ii<3-> Propagation bekannter Werte durch einen Basisblock {
      \bi
      \ii Zum Zeitpunkt einer Zuweisung werden rechte und linke Seite äquivalent.
      \ii Operanden-Ersetzung in den folgenden Instruktionen
      \ii \ALERT{Aber}: Wir dürfen nur solange ersetzen, wie die Äquivalenz sicher ist.
      \ei
    }\medskip
    \ii<4-> \structure{Intuition} für die Propagation von Konstanten und Werten {
      \bi
      \ii Iteration über die Instruktionen eines BBs, Mitführen von Äquivalenzmengen
      \ii Zuweisungen etablieren eine neue Äquivalenz zwischen LHS und RHS
      \ii Andere Schreibzugriffe, die eine Variable verändern, löschen Äquivalenzen
      \ii Bei Lesezugriffen, wird die Äquivalenzliste befragt und ggf. ersetzt.
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{Vorgehen für Wertpropagation}
    \btAnimation[width=0.75\textwidth]{center,range=4-11:<1->}{fig/09-cvp}

    \bi
    \ii \structure{Äquivalenzmengen} werden \enquote{durchgeschoben}, modifiziert und befragt {
      \be
      \ii<2-|handout:2-> Zu Beginn des Blocks ist nichts zu nichts anderem äquivalent
      \ii<3-|handout:3-> Bei Zuweisungen werden linke und rechte Seite äquivalent
      \ii<4-|handout:4-> Quelloperanden werden durch \advantage{äquivalente Konstanten oder Variablen} ersetzt
      \ii<4-|handout:4-> Äquivalenzmengen können mehr als 2 Elemente haben
      \ii<5-|handout:5-> Nicht-\ircmd{Assign} Schreiboperationen entfernen Elemente aus ihrer Menge
      \ee
    }
    \ei

    \OrangeBox<8>{Kann die Funktion f, die Variable x, y, oder t0 verändern?}
  \end{frame}

  \begin{frame}{Alias-Problematik bei der Datenflussanalyse}

    \begin{center}
      \includegraphics[page=12]{fig/09-cvp}
    \end{center}


    \bi
    \ii Das Problem sind Zeiger, die unsere IR-Variablen \alert{verändern könnten} {
      \bi
      \ii Wenn \texttt{ptr} auf \texttt{y} zeigt, kann sich \texttt{y} ändern, ohne explizit Operand zu sein
      \ii Im Funktions-lokalen Scope, wissen wir nicht was \texttt{func()} mit \texttt{ptr} macht.
      \ii Die \ircmd{Store}-Instruktion könnte \texttt{y} auf 3 setzen
      \ei
    }\medskip
    \ii<2-> Dies ist das \structure{Alias-Problem} für Zeiger {
      \bi
      \ii Wir müssten genau wissen auf welche Objekte ein Zeiger verweisen kann
      \ii Dies erfordert aufwendige, teils inter-prozedurale, Analysen.
      \ii Beim geringste Zweifel über die Alias-Relation, \textbf{wirft der Optimierer hin}
      \ei
    }\medskip
    \ii<3-> Einfache Heursitik für die unsere Wertepropagation {
      \bi
      \ii Bei jedem \ircmd{Store} und bei jedem \ircmd{Call} werfen wir die Äquivalenzmengen weg. Better safe, than sorry.
      \ei
    }
    \ei
    \begin{overlaybox}<4>[draw=srared,ultra thick,drop shadow,inner sep=1em]
      \columntitle{Take-Away für den effizienten Programmierer}\medskip

      \bii
      \ii Wildes Zeiger-rum-gefuchtel macht dem Übersetzer das Leben schwer.
      \ii Variablen sind umsonst, Wertepropagation eliminiert Zuweisungen.\\[1ex]
      \ii[$\Rightarrow$] Programmieren Sie \advantage{\textbf{verständlich}}, nicht \enquote{\ALERT{optimiert}}!
      \eii
    \end{overlaybox}
  \end{frame}
#+end_src

** Funktionsweite Optimierungen
#+begin_src latex
  \dividerframe{Funktionsweite Optimierungen}

  \begin{frame}{Wertepropagation über Basisblockgrenzen}
    \textbf{Bisher}: Wertepropagation (CVP) innerhalb eines Basisblocks.

    \begin{center}
      \strut\alt<1>{
        \siginline{CVP}{BasicBlock}{()}
      }{
        \siginline{CVP}{BasicBlock, Equivalences}{Equivalences}
      }
    \end{center}

    \bi
    \ii Wertepropagation ist eine \structure{Datenflussanalyse}{
      \bi
      \ii Wir verfolgen wie Datenwerte entlang des Kontrollflusses \enquote{fließen}
      \ii In einem Basisblock ist der Kontrollfluss determiniert linear
      \ii Die CVP propagiert eine Äquivalenzmenge durch einen Block
      \ei
    }\medskip
    \ii<2-> Wir wollen die CVP auf eine ganze Funktion anweden {
      \bi
      \ii Blöcke werden zu Transformator-Funktionen für Äquivalenzmengen
      \ii Äquivalenzmengen \enquote{fließen} entlang der Kontrollflusskanten
      \ii Fixpunkt-Iteration bis keine Änderungen mehr auftreten
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{Fixpunktiteration auf einem CFG}

    \begin{columns}
      \begin{column}{0.49\textwidth}
        \btAnimation[width=\textwidth]{range=1-4:<1->, 4:<5->}{fig/09-fixpoint}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \begin{btBlock}{}
          \textbf{Problem}: Wie wenden wir eine Block-lokale Datenflussanalyse (z.B. CVP) auf eine ganze Funktion an?
        \end{btBlock}

        \medskip

        \columntitle{Elemente}
        \bii
        \ii<2-> Transformation-Funktion: \texttt{T()}
        \ii<3-> Propagierte Zustände: $d_n$
        \ii<4-> Zustands-Merge-Funktion: \texttt{M()}
        \eii

        \uncover<5->{
          \medskip
          \columntitle{Vorgehen}
          \bii
          \ii Initialisiere Zustände $d_n$
          \ii Iterierte Auswertung von \texttt{M(), T()}
          \ii Updaten der Block-Zustände
          \ii Stop, wenn Fixpunkt erreicht ist
          \eii
        }
      \end{column}
    \end{columns}
  \end{frame}

  \begin{frame}{Fixpunktiteration als Worklist-Algorithmus}
    \begin{code}[tag=Python]
      \lstinputlisting[style=py,style=smaller,linerange=s0-e0]{lst/09-fixpoint.py}
      \uncover<2->{\lstinputlisting[style=py,style=smaller,linerange=s1-e1]{lst/09-fixpoint.py}}
      \uncover<3->{\lstinputlisting[style=py,style=smaller,linerange=s2-e2]{lst/09-fixpoint.py}}
      \uncover<4->{\lstinputlisting[style=py,style=smaller,linerange=s3-e3]{lst/09-fixpoint.py}}
      \uncover<5->{\lstinputlisting[style=py,style=smaller,linerange=s4-e4]{lst/09-fixpoint.py}}
      \uncover<6->{\lstinputlisting[style=py,style=smaller,linerange=s5-e5]{lst/09-fixpoint.py}}
    \end{code}
  \end{frame}

  \begin{frame}[t]{Fixpunkiteration als Datenflussanalyse}
    \bi
    \ii \structure{Vorraussetzungen} für die Terminierung des Worklist-Algorithmus{
      \bi
      \ii Init+Merge+Transform muss Knotenzustände \alert{strikt monoton} ändern
      \ii Beliebte Datenstrukturen für die Zustand: Bitvektoren, Mengen
      \ii Beispiel für eine strikt-monotone : {
        \bi
        \ii \texttt{init()}: \hspace{2cm}\btSetTab Generiere eine leere Menge
        \ii \texttt{merge()}: \btUseTab Vereinige alle Eingabemengen
        \ii \texttt{transform()}: \btUseTab Füge der Menge nur Elemente hinzu
        \ei
      }
      \ei
    }\medskip
    \ii Verschiedene Geschmacksrichtungen {
      \bi
      \ii \structure{Vorwärts-Analyse}: Zustände werden in Richtung der CFG-Kanten propagiert
      \ii \structure{Rückwärts-Analyse}: Zustände werden entgegen der CFG-Kanten propagiert
      \ei
    }\medskip
    \ii \structure{Wertepropagation} als Fixpunktanalyse {
      \bi
      \ii Initialisierung mit leeren Äquivalenzmengen
      \ii Transformation wie gehabt mit \texttt{CVP(BasicBlock, Equivalences)}
      \ii Merge: \btSetTab Zwei Werte sind genau dann äquivalent,\\\btUseTab Wenn sie in allen Eingabemenge äquivalent sind.
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[fragile,t]{Beispiel für Wertepropagation}
    \vspace{-2em}
    \begin{columns}[t]
      \begin{column}{0.55\textwidth}
        \btAnimation[width=\textwidth]{raisebox,range=1-8:<1->}{fig/09-fixpoint-cvp}      
      \end{column}\hfill
      \begin{column}{0.44\textwidth}\mbox{}\\[3ex]
        \columntitle{Worklist}
        \centering
          \texttt{[%
            \only<2>{BB0, BB1, BB3, BB2}%
            \only<3>{BB1, BB3, BB2}%
            \only<4>{BB3, BB2}%
            \only<5>{BB2}%
            \only<6>{BB3}%
            \only<7>{BB0}%
            ]}\\[3ex]

        \columntitle{Merge Logbuch}
        \def\L{\texttt\small}\small
        \def\E{$\emptyset$}
        \only<5->{\colorbox{badbee!20}{\medskip
        \begin{tabular}{lr}
          BB1 & \L{[\{a, c, 2\}, \{b, x, 3\}]}  \\
          BB2 & \L{\E}                          \\\midrule
          BB3 &\L{\E}                         
        \end{tabular}
      }}
      \mbox{}\bigskip\mbox{}
      \only<7->{\colorbox{badbee!20}{\medskip
        \begin{tabular}{lr}
          BB1 & \L{[\{a, c, 2\}, \{b, x, 3\}]}  \\
          BB2 & \L{[\{a, 2\}, \{b, x, 4\}]}     \\\midrule
          BB3 &\L{[\{a, 2\}, \{b, x\}]}         \\
        \end{tabular}
        }
      \bigskip\mbox{}
      Der Merge-Code ist fummelig.
    }
      \end{column}
    \end{columns}

  \end{frame}
#+end_src

** Optimierung des Kontrollflusses
#+begin_src latex

  \dividerframe{Optimierung des Kontrollflusses}

  \begin{frame}{Verschmelzen von konsekutiven Basisblöcken}
    \begin{columns}
      \begin{column}{0.4\textwidth}
        \btAnimation[width=\textwidth]{range=1-2:<1->,3:<3->}{fig/09-block-merge}
      \end{column}\hfill
      \begin{column}{0.6\textwidth}
        \bii
        \ii \textbf{Problem}: Sprung zu BB1 ist überflüssig.{
          \bi
          \ii BB0 hat genau einen Nachfolger
          \ii BB1 hat genau einen Vorgänger
          \ii[$\Rightarrow$] Verschmelze beide BB0 und BB1
          \ei
        }\medskip
        \ii<2-> \textbf{Analyse}: Finde Block-Paar (x, y), sodass...{
          \bi
          \ii y ist Nachfolger von x
          \ii x hat genau einen Nachfolger
          \ii y hat genau einen Vorgänger
          \ei
        }
        \ii<3-> \textbf{Transformation}: Verschmelze $x\rightarrow y${
          \bi
          \ii Lösche \ircmd{Goto} aus x
          \ii Hänge Instruktionen von y an x
          \ii Block y wird später gelöscht
          \ei
        }
        \eii
        \begin{btBlock}<4->[type=info]{Trennung der Belange}\small
          Das Aufräumen des toten Blocks (BB1) übernimmt eine andere Optimierung.
        \end{btBlock}
      \end{column}
    \end{columns}

  \end{frame}

  \begin{frame}{Elimination von unbedingten Doppelsprüngen}

      \begin{columns}
      \begin{column}{0.4\textwidth}
        \btAnimation[width=\textwidth]{1:<1-2>, 2:<3>, 3:<4->}{fig/09-redundant-jump}
      \end{column}\hfill
      \begin{column}{0.6\textwidth}
        \bii
        \ii \textbf{Problem}: BB2 ist überflüssig{
          \bi
          \ii BB2 enthält \textbf{nur} ein \ircmd{Goto}
          \ii Jeder Sprung zu BB2 ist ein Sprung zu BB3
          \ii[$\Rightarrow$] \textbf{Ziel}: Vermeide reundante Sprünge
          \ei
        }\medskip
        \ii<2-> \textbf{Hinweis}: Verschmelzen hier unmöglich {
          \bi
          \ii BB3 hat mehrere Vorgänger
          \ii Verschmelzen würde BB Bedingung verletzen
          \ei
        }\medskip
        \ii<3-> \textbf{Analyse}: Finde Block x sodass\ldots{
          \bi
          \ii x nur ein \ircmd{Goto} enthält
          \ii x hat y als einzigen Nachfolger
          \ei
        }\medskip
        \ii<4-> \textbf{Transformation}:{
          \bi
          \ii Besuche alle Vorgänger von x
          \ii Ersetze jedes x.label durch y.label
          \ii Block x wird später gelöscht
          \ei
        }
        \eii
      \end{column}
    \end{columns}

  
  \end{frame}

#+end_src

#+begin_src latex
  \dividerframe{Aufräumen}

  \begin{frame}{Elimination von toten Basisblöcken}
    \begin{columns}
      \begin{column}{0.4\textwidth}
        \btAnimation[width=0.75\textwidth]{center,padding=1em,range=4-6:<1->}{fig/09-block-merge}
        \btAnimation[width=0.75\textwidth]{center,padding=1em,range=4-6:<1->}{fig/09-redundant-jump}
      \end{column}\hfill
      \begin{column}{0.58\textwidth}
        \bii
        \ii \textbf{Problem}: Optimierungen hinterlassen Müll{
          \bi
          \ii Aufräumen von totem Code zentralisieren
          \ii Blöcke die nie angesprungen werden
          \ei
        }\medskip
        \ii<2-> \textbf{Analyse}: Finde tote Blöcke{
          \bi
          \ii Blöcke ohne Vorgänger
          \ii Keine Label-Adresse im Umlauf
          \ei
        }\medskip
        \ii<2-> \textbf{Transformation}: Lösche Block {
          \bi
          \ii Entfernung aller ausgehenden Kanten
          \ii Block bei umgebender Funktion entfernen
          \ei
        }
        \eii
      \end{column}
    \end{columns}

  \end{frame}
  #+end_src

** Elimination toter Instruktionen
#+begin_src latex
  \begin{frame}[t]{Elimination von toten Variablen}
    \begin{center}
      \vspace{-2em}
      \btAnimation[width=0.5\textwidth]{range=1-9:<1->}{fig/09-dve}  
    \end{center}

    \bi
    \ii \textbf{Problem}: Vorangegangene Optimierungen machen Variablen überflüssig{%
      \bi
      \ii \structure{Konstantenfaltung} ersetzt Operationen durch ihr konstantes Ergebnis
      \ii Durch \structure{Wertepropagation} werden äquivalente Quelloperanden vereinigt
      \ei
    }
    \ii<8-> \textbf{Analyse}: Finde alle lokalen Variablen, die \advantage{nie gelesen werden}{
      \bi
      \ii \alert{Vorsicht}: Zeiger können Variablen indirekt lesen (Alias-Problem)
      \ii \advantage{Heuristik}: Markiere alle Variablen deren Addresse berechnet wird als \enquote{gelesen}
      \ei
    }
    \ii<9-> \textbf{Transformation}: Entferne niemals gelesene lokale Variable x {
      \bi
      \ii Lösche Instruktionen, die x schreiben und kein \ircmd{Call} sind (Seiteneffekte!)
      \ii Lösche x aus der umgebenden Funktion
      \ei
    }
    \ei
  
  \end{frame}

#+end_src

* Optimierung im größeren Zusammenhang

#+begin_src latex
  \dividerframe{Optimierungen\\im\\Kontext}
  \begin{frame}[fragile]{Optimieren einer Funktion}
    \begin{columns}
      \def\BOOL{\bgroup\uncover<2>{\color{luhblue}bool\space}\egroup}
      \begin{column}{0.49\textwidth}
        \begin{code}\ttfamily\scriptsize
        \BOOL ConstantFolding(Function);\\
        \BOOL ValuePropagation(Function);\\
        \BOOL MergeBasicBlocks(Function);
      \end{code}

      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \begin{code}\ttfamily\scriptsize
        \BOOL EliminateRedundantGotos(Function);\\
        \BOOL EliminateDeadBlocks(Function);\\
        \BOOL EliminateDeadVariables(Function);
      \end{code}
      \end{column}
    \end{columns}

    \medskip
    \bi
    \ii Wir haben sechs \structure{Optimierungsverfahren für  Zwischencode} kennengelernt{
      \bi
      \ii Optimierungen ermöglichen sich gegenseitig Optimierungen
      \ii In welcher Reihenfolge sollen wir die Optimierungen anwenden?
      \ei
    }\medskip
    \ii<2-> Optimierung als Fixpunktiteration {
      \bi
      \ii Jedes Verfahren gibt zurück, ob die Funktion \alert{verändert} wurde
      \ii Bei Veränderung führen wir alle anderen Optimierungen \textbf{nochmals aus}
      \ei
    }
    \ei

    \begin{columns}
      \begin{column}{0.49\textwidth}\centering
        \includegraphics[width=3.5cm] {fig/09-optimization-depends}
      \end{column}
      \begin{column}<2->{0.49\textwidth}
        \begin{code}[]
          \begin{py}
            def optimize(func):
              changed = True
              while changed:
                changed = False

                for optimizer in optimizers:
                  ret = optimizer(func)
                  changed = changed or ret 
          \end{py}
        \end{code}
      \end{column}
    \end{columns}
  \end{frame}


  \begin{frame}{Meilensteine der optimierenden Übersetzer}
    Optimierende Übersetzer sind seit vielen Jahrzehnten ein aktives Forschungsebiet.
  Hier einige Arbeiten, die \textbf{ich} für Meilensteine halte:\\[1em]
  
    \begin{description}
      \item[1973] Datenflussanalyse als Fixpunktiteration    \hfill Kildall
      \item[1977] Abstrakte Interpretation                   \hfill Cousot und Cousot
      \item[1979] Portable Peephole Optimizer                \hfill Fraser
      \item[1989] Single-Static Assignment wird effizient    \hfill Cytron
      \item[1993] Verschmelzen von Schleifen                 \hfill Kelly and Pugh
      \item[1996] Effiziente Interprozedurale Alias Analyse  \hfill Steensgaard
      \item[2004] Low-Level Virtual Machine (LLVM)           \hfill Lattner
      \item[2010] Polyhedral Loop Optimization in GCC        \hfill Trifunovic
    \end{description}
  \end{frame}
#+end_src

* Zusammenfassung
#+begin_src latex
  \begin{frame}{Zusammenfassung}
    \bi
    \ii Optimierungen nur die \structure{nicht-funktionalen Programmeigenschaften} {
      \bi
      \ii Aus Sicht der Sprache bleibt das \structure{beobachtbare Verhalten} gleich
      \ii Verschiedene Optimierungsziele, wobei es meist um \structure{Ausführungszeit}  geht
      \ei
    }\medskip
    \ii Optimierungen sind immer zweigeteilte Übersetzungsschritte {
      \bi
      \ii \structure{Analyse} des Programms berechnet Informationen, die wir brauchen um zu entscheiden \textbf{ob und wie} eine Optimierung angewendet wird.
      \ii \structure{Transformation} der Zwischenrepräsentation des Programms setzt die Optimierung durch.
      \ei
    }\medskip
    \ii Auf \structure{IR-Ebene} reduzieren wir die Anzahl der Instruktionen und Sprünge{
      \bi
      \ii \structure{Konstantenfaltung} ersetzt konstante Berechnungen durch ihr Ergebnis
      \ii \structure{Wertepropagation} ersetzt Operanden durch äquivalente Werte/Konstanten
      \ii \structure{Verschmelzen} von streng konsekutiv ausgeführte Blöcke
      \ii \structure{Redundante Doppelsprünge} werden aufgelöst
      \ii \structure{Tote Blöcke} und \structure{tote Variablen} werden entfernt
      \ei
    }
    \ei
  
  \end{frame}
#+end_src
