#+TITLE: Programmiersprachen und Übersetzer
#+SUBTITLE: 09 - Optimierung
#+SETUPFILE: setup.org
#+INCLUDE: export-prologue.org
#+PROPERTY: header-args:latex :tangle yes :noweb yes :tangle-macros yes :tangle-prologue topic :tangle-epilogue endtopic :exports none

#+NAME: topic
#+BEGIN_SRC latex :tangle no
\psuSectionStart{{{{property(ITEM)}}}}{{{{n(block)}}}}
#+END_SRC

#+NAME: endtopic
#+BEGIN_SRC latex :tangle no
\psuSectionStop{{{{property(ITEM)}}}}{{{{n(block,-)}}}}
#+END_SRC

* Gedanken zu dieser Vorlesung                                     :noexport:
- Was darf Optimierung machen?
- Block-Lokale Optimierungen
  - Konstantenfaltung
  - Konstanten- und Kopiepropagation
  - Alias-Problematik
- Optimierung des Kontrollflusses
  - Redundante Jumps entfernen
  - Blöcke verschmelzen
- Müll aufräumen
  - Dead-Code Elimination
  - Dead-Store Elimination

* Was leistet die "Optimierung"?
:PROPERTIES:
:CUSTOM_ID: 08-einleitung
:END:

#+begin_src latex
  \subtitle{{{{subtitle()}}}}
  \begin{frame}
    \maketitle
  \end{frame}

  \begin{frame}{Einordnung in die Vorlesung: Optimierung}
    \begin{center}
      \includegraphics[page=7,width=0.9\linewidth]{fig/01-overview-small}
    \end{center}
    \bi
    \ii \structure{Hadwareunabhängige Optimierung} auf dem Zwischencode {
      \bi
      \ii IR-Code wurde \alert{ohne Rücksicht} auf die effizienzte Ausführbarkeit erstellt.
      \ii \structure{Effektive Entwickler}: Welche Arbeiten kann er dem Optimierer überlassen.
      \ii \structure{Effiziente Entwickler}: Wie lege ich dem Optimierer keine Steine in den Weg.
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[t,fragile]{Motivation: Da geht noch was!}
    \vspace{-2em}
    \begin{columns}[t]

    
      \begin{onlyenv}<1-2>
        \begin{column}{0.49\textwidth}
          \begin{code}[tag=L0]
          \lstinputlisting[style=lzero]{lst/09-example.l0}
        \end{code}
      
        Bei genauer Betrachtung, sehen wir, dass dieses Programm \ALERT{immer 0} zurück geben wird.

        \bigskip
        \uncover<2>{Dafür wird echt viel gerechnet!}
      \end{column}

    \end{onlyenv}
    \begin{onlyenv}<3->
      \begin{column}{0.49\textwidth}
        \mbox{}\par\bigskip
        \enquote{Der Übersetzer schaut genau hin}
        \medskip
        \be
        \ii {Konstante Auswertung} {
          \\[0.5ex]\enquote{Bekanntes Vorrausberechnen}\\[0.5ex]
          \bi
          \ii<4-> Arithmetische Berechnungen
          \ii<5-> Konstante Sprungbedingungen
          \ei
        }
        \ii<6-> {Konstanten- und Kopiepropagation}
        \ii<7-> Goto-auf-Goto  eliminieren
        \ii<8-> {Dead-Code Elimination}
        \ii<9-> {Basic-Block Merge}\\[2ex]
        \ii<10-> \ldots repeat, until no change.
        \ee
      \end{column}
    \end{onlyenv}
    \begin{column}<2->{0.49\textwidth}\centering
      \only<1-3>{\btAnimation[height=0.9\textheight,width=\textwidth,keepaspectratio]{raisebox,1:<1->}{fig/09-example-unoptimized}}%
        \only<4>{\btAnimation[height=0.9\textheight,width=\textwidth,keepaspectratio]{raisebox,1:<1->}{fig/09-example-cf1}}%
        \only<5>{\btAnimation[height=0.9\textheight,width=\textwidth,keepaspectratio]{raisebox,1:<1->}{fig/09-example-cf2}}%
        \only<6>{\btAnimation[height=0.9\textheight,width=\textwidth,keepaspectratio]{raisebox,1:<1->}{fig/09-example-cvp}}%
        \only<7>{\btAnimation[height=0.9\textheight,width=\textwidth,keepaspectratio]{raisebox,1:<1->}{fig/09-example-jumps}}%
        \only<8>{\btAnimation[height=0.9\textheight,width=\textwidth,keepaspectratio]{raisebox,1:<1->}{fig/09-example-dce}}%
        \only<9>{\btAnimation[height=0.9\textheight,width=\textwidth,keepaspectratio]{raisebox,1:<1->}{fig/09-example-merge}}%
        \only<10>{\btAnimation[width=0.5\textwidth]   {raisebox,1:<1->}{fig/09-example-repeat}}
      \end{column}
    \end{columns}
  \end{frame}
#+end_src

* Vorraussetzungen und Ziele
#+begin_src latex
  \dividerframe{Ziele und Vorraussetzungen\\der Optimierung}

  \begin{frame}{Ziele bei IR-Level Optimierung}
    \begin{btBlock}[type=example]{Allgemeine Optimierungsziele}
      Ziel jeder Programm-Optimierung ist es, die \textbf{nicht-funktionalen} Eigenschaften, unter Beibehaltung der \textbf{erwarteten Funktionalität}, zu verbessern.
    \end{btBlock}

    \bi
    \ii Nicht-Funktionale Eigenschaften nach denen wir optimieren {
      \bi
      \ii \structure{Ausführungszeit}: Abbildung auf weniger oder schnellere Instruktionen
      \ii \structure{Programmgröße}: Veringerung der Binärgröße (eingebettete Systeme)
      \ii \structure{Energieverbrauch}: Verlängerung der Batterielaufzeit
      \ei
    }\medskip
    \ii<2-> Auf der Hardware-unabhängigen IR-Ebene fehlt das \alert{Kostenmodell}{
      \bi
      \ii Wir wissen nicht wie schnell, groß, oder Energie-hungrig einzelne Instruktionen auf der Zielplattform sein werden.
      \ii \structure{Heuristik}: \enquote{Speicherzugriffe und Sprünge sind teuer.}
      \medskip
      \ii<3->[$\Rightarrow$] Generelle Reduktion der Anzahl der Instruktionen und Basisblöcke
      \ei
    }
    \ei
  
  \end{frame}

  \begin{frame}{Wiederholung (1. Vorlesung): Korrekte Übersetzung}
    \bi
    \ii Die Programmiersprache definiert die \alert{beobachtbaren} Zustände. {
      \bi
      \ii Ein- und Ausgabe ist immer beobachtbar, oft aber auch Teile des Speichers
      \ii Bei C: Nur das Schreiben von globalen Variablen, nicht aber von lokalen.
      \ei
    }\bigskip
    \ii Ein \advantage{korrekter} Übersetzer erhält alle beobachtbaren Zustände.{
      \bi
      \ii Parsing+Code-Erzeugung ist eine \textbf{Abbildungsfunktion}:\\[2ex]{
        \includegraphics[page=2,width=0.9\textwidth]{fig/01-zustand}
      }
      \ei
    }\bigskip
    \ii[$\Rightarrow$] Funktionen \advantage{dürfen verändert werden}, solange sie außen gleich aussehen {
      \bi
      \ii Im IR-Code: lokalen und temporären Variablen sind nicht sichtbar
      \ii Von Außen sichtbar sind: \ircmd{Store}, \ircmd{Call}, \ircmd{Return}
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{Phasen und Umfang der Optimierung}
    \begin{center}
      \includegraphics{fig/09-analyse}
    \end{center}
    \bi
    \ii Optimierung besteht immer aus \textbf{zwei Schritten} {
      \bi
      \ii \structure{Analyse} des Programms generiert Wissen anhand dessen wir entscheiden können, ob wie \alert{eine Optimierung anwenden dürfen}.
      \ii \structure{Transformation} in ein semantisch äquivalentes, aber \enquote{besseres} Programm.
      \ei
    }\medskip
    \ii Optimierungen analysieren und transformieren \textbf{Programmausschnitte} {
      \bi
      \ii Wie groß ist der Ausschnitt über den wir wissen extrahieren?
      \ii Instruktionen, einzelne Basisblöcke, eine ganze Funktion, eine Aufrufhierarchie, mehrere interagierende Threads
      \ei
    }
    \ei
  \end{frame}
#+end_src

* Optimierungen
** Instruktions- und Block-lokale Optimierungen
#+begin_src latex
\dividerframe{Lokale Optimierungen}

  \begin{frame}{Algebraische Identitäten}
    \OrangeBox{Ersetzung von Instruktionen durch algebraisch-äquivalente Instruktionen}

    \bi
    \ii<1-> \structure{Konstantenfaltung} ist eine Instruktions-lokale Optimierung\\[1ex]{
      \hfill\fbox{\texttt{a := \ircmd{Add} 1, 2}}\hfill$\Rightarrow$\hfill\fbox{\texttt{a := Assign 3}}\hfill\mbox{}\\[1ex]
      \bi
      \ii \textbf{Ziel}: Ersetzung von Instruktionen mit ausschließlich konstanten Operanden
      \ii Sprach-Semantik muss erhalten (32-Bit Programm vs. 64-Bit Übersetzer)
      \ei
    }\medskip
    \ii<2-> \structure{Strength-Reduction} veringert die Ausdruckstärke einer Instruktion\\[1ex]{
      \hfill\fbox{\texttt{a := \ircmd{Mul} x, 2}}\hfill$\Rightarrow$\hfill\fbox{\texttt{a := Add x, x}}\hfill\mbox{}\\[1ex]
      \bi
      \ii Arithmetische Operationen haben unterschiedliche theoretische Komplexitäten
      \ii Multiplikation: $\mathcal{O}(n\cdot\log(n)\cdot\log(\log(n)))$ (FFT) vs. Addition: $\mathcal{O}(n)$
      \ii Ausdrucksstärke: Potenzierung $\gg$ Multiplikation $\gg$ Addition $\gg$ Bit-Shift
      \ei
    }\medskip
    \ii<3-> \structure{Technische Umsetzung}: Wende Ersetzungsregeln auf jede Instruktion an{
      \bi
      \ii \structure{Ersetzungsmuster} gibt Bedingungen vor, die Operanden erfüllen müssen
      \ii Ersetze die Instruktion im umgebenden Basisblock
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[fragile]{Algebraische Identitäten: Beispielhafte Ersetzugsmustern}
    \def\Var#1{\colorbox{safegreen!40}{#1}}
    \def\Const#1{\colorbox{badbee!40}{#1}}
    \def\Label#1{\colorbox{luhblue!40}{#1}}

    \centering
    \OrangeBox{Variablen: \Var{A}, Konstanten: \Const{x}, Labels: \Label{L}}\\[1ex]

    { \ttfamily
      \begin{tabular}{l|c|l}\toprule
        Orginal                                        & Bedingungen      & Ersetzung                              \\\midrule
        \multicolumn{3}{l}{\structure{Null-Operationen}}                                             \\
        \hspace{2em}\Var{A} := \ircmd{Add} \Var{B}, \Const{0}   & --               & \Var{A} := \ircmd{Assign} \Var{B}  \\
        \hspace{2em}\Var{A} := \ircmd{Mul} \Var{B}, \Const{1}   & --               & \Var{A} := \ircmd{Assign} \Var{B}  \\
        \hspace{2em}\Var{A} := \ircmd{Sub} \Var{B}, \Var{B}     & --               & \Var{A} := \ircmd{Assign} \Const{0}  \\\midrule
        \multicolumn{3}{l}{\structure{Konstantenfaltung}}                                             \\
        \hspace{2em}\Var{A} := \ircmd{Add} \Const{b}, \Const{c}    & --               & \Var{A} := \ircmd{Assign} \Const{b+c}  \\
        \hspace{2em}\ircmd{IfGoto} \Const{x}, \Label{A}, \Label{B} & \Const{x}!=0     & \ircmd{Goto} \Label{A}                 \\
        \hspace{2em}\ircmd{IfGoto} \Const{x}, \Label{A}, \Label{B} & \Const{x}==0     & \ircmd{Goto} \Label{B}                 \\\midrule
        \multicolumn{3}{l}{\structure{Strength-Reduction}}                                            \\
        \hspace{2em}\Var{A} := \ircmd{Pow} \Var{B}, \Const{2}      & --               & \Var{A} := Mul \Var{B}, \Var{B}        \\
        \hspace{2em}\Var{A} := \ircmd{Mul} \Var{B}, \Const{n}      & \Const{n}==$2^x$ & \Var{A} := LShift \Var{B}, \Const{x} \\
        \bottomrule
      \end{tabular}
    }
  \end{frame}
#+end_src

#+begin_src latex
  \begin{frame}{Konstanten- und Kopiepropagation}
    \begin{columns}
      \begin{column}{0.35\textwidth}
        \btAnimation[width=\textwidth]{range=1-3:<1->,3:<4->}{fig/09-cvp}
      \end{column}\hfill
      \begin{column}{0.60\textwidth}
        \begin{btBlock}{}\small
          Durch die einfache Codeerzeugung und bei der Optimierung enstehen konstante oder redundante Zuweisungen.
        \end{btBlock}
      \end{column}
    \end{columns}
    \medskip

    \bi
    \ii<3-> Propagation bekannter Werte durch einen Basisblock {
      \bi
      \ii Zum Zeitpunkt einer Zuweisung werden rechte und linke Seite äquivalent.
      \ii Operanden-Ersetzung in den folgenden Instruktionen
      \ii \ALERT{Aber}: Wir dürfen nur solange ersetzen, wie die Äquivalenz sicher ist.
      \ei
    }\medskip
    \ii<4-> \structure{Intuition} für die Propagation von Konstanten und Werten {
      \bi
      \ii Iteration über die Instruktionen eines BBs, Mitführen von Äquivalenzmengen
      \ii Zuweisungen etablieren eine neue Äquivalenz zwischen LHS und RHS
      \ii Andere Schreibzugriffe, die eine Variable verändern, löschen Äquivalenzen
      \ii Bei Lesezugriffen, wird die Äquivalenzliste befragt und ggf. ersetzt.
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{Vorgehen für Wertpropagation}
    \btAnimation[width=0.75\textwidth]{center,range=4-11:<1->}{fig/09-cvp}

    \bi
    \ii \structure{Äquivalenzmengen} werden \enquote{durchgeschoben}, modifiziert und befragt {
      \be
      \ii<2-|handout:2-> Zu Beginn des Blocks ist nichts zu nichts anderem äquivalent
      \ii<3-|handout:3-> Bei Zuweisungen werden linke und rechte Seite äquivalent
      \ii<4-|handout:4-> Quelloperanden werden durch \advantage{äquivalente Konstanten oder Variablen} ersetzt
      \ii<4-|handout:4-> Äquivalenzmengen können mehr als 2 Elemente haben
      \ii<5-|handout:5-> Nicht-\ircmd{Assign} Schreiboperationen entfernen Elemente aus ihrer Menge
      \ee
    }
    \ei

    \OrangeBox<8>{Kann die Funktion f, die Variable x, y, oder t0 verändern?}
  \end{frame}

  \begin{frame}{Alias-Problematik bei der Datenflussanalyse}

    \begin{center}
      \includegraphics[page=12]{fig/09-cvp}
    \end{center}


    \bi
    \ii Das Problem sind Zeiger, die unsere IR-Variablen \alert{verändern könnten} {
      \bi
      \ii Wenn \texttt{ptr} auf \texttt{y} zeigt, kann sich \texttt{y} ändern, ohne explizit Operand zu sein
      \ii Im Funktions-lokalen Scope, wissen wir nicht was \texttt{func()} mit \texttt{ptr} macht.
      \ii Die \ircmd{Store}-Instruktion könnte \texttt{y} auf 3 setzen
      \ei
    }\medskip
    \ii<2-> Dies ist das \structure{Alias-Problem} für Zeiger {
      \bi
      \ii Wir müssten genau wissen auf welche Objekte ein Zeiger verweisen kann
      \ii Dies erfordert aufwendige, teils inter-prozedurale, Analysen.
      \ii Beim geringste Zweifel über die Alias-Relation, \textbf{wirft der Optimierer hin}
      \ei
    }\medskip
    \ii<3-> Einfache Heursitik für die unsere Wertepropagation {
      \bi
      \ii Bei jedem \ircmd{Store} und bei jedem \ircmd{Call} werfen wir die Äquivalenzmengen weg. Better safe, than sorry.
      \ei
    }
    \ei
    \begin{overlaybox}<4>[draw=srared,ultra thick,drop shadow,inner sep=1em]
      \columntitle{Take-Away für den effizienten Programmierer}\medskip

      \bii
      \ii Wildes Zeiger-rum-gefuchtel macht dem Übersetzer das Leben schwer.
      \ii Variablen sind umsonst, Wertepropagation eliminiert Zuweisungen.\\[1ex]
      \ii[$\Rightarrow$] Programmieren Sie \advantage{\textbf{verständlich}}, nicht \enquote{\ALERT{optimiert}}!
      \eii
    \end{overlaybox}
  \end{frame}
#+end_src

** Funktionsweite Optimierungen
#+begin_src latex
  \dividerframe{Funktionsweite Optimierungen}

  \begin{frame}{Wertepropagation über Basisblockgrenzen}
    \textbf{Bisher}: Wertepropagation (CVP) innerhalb eines Basisblocks.

    \begin{center}
      \strut\alt<1>{
        \siginline{CVP}{BasicBlock}{()}
      }{
        \siginline{CVP}{BasicBlock, Equivalences}{Equivalences}
      }
    \end{center}

    \bi
    \ii Wertepropagation ist eine \structure{Datenflussanalyse}{
      \bi
      \ii Wir verfolgen wie Datenwerte entlang des Kontrollflusses \enquote{fließen}
      \ii In einem Basisblock ist der Kontrollfluss determiniert linear
      \ii Die CVP propagiert eine Äquivalenzmenge durch einen Block
      \ei
    }\medskip
    \ii<2-> Wir wollen die CVP auf eine ganze Funktion anweden {
      \bi
      \ii Blöcke werden zu Transformator-Funktionen für Äquivalenzmengen
      \ii Äquivalenzmengen \enquote{fließen} entlang der Kontrollflusskanten
      \ii Fixpunkt-Iteration bis keine Änderungen mehr auftreten
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{Fixpunktiteration auf einem CFG}

    \begin{columns}
      \begin{column}{0.49\textwidth}
        \btAnimation[width=\textwidth]{range=1-4:<1->, 4:<5->}{fig/09-fixpoint}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \begin{btBlock}{}
          \textbf{Problem}: Wie wenden wir eine Block-lokale Datenflussanalyse (z.B. CVP) auf eine ganze Funktion an?
        \end{btBlock}

        \medskip

        \columntitle{Elemente}
        \bii
        \ii<2-> Transformation-Funktion: \texttt{T()}
        \ii<3-> Propagierte Zustände: $d_n$
        \ii<4-> Zustands-Merge-Funktion: \texttt{M()}
        \eii

        \uncover<5->{
          \medskip
          \columntitle{Vorgehen}
          \bii
          \ii Initialisiere Zustände $d_n$
          \ii Iterierte Auswertung von \texttt{M(), T()}
          \ii Updaten der Block-Zustände
          \ii Stop, wenn Fixpunkt erreicht ist
          \eii
        }
      \end{column}
    \end{columns}
  \end{frame}

  \begin{frame}{Fixpunktiteration als Worklist-Algorithmus}
    \begin{code}[tag=Python]
      \lstinputlisting[style=py,style=smaller,linerange=s0-e0]{lst/09-fixpoint.py}
      \uncover<2->{\lstinputlisting[style=py,style=smaller,linerange=s1-e1]{lst/09-fixpoint.py}}
      \uncover<3->{\lstinputlisting[style=py,style=smaller,linerange=s2-e2]{lst/09-fixpoint.py}}
      \uncover<4->{\lstinputlisting[style=py,style=smaller,linerange=s3-e3]{lst/09-fixpoint.py}}
      \uncover<5->{\lstinputlisting[style=py,style=smaller,linerange=s4-e4]{lst/09-fixpoint.py}}
      \uncover<6->{\lstinputlisting[style=py,style=smaller,linerange=s5-e5]{lst/09-fixpoint.py}}
    \end{code}
  \end{frame}

  \begin{frame}[t]{Fixpunkiteration als Datenflussanalyse}
    \bi
    \ii \structure{Vorraussetzungen} für die Terminierung des Worklist-Algorithmus{
      \bi
      \ii Init+Merge+Transform muss Knotenzustände \alert{strikt monoton} ändern
      \ii Beliebte Datenstrukturen für die Zustand: Bitvektoren, Mengen
      \ii Beispiel für eine strikt-monotone : {
        \bi
        \ii \texttt{init()}: \hspace{2cm}\btSetTab Generiere eine leere Menge
        \ii \texttt{merge()}: \btUseTab Vereinige alle Eingabemengen
        \ii \texttt{transform()}: \btUseTab Füge der Menge nur Elemente hinzu
        \ei
      }
      \ei
    }\medskip
    \ii Verschiedene Geschmacksrichtungen {
      \bi
      \ii \structure{Vorwärts-Analyse}: Zustände werden in Richtung der CFG-Kanten propagiert
      \ii \structure{Rückwärts-Analyse}: Zustände werden entgegen der CFG-Kanten propagiert
      \ei
    }\medskip
    \ii \structure{Wertepropagation} als Fixpunktanalyse {
      \bi
      \ii Initialisierung mit leeren Äquivalenzmengen
      \ii Transformation wie gehabt mit \texttt{CVP(BasicBlock, Equivalences)}
      \ii Merge: \btSetTab Zwei Werte sind genau dann äquivalent,\\\btUseTab Wenn sie in allen Eingabemenge äquivalent sind.
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[fragile,t]{Beispiel für Wertepropagation}
    \vspace{-2em}
    \begin{columns}[t]
      \begin{column}{0.55\textwidth}
        \btAnimation[width=\textwidth]{raisebox,range=1-8:<1->}{fig/09-fixpoint-cvp}      
      \end{column}\hfill
      \begin{column}{0.44\textwidth}\mbox{}\\[3ex]
        \columntitle{Worklist}
        \centering
          \texttt{[%
            \only<2>{BB0, BB1, BB3, BB2}%
            \only<3>{BB1, BB3, BB2}%
            \only<4>{BB3, BB2}%
            \only<5>{BB2}%
            \only<6>{BB3}%
            \only<7>{BB0}%
            ]}\\[3ex]

        \columntitle{Merge Logbuch}
        \def\L{\texttt\small}\small
        \def\E{$\emptyset$}
        \only<5->{\colorbox{badbee!20}{\medskip
        \begin{tabular}{lr}
          BB1 & \L{[\{a, c, 2\}, \{b, x, 3\}]}  \\
          BB2 & \L{\E}                          \\\midrule
          BB3 &\L{\E}                         
        \end{tabular}
      }}
      \mbox{}\bigskip\mbox{}
      \only<7->{\colorbox{badbee!20}{\medskip
        \begin{tabular}{lr}
          BB1 & \L{[\{a, c, 2\}, \{b, x, 3\}]}  \\
          BB2 & \L{[\{a, 2\}, \{b, x, 4\}]}     \\\midrule
          BB3 &\L{[\{a, 2\}, \{b, x\}]}         \\
        \end{tabular}
        }
      \bigskip\mbox{}
      Der Merge-Code ist fummelig.
    }
      \end{column}
    \end{columns}

  \end{frame}
#+end_src

**  Optimierung des Kontrollflusses
#+begin_src latex

  \dividerframe{Optimierung des Kontrollflusses}

  \begin{frame}{Verschmelzen von konsekutiven Basisblöcken}
    \begin{columns}
      \begin{column}{0.4\textwidth}
        \btAnimation[width=\textwidth]{range=1-2:<1->,3:<3->}{fig/09-block-merge}
      \end{column}\hfill
      \begin{column}{0.6\textwidth}
        \bii
        \ii \textbf{Problem}: Sprung zu BB1 ist überflüssig.{
          \bi
          \ii BB0 hat genau einen Nachfolger
          \ii BB1 hat genau einen Vorgänger
          \ii[$\Rightarrow$] Verschmelze beide BB0 und BB1
          \ei
        }\medskip
        \ii<2-> \textbf{Analyse}: Finde Block-Paar (x, y), sodass...{
          \bi
          \ii y ist Nachfolger von x
          \ii x hat genau einen Nachfolger
          \ii y hat genau einen Vorgänger
          \ei
        }
        \ii<3-> \textbf{Transformation}: Verschmelze $x\rightarrow y${
          \bi
          \ii Lösche \ircmd{Goto} aus x
          \ii Hänge Instruktionen von y an x
          \ii Block y wird später gelöscht
          \ei
        }
        \eii
        \begin{btBlock}<4->[type=info]{Trennung der Belange}\small
          Das Aufräumen des toten Blocks (BB1) übernimmt eine andere Optimierung.
        \end{btBlock}
      \end{column}
    \end{columns}

  \end{frame}

  \begin{frame}{Elimination von unbedingten Doppelsprüngen}

      \begin{columns}
      \begin{column}{0.4\textwidth}
        \btAnimation[width=\textwidth]{1:<1-2>, 2:<3>, 3:<4->}{fig/09-redundant-jump}
      \end{column}\hfill
      \begin{column}{0.6\textwidth}
        \bii
        \ii \textbf{Problem}: BB2 ist überflüssig{
          \bi
          \ii BB2 enthält \textbf{nur} ein \ircmd{Goto}
          \ii Jeder Sprung zu BB2 ist ein Sprung zu BB3
          \ii[$\Rightarrow$] \textbf{Ziel}: Vermeide reundante Sprünge
          \ei
        }\medskip
        \ii<2-> \textbf{Hinweis}: Verschmelzen hier unmöglich {
          \bi
          \ii BB3 hat mehrere Vorgänger
          \ii Verschmelzen würde BB Bedingung verletzen
          \ei
        }\medskip
        \ii<3-> \textbf{Analyse}: Finde Block x sodass\ldots{
          \bi
          \ii x nur ein \ircmd{Goto} enthält
          \ii x hat y als einzigen Nachfolger
          \ei
        }\medskip
        \ii<4-> \textbf{Transformation}:{
          \bi
          \ii Besuche alle Vorgänger von x
          \ii Ersetze jedes x.label durch y.label
          \ii Block x wird später gelöscht
          \ei
        }
        \eii
      \end{column}
    \end{columns}

  
  \end{frame}

#+end_src

#+begin_src latex
  \dividerframe{Aufräumen}

  \begin{frame}{Elimination von toten Basisblöcken}
    \begin{columns}
      \begin{column}{0.4\textwidth}
        \btAnimation[width=0.75\textwidth]{center,padding=1em,range=4-6:<1->}{fig/09-block-merge}
        \btAnimation[width=0.75\textwidth]{center,padding=1em,range=4-6:<1->}{fig/09-redundant-jump}
      \end{column}\hfill
      \begin{column}{0.58\textwidth}
        \bii
        \ii \textbf{Problem}: Optimierungen hinterlassen Müll{
          \bi
          \ii Aufräumen von totem Code zentralisieren
          \ii Blöcke die nie angesprungen werden
          \ei
        }\medskip
        \ii<2-> \textbf{Analyse}: Finde tote Blöcke{
          \bi
          \ii Blöcke ohne Vorgänger
          \ii Keine Label-Adresse im Umlauf
          \ei
        }\medskip
        \ii<2-> \textbf{Transformation}: Lösche Block {
          \bi
          \ii Entfernung aller ausgehenden Kanten
          \ii Block bei umgebender Funktion entfernen
          \ei
        }
        \eii
      \end{column}
    \end{columns}

  \end{frame}
  #+end_src

** Elimination toter Instruktionen
#+begin_src latex
  \begin{frame}[t]{Elimination von toten Variablen}
    \begin{center}
      \vspace{-2em}
      \btAnimation[width=0.5\textwidth]{range=1-9:<1->}{fig/09-dve}  
    \end{center}

    \bi
    \ii \textbf{Problem}: Vorangegangene Optimierungen machen Variablen überflüssig{%
      \bi
      \ii \structure{Konstantenfaltung} ersetzt Operationen durch ihr konstantes Ergebnis
      \ii Durch \structure{Wertepropagation} werden äquivalente Quelloperanden vereinigt
      \ei
    }
    \ii<8-> \textbf{Analyse}: Finde alle lokalen Variablen, die \advantage{nie gelesen werden}{
      \bi
      \ii \alert{Vorsicht}: Zeiger können Variablen indirekt lesen (Alias-Problem)
      \ii \advantage{Heuristik}: Markiere alle Variablen deren Addresse berechnet wird als \enquote{gelesen}
      \ei
    }
    \ii<9-> \textbf{Transformation}: Entferne niemals gelesene lokale Variable x {
      \bi
      \ii Lösche Instruktionen, die x schreiben und kein \ircmd{Call} sind (Seiteneffekte!)
      \ii Lösche x aus der umgebenden Funktion
      \ei
    }
    \ei
  
  \end{frame}

#+end_src

* Optimierung im größeren Zusammenhang

#+begin_src latex
  \dividerframe{Optimierungen\\im\\Kontext}
  \begin{frame}[fragile]{Optimieren einer Funktion}
    \begin{columns}
      \def\BOOL{\bgroup\uncover<2>{\color{luhblue}bool\space}\egroup}
      \begin{column}{0.49\textwidth}
        \begin{code}\ttfamily\scriptsize
        \BOOL ConstantFolding(Function);\\
        \BOOL ValuePropagation(Function);\\
        \BOOL MergeBasicBlocks(Function);
      \end{code}

      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \begin{code}\ttfamily\scriptsize
        \BOOL EliminateRedundantGotos(Function);\\
        \BOOL EliminateDeadBlocks(Function);\\
        \BOOL EliminateDeadVariables(Function);
      \end{code}
      \end{column}
    \end{columns}

    \medskip
    \bi
    \ii Wir haben sechs \structure{Optimierungsverfahren für  Zwischencode} kennengelernt{
      \bi
      \ii Optimierungen ermöglichen sich gegenseitig Optimierungen
      \ii In welcher Reihenfolge sollen wir die Optimierungen anwenden?
      \ei
    }\medskip
    \ii<2-> Optimierung als Fixpunktiteration {
      \bi
      \ii Jedes Verfahren gibt zurück, ob die Funktion \alert{verändert} wurde
      \ii Bei Veränderung führen wir alle anderen Optimierungen \textbf{nochmals aus}
      \ei
    }
    \ei

    \begin{columns}
      \begin{column}{0.49\textwidth}\centering
        \includegraphics[width=3.5cm] {fig/09-optimization-depends}
      \end{column}
      \begin{column}<2->{0.49\textwidth}
        \begin{code}[]
          \begin{py}
            def optimize(func):
              changed = True
              while changed:
                changed = False

                for optimizer in optimizers:
                  ret = optimizer(func)
                  changed = changed or ret 
          \end{py}
        \end{code}
      \end{column}
    \end{columns}
  \end{frame}


  \begin{frame}{Meilensteine der optimierenden Übersetzer}
    Optimierende Übersetzer sind seit vielen Jahrzehnten ein aktives Forschungsebiet.
  Hier einige Arbeiten, die \textbf{ich} für Meilensteine halte:\\[1em]
  
    \begin{description}
      \item[1973] Datenflussanalyse als Fixpunktiteration    \hfill Kildall
      \item[1977] Abstrakte Interpretation                   \hfill Cousot und Cousot
      \item[1979] Portable Peephole Optimizer                \hfill Fraser
      \item[1989] Single-Static Assignment wird effizient    \hfill Cytron
      \item[1993] Verschmelzen von Schleifen                 \hfill Kelly and Pugh
      \item[1996] Effiziente Interprozedurale Alias Analyse  \hfill Steensgaard
      \item[2004] Low-Level Virtual Machine (LLVM)           \hfill Lattner
      \item[2010] Polyhedral Loop Optimization in GCC        \hfill Trifunovic
    \end{description}
  \end{frame}
#+end_src
