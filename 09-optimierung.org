#+TITLE: Programmiersprachen und Übersetzer
#+SUBTITLE: 09 - Optimierung
#+SETUPFILE: setup.org
#+INCLUDE: export-prologue.org
#+PROPERTY: header-args:latex :tangle yes :noweb yes :tangle-macros yes :tangle-prologue topic :tangle-epilogue endtopic :exports none

#+NAME: topic
#+BEGIN_SRC latex :tangle no
\psuSectionStart{{{{property(ITEM)}}}}{{{{n(block)}}}}
#+END_SRC

#+NAME: endtopic
#+BEGIN_SRC latex :tangle no
\psuSectionStop{{{{property(ITEM)}}}}{{{{n(block,-)}}}}
#+END_SRC

* Gedanken zu dieser Vorlesung                                     :noexport:
- Was darf Optimierung machen?
- Block-Lokale Optimierungen
  - Konstantenfaltung
  - Konstanten- und Kopiepropagation
  - Alias-Problematik
- Optimierung des Kontrollflusses
  - Redundante Jumps entfernen
  - Blöcke verschmelzen
- Müll aufräumen
  - Dead-Code Elimination
  - Dead-Store Elimination

* Was leistet die "Optimierung"?
:PROPERTIES:
:CUSTOM_ID: 08-einleitung
:END:

#+begin_src latex
  \subtitle{{{{subtitle()}}}}
  \begin{frame}
    \maketitle
  \end{frame}

  \begin{frame}{Einordnung in die Vorlesung: Optimierung}
    \begin{center}
      \includegraphics[page=7,width=0.9\linewidth]{fig/01-overview-small}
    \end{center}
    \bi
    \ii \structure{Hadwareunabhängige Optimierung} auf dem Zwischencode {
      \bi
      \ii IR-Code wurde \alert{ohne Rücksicht} auf die effizienzte Ausführbarkeit erstellt.
      \ii \structure{Effektive Entwickler}: Welche Arbeiten kann er dem Optimierer überlassen.
      \ii \structure{Effiziente Entwickler}: Wie lege ich dem Optimierer keine Steine in den Weg.
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[t,fragile]{Motivation: Da geht noch was!}
    \vspace{-2em}
    \begin{columns}[t]

    
      \begin{onlyenv}<1-2>
        \begin{column}{0.49\textwidth}
          \begin{code}[tag=L0]
          \lstinputlisting[style=lzero]{lst/09-example.l0}
        \end{code}
      
        Bei genauer Betrachtung, sehen wir, dass dieses Programm \ALERT{immer 0} zurück geben wird.

        \bigskip
        \uncover<2>{Dafür wird echt viel gerechnet!}
      \end{column}

    \end{onlyenv}
    \begin{onlyenv}<3->
      \begin{column}{0.49\textwidth}
        \mbox{}\par\bigskip
        \enquote{Der Übersetzer schaut genau hin}
        \medskip
        \be
        \ii {Konstante Auswertung} {
          \\[0.5ex]\enquote{Bekanntes Vorrausberechnen}\\[0.5ex]
          \bi
          \ii<4-> Arithmetische Berechnungen
          \ii<5-> Konstante Sprungbedingungen
          \ei
        }
        \ii<6-> {Konstanten- und Kopiepropagation}
        \ii<7-> Goto-auf-Goto  eliminieren
        \ii<8-> {Dead-Code Elimination}
        \ii<9-> {Basic-Block Merge}\\[2ex]
        \ii<10-> \ldots repeat, until no change.
        \ee
      \end{column}
    \end{onlyenv}
    \begin{column}<2->{0.49\textwidth}\centering
      \only<1-3>{\btAnimation[height=0.9\textheight,width=\textwidth,keepaspectratio]{raisebox,1:<1->}{fig/09-example-unoptimized}}%
        \only<4>{\btAnimation[height=0.9\textheight,width=\textwidth,keepaspectratio]{raisebox,1:<1->}{fig/09-example-cf1}}%
        \only<5>{\btAnimation[height=0.9\textheight,width=\textwidth,keepaspectratio]{raisebox,1:<1->}{fig/09-example-cf2}}%
        \only<6>{\btAnimation[height=0.9\textheight,width=\textwidth,keepaspectratio]{raisebox,1:<1->}{fig/09-example-cvp}}%
        \only<7>{\btAnimation[height=0.9\textheight,width=\textwidth,keepaspectratio]{raisebox,1:<1->}{fig/09-example-jumps}}%
        \only<8>{\btAnimation[height=0.9\textheight,width=\textwidth,keepaspectratio]{raisebox,1:<1->}{fig/09-example-dce}}%
        \only<9>{\btAnimation[height=0.9\textheight,width=\textwidth,keepaspectratio]{raisebox,1:<1->}{fig/09-example-merge}}%
        \only<10>{\btAnimation[width=0.5\textwidth]   {raisebox,1:<1->}{fig/09-example-repeat}}
      \end{column}
    \end{columns}
  \end{frame}
#+end_src

* Vorraussetzungen und Ziele
#+begin_src latex
  \dividerframe{Ziele und Vorraussetzungen\\der Optimierung}

  \begin{frame}{Ziele bei IR-Level Optimierung}
    \begin{btBlock}[type=example]{Allgemeine Optimierungsziele}
      Ziel jeder Programm-Optimierung ist es, die \textbf{nicht-funktionalen} Eigenschaften, unter Beibehaltung der \textbf{erwarteten Funktionalität}, zu verbessern.
    \end{btBlock}

    \bi
    \ii Nicht-Funktionale Eigenschaften nach denen wir optimieren {
      \bi
      \ii \structure{Ausführungszeit}: Abbildung auf weniger oder schnellere Instruktionen
      \ii \structure{Programmgröße}: Veringerung der Binärgröße (eingebettete Systeme)
      \ii \structure{Energieverbrauch}: Verlängerung der Batterielaufzeit
      \ei
    }\medskip
    \ii<2-> Auf der Hardware-unabhängigen IR-Ebene fehlt das \alert{Kostenmodell}{
      \bi
      \ii Wir wissen nicht wie schnell, groß, oder Energie-hungrig einzelne Instruktionen auf der Zielplattform sein werden.
      \ii \structure{Heuristik}: \enquote{Speicherzugriffe und Sprünge sind teuer.}
      \medskip
      \ii<3->[$\Rightarrow$] Generelle Reduktion der Anzahl der Instruktionen und Basisblöcke
      \ei
    }
    \ei
  
  \end{frame}

  \begin{frame}{Wiederholung (1. Vorlesung): Korrekte Übersetzung}
    \bi
    \ii Die Programmiersprache definiert die \alert{beobachtbaren} Zustände. {
      \bi
      \ii Ein- und Ausgabe ist immer beobachtbar, oft aber auch Teile des Speichers
      \ii Bei C: Nur das Schreiben von globalen Variablen, nicht aber von lokalen.
      \ei
    }\bigskip
    \ii Ein \advantage{korrekter} Übersetzer erhält alle beobachtbaren Zustände.{
      \bi
      \ii Parsing+Code-Erzeugung ist eine \textbf{Abbildungsfunktion}:\\[2ex]{
        \includegraphics[page=2,width=0.9\textwidth]{fig/01-zustand}
      }
      \ei
    }\bigskip
    \ii[$\Rightarrow$] Funktionen \advantage{dürfen verändert werden}, solange sie außen gleich aussehen {
      \bi
      \ii Im IR-Code: lokalen und temporären Variablen sind nicht sichtbar
      \ii Von Außen sichtbar sind: \ircmd{Store}, \ircmd{Call}, \ircmd{Return}
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{Phasen und Umfang der Optimierung}
    \begin{center}
      \includegraphics{fig/09-analyse}
    \end{center}
    \bi
    \ii Optimierung besteht immer aus \textbf{zwei Schritten} {
      \bi
      \ii \structure{Analyse} des Programms generiert Wissen anhand dessen wir entscheiden können, ob wie \alert{eine Optimierung anwenden dürfen}.
      \ii \structure{Transformation} in ein semantisch äquivalentes, aber \enquote{besseres} Programm.
      \ei
    }\medskip
    \ii Optimierungen analysieren und transformieren \textbf{Programmausschnitte} {
      \bi
      \ii Wie groß ist der Ausschnitt über den wir wissen extrahieren?
      \ii Instruktionen, einzelne Basisblöcke, eine ganze Funktion, eine Aufrufhierarchie, mehrere interagierende Threads
      \ei
    }
    \ei
  \end{frame}
#+end_src

* Instruktions- und Block-lokale Optimierungen
#+begin_src latex
  \dividerframe{Einfache Optimierungen}

  \begin{frame}{Algebraische Identitäten}
    \OrangeBox{Ersetzung von Instruktionen durch algebraisch-äquivalente Instruktionen}

    \bi
    \ii<1-> \structure{Konstantenfaltung} ist eine Instruktions-lokale Optimierung\\[1ex]{
      \hfill\fbox{\texttt{a := \ircmd{Add} 1, 2}}\hfill$\Rightarrow$\hfill\fbox{\texttt{a := Assign 3}}\hfill\mbox{}\\[1ex]
      \bi
      \ii \textbf{Ziel}: Ersetzung von Instruktionen mit ausschließlich konstanten Operanden
      \ii Sprach-Semantik muss erhalten (32-Bit Programm vs. 64-Bit Übersetzer)
      \ei
    }\medskip
    \ii<2-> \structure{Strength-Reduction} veringert die Ausdruckstärke einer Instruktion\\[1ex]{
      \hfill\fbox{\texttt{a := \ircmd{Mul} x, 2}}\hfill$\Rightarrow$\hfill\fbox{\texttt{a := Add x, x}}\hfill\mbox{}\\[1ex]
      \bi
      \ii Arithmetische Operationen haben unterschiedliche theoretische Komplexitäten
      \ii Multiplikation: $\mathcal{O}(n\cdot\log(n)\cdot\log(\log(n)))$ (FFT) vs. Addition: $\mathcal{O}(n)$
      \ii Ausdrucksstärke: Potenzierung $\gg$ Multiplikation $\gg$ Addition $\gg$ Bit-Shift
      \ei
    }\medskip
    \ii<3-> \structure{Technische Umsetzung}: Wende Ersetzungsregeln auf jede Instruktion an{
      \bi
      \ii \structure{Ersetzungsmuster} gibt Bedingungen vor, die Operanden erfüllen müssen
      \ii Ersetze die Instruktion im umgebenden Basisblock
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[fragile]{Algebraische Identitäten: Beispielhafte Ersetzugsmustern}
    \def\Var#1{\colorbox{safegreen!40}{#1}}
    \def\Const#1{\colorbox{badbee!40}{#1}}
    \def\Label#1{\colorbox{luhblue!40}{#1}}

    \centering
    \OrangeBox{Variablen: \Var{A}, Konstanten: \Const{x}, Labels: \Label{L}}\\[1ex]

    { \ttfamily
      \begin{tabular}{l|c|l}\toprule
        Orginal                                        & Bedingungen      & Ersetzung                              \\\midrule
        \multicolumn{3}{l}{\structure{Null-Operationen}}                                             \\
        \hspace{2em}\Var{A} := \ircmd{Add} \Var{B}, \Const{0}   & --               & \Var{A} := \ircmd{Assign} \Var{B}  \\
        \hspace{2em}\Var{A} := \ircmd{Mul} \Var{B}, \Const{1}   & --               & \Var{A} := \ircmd{Assign} \Var{B}  \\
        \hspace{2em}\Var{A} := \ircmd{Sub} \Var{B}, \Var{B}     & --               & \Var{A} := \ircmd{Assign} \Const{0}  \\\midrule
        \multicolumn{3}{l}{\structure{Konstantenfaltung}}                                             \\
        \hspace{2em}\Var{A} := \ircmd{Add} \Const{b}, \Const{c}    & --               & \Var{A} := \ircmd{Assign} \Const{b+c}  \\
        \hspace{2em}\ircmd{IfGoto} \Const{x}, \Label{A}, \Label{B} & \Const{x}!=0     & \ircmd{Goto} \Label{A}                 \\
        \hspace{2em}\ircmd{IfGoto} \Const{x}, \Label{A}, \Label{B} & \Const{x}==0     & \ircmd{Goto} \Label{B}                 \\\midrule
        \multicolumn{3}{l}{\structure{Strength-Reduction}}                                            \\
        \hspace{2em}\Var{A} := \ircmd{Pow} \Var{B}, \Const{2}      & --               & \Var{A} := Mul \Var{B}, \Var{B}        \\
        \hspace{2em}\Var{A} := \ircmd{Mul} \Var{B}, \Const{n}      & \Const{n}==$2^x$ & \Var{A} := LShift \Var{B}, \Const{x} \\
        \bottomrule
      \end{tabular}
    }
  \end{frame}
#+end_src

#+begin_src latex
  %%ONLY%%
  \begin{frame}{Konstanten- und Kopiepropagation}
    \begin{columns}
      \begin{column}{0.35\textwidth}
        \btAnimation[width=\textwidth]{range=1-3:<1->,3:<4->}{fig/09-cvp}
      \end{column}\hfill
      \begin{column}{0.60\textwidth}
        \begin{btBlock}{}\small
          Durch die einfache Codeerzeugung und bei der Optimierung enstehen konstante oder redundante Zuweisungen.
        \end{btBlock}
      \end{column}
    \end{columns}
    \medskip

    \bi
    \ii<3-> Propagation bekannter Werte durch einen Basisblock {
      \bi
      \ii Zum Zeitpunkt einer Zuweisung werden rechte und linke Seite äquivalent.
      \ii Operanden-Ersetzung in den folgenden Instruktionen
      \ii \ALERT{Aber}: Wir dürfen nur solange ersetzen, wie die Äquivalenz sicher ist.
      \ei
    }\medskip
    \ii<4-> \structure{Intuition} für die Propagation von Konstanten und Werten {
      \bi
      \ii Iteration über die Instruktionen eines BBs, Mitführen einer Äquivalenzliste
      \ii Zuweisungen etablieren eine neue Äquivalenz zwischen LHS und RHS
      \ii Andere Schreibzugriffe, die eine Variable verändern, löschen Äquivalenzen
      \ii Bei Lesezugriffen, wird die Äquivalenzliste befragt und ggf. ersetzt.
      \ei
    }
    \ei



  \end{frame}
#+end_src

* Optimierung des Kontrollflusses

* Elimination toter Instruktionen
