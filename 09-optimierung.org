#+TITLE: Programmiersprachen und Übersetzer
#+SUBTITLE: 09 - Optimierung
#+SETUPFILE: setup.org
#+INCLUDE: export-prologue.org
#+PROPERTY: header-args:latex :tangle yes :noweb yes :tangle-macros yes :tangle-prologue topic :tangle-epilogue endtopic :exports none

#+NAME: topic
#+BEGIN_SRC latex :tangle no
\psuSectionStart{{{{property(ITEM)}}}}{{{{n(block)}}}}
#+END_SRC

#+NAME: endtopic
#+BEGIN_SRC latex :tangle no
\psuSectionStop{{{{property(ITEM)}}}}{{{{n(block,-)}}}}
#+END_SRC

* Gedanken zu dieser Vorlesung                                     :noexport:
- Was darf Optimierung machen?
- Block-Lokale Optimierungen
  - Konstantenfaltung
  - Konstanten- und Kopiepropagation
  - Alias-Problematik
- Optimierung des Kontrollflusses
  - Redundante Jumps entfernen
  - Blöcke verschmelzen
- Müll aufräumen
  - Dead-Code Elimination
  - Dead-Store Elimination

* Was leistet die "Optimierung"?
:PROPERTIES:
:CUSTOM_ID: 08-einleitung
:END:

#+begin_src latex
  \subtitle{{{{subtitle()}}}}
  \begin{frame}
    \maketitle
  \end{frame}

  \begin{frame}{Einordnung in die Vorlesung: Optimierung}
    \begin{center}
      \includegraphics[page=7,width=0.9\linewidth]{fig/01-overview-small}
    \end{center}
    \bi
    \ii \structure{Hadwareunabhängige Optimierung} auf dem Zwischencode {
      \bi
      \ii IR-Code wurde \alert{ohne Rücksicht} auf die effizienzte Ausführbarkeit erstellt.
      \ii \structure{Effektive Entwickler}: Welche Arbeiten kann er dem Optimierer überlassen.
      \ii \structure{Effiziente Entwickler}: Wie lege ich dem Optimierer keine Steine in den Weg.
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[t,fragile]{Motivation: Da geht noch was!}
    \vspace{-2em}
    \begin{columns}[t]

    
      \begin{onlyenv}<1-2>
        \begin{column}{0.49\textwidth}
          \begin{code}[tag=L0]
          \lstinputlisting[style=lzero]{lst/09-example.l0}
        \end{code}
      
        Bei genauer Betrachtung, sehen wir, dass dieses Programm \ALERT{immer 0} zurück geben wird.

        \bigskip
        \uncover<2>{Dafür wird echt viel gerechnet!}
      \end{column}

    \end{onlyenv}
    \begin{onlyenv}<3->
      \begin{column}{0.49\textwidth}
        \mbox{}\par\bigskip
        \enquote{Der Übersetzer schaut genau hin}
        \medskip
        \be
        \ii {Konstante Auswertung} {
          \\[0.5ex]\enquote{Bekanntes Vorrausberechnen}\\[0.5ex]
          \bi
          \ii<4-> Arithmetische Berechnungen
          \ii<5-> Konstante Sprungbedingungen
          \ei
        }
        \ii<6-> {Konstanten- und Kopiepropagation}
        \ii<7-> Goto-auf-Goto  eliminieren
        \ii<8-> {Dead-Code Elimination}
        \ii<9-> {Basic-Block Merge}\\[2ex]
        \ii<10-> \ldots repeat, until no change.
        \ee
      \end{column}
    \end{onlyenv}
    \begin{column}<2->{0.49\textwidth}\centering
      \only<1-3>{\btAnimation[height=0.9\textheight,width=\textwidth,keepaspectratio]{raisebox,1:<1->}{fig/09-example-unoptimized}}%
        \only<4>{\btAnimation[height=0.9\textheight,width=\textwidth,keepaspectratio]{raisebox,1:<1->}{fig/09-example-cf1}}%
        \only<5>{\btAnimation[height=0.9\textheight,width=\textwidth,keepaspectratio]{raisebox,1:<1->}{fig/09-example-cf2}}%
        \only<6>{\btAnimation[height=0.9\textheight,width=\textwidth,keepaspectratio]{raisebox,1:<1->}{fig/09-example-cvp}}%
        \only<7>{\btAnimation[height=0.9\textheight,width=\textwidth,keepaspectratio]{raisebox,1:<1->}{fig/09-example-jumps}}%
        \only<8>{\btAnimation[height=0.9\textheight,width=\textwidth,keepaspectratio]{raisebox,1:<1->}{fig/09-example-dce}}%
        \only<9>{\btAnimation[height=0.9\textheight,width=\textwidth,keepaspectratio]{raisebox,1:<1->}{fig/09-example-merge}}%
        \only<10>{\btAnimation[width=0.5\textwidth]   {raisebox,1:<1->}{fig/09-example-repeat}}
      \end{column}
    \end{columns}
  \end{frame}
#+end_src

* Vorraussetzungen und Ziele
#+begin_src latex
  %%ONLY%%
  \dividerframe{Ziele und Vorraussetzungen\\der Optimierung}

  \begin{frame}{Ziele bei IR-Level Optimierung}
    \begin{btBlock}[type=example]{Allgemeine Optimierungsziele}
      Ziel jeder Programm-Optimierung ist es, die \textbf{nicht-funktionalen} Eigenschaften, unter Beibehaltung der \textbf{erwarteten Funktionalität}, zu verbessern.
    \end{btBlock}

    \bi
    \ii Nicht-Funktionale Eigenschaften nach denen wir optimieren {
      \bi
      \ii \structure{Ausführungszeit}: Abbildung auf weniger oder schnellere Instruktionen
      \ii \structure{Programmgröße}: Veringerung der Binärgröße (eingebettete Systeme)
      \ii \structure{Energieverbrauch}: Verlängerung der Batterielaufzeit
      \ei
    }\medskip
    \ii<2-> Auf der Hardware-unabhängigen IR-Ebene fehlt das \alert{Kostenmodell}{
      \bi
      \ii Wir wissen nicht wie schnell, groß, oder Energie-hungrig einzelne Instruktionen auf der Zielplattform sein werden.
      \ii \structure{Heuristik}: \enquote{Speicherzugriffe und Sprünge sind teuer.}
      \medskip
      \ii<3->[$\Rightarrow$] Generelle Reduktion der Anzahl der Instruktionen und Basisblöcke
      \ei
    }
    \ei
  
  \end{frame}

  \begin{frame}{Wiederholung (1. Vorlesung): Korrekte Übersetzung}
    \bi
    \ii Die Programmiersprache definiert die \alert{beobachtbaren} Zustände. {
      \bi
      \ii Ein- und Ausgabe ist immer beobachtbar, oft aber auch Teile des Speichers
      \ii Bei C: Nur das Schreiben von globalen Variablen, nicht aber von lokalen.
      \ei
    }\bigskip
    \ii Ein \advantage{korrekter} Übersetzer erhält alle beobachtbaren Zustände.{
      \bi
      \ii Parsing+Code-Erzeugung ist eine \textbf{Abbildungsfunktion}:\\[2ex]{
        \includegraphics[page=2,width=0.9\textwidth]{fig/01-zustand}
      }
      \ei
    }\bigskip
    \ii[$\Rightarrow$] Funktionen \advantage{dürfen verändert werden}, solange sie außen gleich aussehen {
      \bi
      \ii Im IR-Code: lokalen und temporären Variablen sind nicht sichtbar
      \ii Von Außen sichtbar sind: \ircmd{Store}, \ircmd{Call}, \ircmd{Return}
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{Phasen und Umfang der Optimierung}
    \begin{center}
      \includegraphics{fig/09-analyse}
    \end{center}
    \bi
    \ii Optimierung besteht immer aus \textbf{zwei Schritten} {
      \bi
      \ii \structure{Analyse} des Programms generiert Wissen anhand dessen wir entscheiden können, ob wie \alert{eine Optimierung anwenden dürfen}.
      \ii \structure{Transformation} in ein semantisch äquivalentes, aber \enquote{besseres} Programm.
      \ei
    }\medskip
    \ii Optimierungen analysieren und transformieren \textbf{Programmausschnitte} {
      \bi
      \ii Wie groß ist der Ausschnitt über den wir wissen extrahieren?
      \ii Instruktionen, einzelne Basisblöcke, eine ganze Funktion, eine Aufrufhierarchie, mehrere interagierende Threads
      \ei
    }
    \ei
  \end{frame}
#+end_src

* Block-lokale Optimierungen

* Optimierung des Kontrollflusses

* Elimination toter Instruktionen
