#+TITLE: Programmiersprachen und Übersetzer
#+SUBTITLE: 03 - Typen
#+SETUPFILE: setup.org
#+INCLUDE: export-prologue.org
#+PROPERTY: header-args:latex :tangle yes :noweb yes :tangle-macros yes :tangle-prologue topic :tangle-epilogue endtopic :exports none

#+NAME: topic
#+BEGIN_SRC latex :tangle no
\psuSectionStart{{{{property(ITEM)}}}}{{{{n(block)}}}}
#+END_SRC

#+NAME: endtopic
#+BEGIN_SRC latex :tangle no
\psuSectionStop{{{{property(ITEM)}}}}{{{{n(block,-)}}}}
#+END_SRC

* Gedanken zu dieser Vorlesung                                     :noexport:

Was lernt man aus dieser Vorlesung für die Ziele effektiv und effizient?
 - Typen sind immer da. Schreibt man sie auf, werden sie Freunde. [effektiv]
 - Typen sind _die_ Informationsquelle für den Übersetzer.        [effizient]


* Was ist ein "Typ"?
:PROPERTIES:
:CUSTOM_ID: 03-einleitung
:END:

#+begin_src latex
  \subtitle{{{{subtitle()}}}}
  \begin{frame}
    \maketitle
  \end{frame}

  \begin{frame}{Wieso sollte ich mich mit Typen beschäftigen?}
    \begin{center}
      \includegraphics[page=10,width=0.6\linewidth]{fig/01-overview-small}
    \end{center}
    \bi
    \ii Typen sind das Rückgrat moderner Programmiersprachen. {
      \bi
      \ii Je mehr das Typsystem abfängt, desto weniger muss man denken.
      \ii Das Typsystem ist eine wichtige Quelle für automatische Optimierungen.
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[fragile]{Was bieten einem Typen?}
    \bi
    \ii Typen bieten \textbf{Kontext} und transportieren Informationen quer zum AST.{
      \bi
      \ii Ohne Typen:  Wir müssten die Operation immer ganz genau angeben.\\
          {
            \hfill\codeinline{var a,b; ... float32_add(a, b)}
            \hfill\codeinline[style=C,morekeywords={int32_t}]{int32_t a, b; .... a+b}
            \hfill\mbox{}
          }
          \ii Mit Typen: Der Übersetzer wählt die passende Operation entsprechend.
      \ei
    }\bigskip
    \ii Typen \textbf{schützen vor Bugs} und verhindern invalide Aktionen. {
      \bi
      \ii \codeinline{Cat k1; ... k1 = Dog();} $\Rightarrow$ \enquote{Type mismatch: Cannot assign 'Dog' to 'Cat'}\\[0.5ex]
      \ii Mit Typen macht ein Programmierer Zusicherungen über eine Objekt.
      \ei
    }
    \bigskip
    \ii Typen \textbf{verbessern die Lesbarkeit} von Code und sind Dokumentation. {
      \bi
      \ii Mit statisch Typen kommunizieren wir Intention und angedachte Verwendung.
      \ii Eine gute API ist bereits anhand der Typnamen verständlich:{\\[1ex]
        \begin{center}
          \codeinline<1>[style=C]{____ regex_match(________, ___________, _____________)}%
          \codeinline<2->[style=C,morekeywords={bool,regex_t,regex_flags_t}]{bool regex_match(regex_t*, const char*, regex_flags_t)}
        \end{center}
      }
      \ei
    }
    \ei
    \onslide<3->{
      \medskip
      \Large \alert{$\Rightarrow$ Typen sind Freunde und Helfer in der Not!}
    }
  \end{frame}

  #+end_src
- Einordnung in die Vorlesung
- Vorteile von Typen

#+begin_src latex
\dividerframe{Grundbegriffe\\für\\Typen}
  \begin{frame}[fragile]{Was bedeutet ein Typ? Wie interpretieren wir Typen?}
    \bi
    \ii \structure{Strukturell}: Es gibt eingebaute und daraus kombinierte Typen.{
      \bi
      \ii Eingebaute Typen: \lstinline[style=C,morekeywords={int32_t,bool}]{bool, int, int32_t, float, double, char, ...}
      \ii Kompositionen: Referenzen (\codeinline|char *|= Pointer auf \texttt{char}), Arrays (\codeinline|int[10]|).
      \ii \enquote{Wie baue ich meine Datenstrukturen aus einfacheren Datentypen?}
      \ei
    }\medskip
    \ii \structure{Denotationell}: Typen $T$ sind Mengen von Objekten. {
      \bi
      \ii Der Typ \codeinline{uint16_t} \emph{ist} die Menge aller positiver Ganzahlen $0\le x < 65536$.
      \ii Typen sind Prädikate über die Mengen-Mitgliedschaft \siginline{T}{object}{bool}
      \ii \enquote{Welche Regeln und Invarianten gelten für die Objekte hinter diesem Typ?}
      \ei
    }\medskip
    \ii \structure{Abstraktional}: Ein Typ ist ein Interface von konsistenten Operationen.{
      \bi
      \ii \codeinline{int32_t} ist das Interface $\{\texttt{+}_{int32_t}, \texttt{-}_{int32_t}, \texttt{*}_{int32_t}, \ldots\}$
      \ii Der Typ \codeinline{stack_t} besteht aus drei Operationen: \{\texttt{push()}, \texttt{pop()}, \texttt{empty()}\}
      \ii \enquote{Mit welchen Operationen kann ich Objekte dieses Typs manipulieren?}
      \ei
    }
    \ei
    \onslide<2->{
      \bigskip\alert{Alle drei Sichtweisen sind nützlich und keine ist richtiger als die andere.}
    }

  \end{frame}


  \begin{frame}[t,fragile]{Typausdrücke: Strukturelle Notation für Typen}
    \bi
    \ii Wir könnnen Typen strukturell als \structure{Typausdrücke} aufschreiben.{
      \bi
      \ii Komplexere Typen durch die wiederholte Anwendung von \structure{Typkonstruktoren}.\\
      $T$ ist die Menge aller valider Typausdrücke. (Rekursiv!){
        \begin{center}\smallskip
          \signature{pair}{$T \times T$}{T}
  \smallskip
        \end{center}
      }
      \ii \enquote{Ein Paar aus Ganzzahl und einer Menge von Zeichen}
      \ii Mit Typausdrücken wird das formeller: \typeinline{pair(int, set(char))}
      \ei
    }\bigskip
    \ii Typausdrücke sind \alert{Bäume} und Konstruktoren erzeugen innere Knoten.{
      \begin{columns}
        \begin{column}{0.84\textwidth}
          \bi
          \ii Typausdrücke sind strukturell sehr ähnlich zu AST Unterbäumen
          \ii Umwandlung von AST Knoten durch rekursiven Besucher
          \ii Nicht nur Built-In Typen als Blätter: \typeinline{array(int, 2)}
          \ei
        \end{column}\hfill
        \begin{column}{0.15\textwidth}
          \begin{tikzpicture}[small tree,transform canvas={scale=0.8}]
            \node {\emph{pair}}
            child { node {int} }
            child { node {set}
              child { node {char} }
            };
          \end{tikzpicture}
        \end{column}
      \end{columns}
    }
   \ei
  \end{frame}
  #+end_src
- Struktur, Denotationell, Abstationell
- Typausdrücke

#+begin_src latex
  \begin{frame}[fragile]{Äquivalenz von Typen}
    \bi
    \ii Oft gestellte Frage bei Sprachen: Wann sind zwei Typen äquivalent?{
      \bi
      \ii \textbf{Äquivalenz ist}: Ununterscheidbarkeit unter einem bestimmten Aspekt.
      \ii \sample{Beispiel}: "abc" und "foo" sind äquivalent im Speicherverbrauch.
      \ii Unterschiedliche Sprachen verwenden unterschiedliche Äquivalenzen!
      \ei
    }\bigskip
    \ii<2-> \structure{Strukturelle Äquivalenz}: Gleicher Typausdruck = Gleicher Typ{
      \bi
      \ii Typnamen sind nur Abkürzung für den definierten Typausdruck
      \ei
      \vspace{-2ex}
      \begin{columns}[t]
        \begin{column}{0.49\textwidth}
          \begin{code}[tag=Pascal]
            \begin{pascal}
              type R1 = record
                 a, b : integer;
              end;

              type R2 = record
                 a : integer;
                 b : integer;
              end;
            \end{pascal}
          \end{code}

          Beide Definition liefern in Pascal:
          \typeinline{record(("a", integer), ("b", integer))}
        \end{column}\hfill
        \begin{column}<3->{0.49\textwidth}
          \begin{code}[tag=Pascal]
            \begin{pascal}
              type student = record
                 name: string;
                 age: integer;
              end;

              type school = record
                 name: string;
                 age: integer;
              end;
            \end{pascal}
          \end{code}

          Mit reiner struktureller Äquivalenz sind beide Typen unterscheidbar.
          Sollten sie das sein?
        \end{column}
      \end{columns}

    }
    \ei
  \end{frame}

  \begin{frame}[t,fragile]{Namensäquivalenz von Typen}
    \bi
    \ii Rekursive Typdefinitionen sind ein Problem für strukturelle Äquivalenz.{
      \bi
      \ii Ersetzt man jedes Auftreten eins Typnamens durch den Typausdruck, kommt man zu einer endlos tiefen Verschachtelung:
      \ei
      \vspace{-2ex}
  \begin{columns}[t]
    \begin{column}{0.49\textwidth}
      \begin{code}[tag=C]
        \begin{C}
          struct list {
            struct list *next;
          }
        \end{C}
      \end{code}
    \end{column}\hfill
    \begin{column}{0.49\textwidth}
      \begin{code}[background color=typecolor]
        \begin{py}
          record(("next", pointer(
            record(("next", ...)))
          ))
        \end{py}
      \end{code}
    \end{column}
  \end{columns}
    }\bigskip
    \ii<2-> \structure{Namensäquivalenz}: Jede Typdefinition erzeugt einen neuen Typen{
      \begin{quote}
        Wenn der Enwickler sich den Aufwand treibt zwei Definitionen zu schreiben, wird er schon Unterschiedliches gemeint haben.
      \end{quote}

      \bi
      \ii Berechnung der Typausdrücke stoppt an benannten Typen.\\
          \typeinline{type list = record(("next", pointer(type("list"))))}
      \ei

      \hspace{1ex}\includegraphics[width=0.7\textwidth]{fig/03-name-equivalence}
    }
    \ei
  \end{frame}

  \begin{frame}[fragile]{Typnamen und Typaliase}
    \bi
    \ii Mit benannten Typen und Namensäquivalenz: Aliasproblematik {
      \bi
      \ii \codeinline{typedef old_type new_type} (C): Sind dies zwei Namen für den gleichen Typ?
      \ii Nach strikter Namensäquivalenz: Zwei echt unterschiedliche Typen.\\[.5ex]{
        \begin{code}[tag=C]
          \begin{C}
            typedef double celsius_t;
            typedef double fahrenheit_t;
            void heating_set(celsius_t);

            // Namensäquivalenz:   Übersetzerfehler
            // Strukturäquivalenz: Gegrillte Zimmerpflanzen
            fahrenheit_t target = (fahrenheit_t) 100;
            heating_set(target);
          \end{C}
        \end{code}
      }
      \ii C macht nur für \codeinline[style=C]{struct}s Namensäquivalenz, ansonsten Strukturäquivalenz
      \ei
    }\medskip
    \ii<2> Manche Sprachen: Sowohl Typaliase als auch \textbf{abgeleiteten Typen}\\[.5ex]{
      \begin{code}[tag=Haskell]
        \begin{haskell}
          type    X =       Char    -- X ist nur ein zweiter Name
          newtype Y = MakeY Char    -- Y ist ein separater Typ
                                    -- MakeY :: Char -> Y
          a :: X;   a = 'a'
          b :: Y;   b = (MakeY 'a')
        \end{haskell}
      \end{code}
    }
    \ei
  \end{frame}
  #+end_src
- Wie vergleichen wir Typen?
  - Gleichheit
  - Namensgleicheit und Strukturgleichheit
  - Typalias und abgeleiteter Typ

* Klassen von Typen

#+begin_src latex
  \dividerframe{Klassen von Typen}

  \begin{frame}[fragile]{Skalare Typen: Aufzählungen und Zahlen}
    \bi
    \ii Skalare Typen beschreiben nicht-weiter zerlegbare Objekte{
      \bi
      \ii Kein Teil eines Skalaren Objekts macht eigenständig Sinn.
      \ii Diskreter Wertebereich, oft mit totaler Ordnung
      \ei
    }\bigskip
    \ii<2-> Aufzählungen oder Enumerations (\codeinline[style=C]{enum{wert0, wert1, ...}}){
      \bi
      \ii Explizite Angabe des Werteberreichs: \hfill\codeinline{enum {red, green, blue}}
      \ii Wahrheitswerte sind ein häufiger Spezialfall: \hfill\codeinline{typedef enum{false, true} bool;}
      \ii Closed-World Assumption ist manchmal schädlich: \hfill\codeinline{enum {female, male}}
      \ei
    }\bigskip
    \ii<2-> Numerische Typen: Ganzzahlen, Fliesskommazahlen, und Dezimalzahlen{
      \bi
      \ii Endlicher, aber meist sehr großer Wertebereich (\codeinline{uint32_t}: $0 \le n < 2^{32}$)
      \ii Speicherung mit (\codeinline{signed}) und ohne (\codeinline{unsigned)} Vorzeichen
      \ii Sehr oft Übereinstimmung mit den Wortbreiten der realen Maschine
      \ii Manche Sprachen erlauben explizite Einschränkung des Wertebereichs:\\[.5ex]{
        \begin{code}[tag=Pascal]
          \begin{pascal}
            type water_temperature = 273..373 (* Kelvin *)
          \end{pascal}
        \end{code}
      }
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[t,fragile]{Skalare Typen: Zeiger und Funktionen}
    \bi
    \ii Zeiger sind gespeicherte Referenzen auf Objekte vom Basistyp {
      \begin{center}
        \includegraphics[width=0.5\textwidth]{fig/03-pointers}
      \end{center}
      \bi
      \ii Minimales Interface (abstraktional): \siginline{dereference}{pointer(T)}{T}
      \ii Verschiedene Zeigertypen geben unterschiedliche Referenzen{
        \bi
        \ii Universeller Zeiger in C garantiert nichts (\codeinline{T*})
        \ii C++ Referenzen zeigen immer auf valides Objekt (\codeinline[style=CPP]{T&})
        \ii Für jedes Objekt, maximal ein \textbf{eindeutiger Zeiger} (\codeinline[style=CPP]{std::unique_ptr<T>})
        \ei
      }
      \ei
    }\medskip
    \ii<2-> Funktionstypen beschreiben den Rückgabetyp und die Parametertypen\\{
      \bi
      \ii Strukturell: Typausdruck für \codeinline{strlen} ist \typeinline{func(size\_t, pointer(char))}
      \ii Abstraktional: \siginline{call}{func(R,\ldots)}{R} (\enquote{Funktionen sind aufrufbar})
      \ii Denotational: Maschinencode der Funktion ist ein Objekt dieser Typen.
      \ei
    }
    \ei
  \end{frame}
#+end_src

- Skalare Typen
  - bool
  - enums
  - integer/floats & subrange types
  - Funktionstypen

#+begin_src latex
  \begin{frame}[fragile]{Zusammengesetzte Typen: Strukturen}
    \begin{columns}
      \begin{column}{0.49\textwidth}
        \begin{code}[tag=C]
          \begin{C}
            typedef struct {
              int    feld_1;
              double feld_2;
            } foo_t;
          \end{C}
        \end{code}
      \end{column}\hfill
      \begin{column}<2->{0.49\textwidth}
        \begin{code}[tag=C]
          \begin{C}
            union {
              int    feld_1;
              double feld_2;
            };
          \end{C}
        \end{code}
      \end{column}
    \end{columns}

    \bi
    \ii Records subsumieren endlich viele, jedoch heterogen getypte, Elemente{
      \bi
      \ii Die einzelnen Elemente heißen Felder und haben einen Typ und einen Namen
      \ii Namen müssen normalerweise statische Bezeichner sein
      \ii Minimales Interface: \siginline{dot\_operator}{record(..., (name, T), ...) $\times$ name}{T}
      \ei
    }\medskip
    \ii Records kommen in fast allen Sprachen in diversen Geschmäckern vor: {
      \bi
      \ii Java Klassen sind auch Records, aber noch viel viel mehr...
      \ii Fortran90: Der Übersetzer darf Felder umsortieren um Speicher zu sparen
      \ii Haskell: Tupel sind so etwas wie Records ohne Feldnamen
      \ei
    }
    \medskip
    \ii<2-> Bei varianten Records (Unions) ist maximal ein Feld gültig {
      \bi
      \ii Alle Felder des Records nehmen den gleichen Speicher ein.
      \ii Unions sind oft die einzige (erlaubte) Möglichkeit das Typsystem zu umgehen
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[fragile]{Zusammengesetzte Typen: Sequenzen}
    \begin{columns}[b]
      \begin{column}{0.49\textwidth}
        \begin{code}[tag=Haskell]
          \begin{haskell}[basicstyle=\scriptsize\ttfamily]
            a = [2, 3] -- `\typeinline{list(int)}`
            b = 1 : a  -- = cons(1, [2, 3])
            T = tail b -- `\typeinline{list(int)}`, [2,3]
            H = head b -- `\typeinline{int}`, 1
          \end{haskell}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \begin{code}[tag=C]
          \begin{C}
            struct list {
              int          value;
              struct list *next;
            };
          \end{C}
        \end{code}
      \end{column}
    \end{columns}

    \bi
    \ii Sequenztypen sind homogen getypte und (un)geordnete Container  {
      \bi
      \ii Bekanntester Sequenztyp ist die (einfach verkettete) Liste: \typeinline{list(T)}
      \ii Minimales Interface: Nur Zugriff auf das erste Element und die Restelemente:\\
         \siginline{head}{list(T)}{T} \siginline{tail}{list(T)}{list(T)}
      \ei
    }\medskip
    \ii Listen sind rekursive definiert und werden oft mit Records nachgebaut{
      \bi
      \ii Die Restliste ist selbst wieder eine Liste oder \codebox{nil} (Leere Liste)
      \ii Mittels einem rekursivem Record kann man Listentypen emulieren
      \ei
    }\medskip
    \ii Abweichungen von strikter Homogenität und Einfügeordnung möglich{
      \bi
      \ii Python Listen (\codeinline{[1, "x", 3.4]}) garantieren nur minimalen Typ: \typeinline{list(object)}
      \ii Sets sind ungeordnete Mengen (Java: \codeinline[style=Java]{HashSet<Integer>})
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[fragile]{Zusammengesetzte Typen: Abbildungen}
      \begin{columns}[b]
        \begin{column}{0.49\textwidth}
          \begin{code}[tag=C]
            \begin{CPP}[basicstyle=\scriptsize\ttfamily]
              // `\typeinline{array(int,10)}`, `\typeinline{map(int,int)}`
              int rgb[10];
              // `\typeinline{map(int, map(int, int))}`
              char matrix[20][20];
          \end{CPP}
        \end{code}
      \end{column}\hfill
      \begin{column}<2->{0.49\textwidth}
        \begin{code}[tag=C++]
          \begin{CPP}[basicstyle=\scriptsize\ttfamily]
            std::map<std::string, int> x;
            x["y"] = 23;
            x["z"] = x.at("y") + 100;
          \end{CPP}
        \end{code}
      \end{column}
    \end{columns}

    \bi
    \ii Abbildungstypen: Zuordnung zwischen einem Index- und einer Wertetyp{
      \bi
      \ii Indexmenge und Wertemengen sind homogen getypt
      \ii Vordefiniert-beschränkte oder dynamisch-wachsende Abbildungsgröße
      \ii Wahlfreier Zugriff mit dynamischen Index \siginline{get}{map(K, V) $\times$ K}{V}
      \ei
    }\medskip
    \ii Arrays sind die einfachste (und effizienteste) Abbildung {
      \bi
      \ii Indextyp ist immer \typeinline{int}, Indexmenge ist zusammenhängend und beschränkt
      \ii Effizienter Elementzugriff und dichte Speicherung möglich
      \ii Manche Sprachen erlauben variabel lange Zeilen in mehrdimensionalen Arrays
      \ei
    }\medskip
    \ii<2-> Assoziative Arrays wachsen und erlauben beliebige Indextypen{
      \bi
      \ii Namen: Dictionary (Python), Hash (Ruby), Table (Lua), Map (Rust, C++)
      \ii In Skriptsprachen wird oft die Homogenität aufgegeben: \typeinline{map(object,object)}
      \ei
    }
    \ei

  \end{frame}

#+end_src
- Zusammengesetzte Typen
  - Pointer
  - Records
  - Unions
  - Arrays
  - Sets & Listen

FIXME: - Was tun, wenn meine Sprache einen Typ nicht anbietet? Minimale Wunsch ist: Record+Struct oder

* Polymorphismus
#+begin_src latex
%%ONLY%%
  \dividerframe{Polymorphismus}

  \begin{frame}[fragile]{Polymorphismus macht Code flexibel}
    \textbf{Bisher:} Zwei Typen sind entweder gleich oder haben nichts gemein.
    \bigskip

    \bi
    \ii Typen haben jedoch oft gemeinsame Aspekte und sind irgendwie ähnlich{
      \bi
      \ii Strukturell:   \codeinline[style=C]{struct point2D {int x,y}} \codeinline[style=C]{struct point3D {int x,y,z}}
      \ii Denotational:  \typeinline{uint8\_t} $\in$ \typeinline{uint16\_t} $\in$ \typeinline{uint32\_t} $\in$ \typeinline{uint64\_t}
      \ii Abstractional: \siginline{lengthIntList}{list(int)}{int} \siginline{lengthFloatList}{list(float)}{int}
      \ei
    }\medskip
    \ii \structure{Monomorphe Typsysteme} beachten nur Äquivalenz und sind \ALERT{inflexibel} {
      \bi
      \ii Codeduplikaten: \codeinline{printX_2D()}, \codeinline{isEven_u8()}, \codeinline{lenghtFoobarList()}
      \ii Ständige explizite Konvertierungen zwischen ähnlichen Typen:\\
          \codeinline[style=C]{struct point3D x; struct point2D x_ = {x.x, x.y};}
      \ei
    }\medskip
    \ii Polymorphismus erlaubt es ähnliche anstatt nur gleicher Typen zu haben{
      \bi
      \ii Polymorpher Code darf sich nur auf die Gemeinsamkeiten verlassen
      \ii Subtypes: \enquote{Jeder 3D Punkt ist auch ein 2D Punkt}
      \ii Parametrisch: \enquote{Funktion verarbeitet alle Listen unabhängig vom Elementtyp}
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[fragile]{Typkompatibilität}
    \bi
    \ii Neben Typäquivalenz, brauchen wir auch noch die Typkompatibilität {
      \lstset{style=smaller}
      \begin{columns}
        \begin{column}{0.49\textwidth}
          \begin{code}[tag=C]
            \begin{C}[style=C,morekeywords={uint8_t, uint16_t, uint32_t}]
              uint16_t x = (uint8_t)10;
              uint32_t y = x + 13;
            \end{C}
          \end{code}
        \end{column}\hfill
        \begin{column}{0.49\textwidth}
          \begin{code}[tag=C++]
            \begin{CPP}[style=CPP,morekeywords={T1, T2}]
              T1 *x;
              T2 *y = x;
            \end{CPP}
          \end{code}
        \end{column}
      \end{columns}

      \medskip
      \structure{Substitution}:
      Kann ich \codeinline{T2 *} sicher durch \codeinline{T1 *} ersetzen?
    }\medskip
    \ii \enquote{Sicher} hat dabei viele unterschiedliche Interpretationen{
      \bi
      \ii Speicher: Die T1 Datenstruktur ist kompatibel zur T2 Datenstruktur.
      \ii Abstraktionen: T1 kann in jedem Context wie T2 verwendet werden.
      \ii Semantik: T1 verhält sich in jedem Context entsprechend wie T2.
      \ei
    }
    \ii<2> \alert{Kein} Typsystem kann alles abfangen und komplette Sicherheit bieten{
    \vspace{-2ex}
  \begin{columns}[t]
    \begin{column}{0.49\textwidth}
      \begin{code}[tag=Base.java]
        \begin{java}
          class Base {
            public MyObj alloc() {
              return new MyObj(23);
            };
          }
        \end{java}
      \end{code}

    \end{column}\hfill
    \begin{column}{0.49\textwidth}
      \begin{code}[tag=Derived.java]
        \begin{java}
          class Derived extends Base {
            public MyObj alloc() {
              eraseUserDisk();
              return null;
            };
          }
        \end{java}
      \end{code}

    \end{column}
  \end{columns}
  }
  \ei
  \end{frame}

  #+end_src

#+begin_src latex
    %%ONLY%%
    \begin{frame}{Arten des Polymorphismus}
      \btAnimation[width=\textwidth]{center, padding, range=1-2:<1->}{fig/03-polymorphismus}
    \end{frame}

    \begin{frame}[t,fragile]{Inklusionspolymorphismus: Subtypen}
      \begin{btBlock}[type=alert]{\ALERT{Ziel:} Behandlung unterschiedlicher Typen \textbf{ohne} Konvertierung}
        Der Code für Supertypen solls auch Subtypen verarbeiten können.
      \end{btBlock}

      \begin{btBlock}{Subtypen sind Subsets: $S \subseteq T$}
        Da ein Typ T die Menge seiner Objekte (denotational), ist ein Subtyp S eine Untermenge vom (Super)typ T. Jedes S ist auch ein T.
      \end{btBlock}

      \bigskip
      \bi
      \ii<2-> \structure{Subranges}: Subtyping durch Einschränkung des Werteberreichs {
        \bi
        \ii Ada: \codeinline[]{subtype percent_t is integer range 0..100;}
        \ii Wer \codeinline{integer} verarbeiten kann, kann auch \codeinline{percent_t} verarbeiten.
        \ei

        \begin{code}[tag=Pascal]
          \begin{pascal}[style=smaller]
            type percent_t = 0..100;
            procedure PrintInteger(j : integer);
            ...
            var completed : percent_t;
            completed := 37;
            PrintInteger(completed);
          \end{pascal}
        \end{code}
      }
      \ei
    \end{frame}

    \begin{frame}[fragile]{Subtyping durch Vererbung (Strukturerweiterung)}

      \medskip

      \bi
        \ii Vererbung ist auch Subtyping, \emph{obwohl} Objekte unterschiedlich sind.{%
          \bi
          \ii Abgeleitete Klassen erben alle Felder der Elternklasse und fügen nur etwas zu. {
      \begin{columns}
        \begin{column}{0.49\textwidth}
          \begin{code}[tag=C++]
            \begin{CPP}[style=smaller]
              struct Base {
                int x;
              };
            \end{CPP}
          \end{code}\\
          \typeinline{type Base = record(("x", int))}
        \end{column}\hfill
        \begin{column}{0.49\textwidth}
          \begin{code}[tag=C++]
            \begin{CPP}[style=smaller]
              struct Derived : public Base {
                int y;
              };
            \end{CPP}
          \end{code}\\
          \typeinline{type Derived = record(("x", int), ("y", int))}
        \end{column}
      \end{columns}\medskip
          }
          \ii<2-> Wir können das \enquote{Vergessen} von Felder beim \codeinline{Derived} $\subseteq$ \codeinline{Base} erlauben.\\
               \ALERT{$\Rightarrow$}  \codeinline{Derived} ist ein Subtyp von \codeinline{Base}.
          \ei
        }\medskip
        \ii<3-> Bei C++ wird die Kompatibilität sofort am Assembler sichtbar.{
          \bi
          \ii Geerbte Felder werden \enquote{vorne} eingefügt: \codeinline{offsetoff(Derived, x) == 0}
          \ei
        \begin{columns}
          \begin{column}{0.49\textwidth}
            \begin{code}[tag=C++]
              \begin{CPP}
                int getX(Base* o) {
                  return o->x;
                }

                int getY(Derived* o) {
                  return o->y;
                }
              \end{CPP}
            \end{code}
          \end{column}\hfill
          \begin{column}{0.49\textwidth}
            \begin{code}[tag=RV32]
              \begin{asm}
                getX: # (Base * a0)
                   lw   a0, 0(a0)
                   ret

                getY: # (Derived * a0):
                   lw   a0, 4(a0)
                   ret
              \end{asm}
            \end{code}
          \end{column}
        \end{columns}
        }
        \ei
    \end{frame}

    \begin{frame}{Parametrischer Polymorphismus}
    \end{frame}

    \begin{frame}{Covarianz, Invarianz und Contravarianz}
    \end{frame}

#+end_src

#+begin_src latex
\begin{frame}{Type Traits}
\end{frame}

\begin{frame}{Rust: Type-Trait Objects}
\end{frame}
#+end_src



http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf
* Typsysteme in Programmiersprachen
#+begin_src  latex
  \begin{frame}{Typsysteme: Verwendung von Typen in der Sprache}
    \bi
    \ii Typsicherheit
    \ei

  \end{frame}

  \begin{frame}[fragile]{Typsysteme: Starke vs. Schwache Typisierung}
    \begin{center}\SAMPLE{\Large
      "Wie strikt forciert die Sprache ihr Typsystem?"
    }\end{center}

    \bi
    \ii Das Typsystem einer Programmiersprache heisst stark typisiert, wenn: {
      \be
      \ii Es gibt unterschiedliche Typen.
      \ii Implizite (automatische) Konvertierung nur zwischen ähnlichen Typen.
      \ii Explizite Typekonvertierungen sind der Regelfall.
      \ee
    }\bigskip
    \ii Python ist ein Beispiel für eine stärker typisierten Sprache. {
      \bi
      \ii Jedes Objekt hat genau einen Typ, der bei der Erstellung festgelegt wird.
      \ii Wenige implizite Konvertierung. Zum Beispiel: \texttt{int}$\rightarrow$\texttt{float}: \codeinline{1+4.5} $\Rightarrow 5.5$
      \ii Konvertierungen explizit sichtbar: \codeinline{int("23")} $\Rightarrow 23$, \codeinline{str([1,2])} $\Rightarrow$ \texttt{"[1, 2]"}
      \ei
    }\medskip
    \ii Beispiele für schwache Typisierung{
      \bi
      \ii TCL: Alles ist ein String. Jede Operation interpretiert den String anders.
      \ii PHP ($<7$): Implizite Konvertierung von \texttt{str}$\rightarrow$\texttt{int}: \codeinline{"23"+4}$\Rightarrow$ 27
      \ii C: Arrays werden, falls nötig, zu einem Pointer auf ihr erstes Element.
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[t,fragile]{Typsysteme: Statische vs. Dynamische Typisierung}
    \begin{center}\SAMPLE{\Large
      "Werden Typen statisch im Quellcode annotiert?"
    }\end{center}

    \bi
    \ii Statische Typisierung: C, C++, Rust, Java, Haskell,\ldots{
      \bi
      \ii Bei jeder Definition/Deklaration wird ein statischer Typ festgelegt.
      \ii Variablen können niemals ein Objekt falschen Typs beinhalten.
      \ii Variablen und Funktionen bekommen einen Typ: \codeinline{pair<int, int> foo}{
        \begin{center}
          \includegraphics[page=2,width=0.7\textwidth]{fig/03-static-types}
        \end{center}
      }
      \ei
    }\medskip
    \ii Dynamische Typisierung: Python, PHP, JavaScript, Lisp, \ldots {
      \bi
      \ii Variablen haben keine fest assoziierten Typen.
      \ii Nur die Objekte, die in den Variablen \enquote{leben}, haben eine Typ.
      \ei
      \begin{center}
        \includegraphics[page=1,width=0.7\textwidth]{fig/03-static-types}
      \end{center}
    }
    \ei
    \begin{overlaybox}<2>[draw=srared,ultra thick,drop shadow,inner sep=1em]
      Die Frage nach \enquote{Statisch} oder \enquote{Dynamisch} ist eine der wichtigsten Fragen bei Programmiersprachen und beim Übersetzerbau!\\[1ex]
      \begin{columns}
        \begin{column}{0.49\textwidth}
          \STRUCTURE{Statisch}
          \bii
          \ii Vor der Laufzeit.
          \ii Im Übersetzer.
          \ii Im Quellcode notiert.
          \ii Entscheidung ohne Ausführung.
          \ii Später Kostenlos.
          \eii
        \end{column}\hfill
        \begin{column}{0.49\textwidth}
          \STRUCTURE{Dynamisch}
          \bii
          \ii Während Laufzeit.
          \ii In der virtuellen Maschine.
          \ii Im Maschinenezustand.
          \ii Enscheidung bei Auführung.
          \ii Ausführungskosten.
          \eii
        \end{column}
      \end{columns}

    \end{overlaybox}
  \end{frame}

  \begin{frame}[fragile]{Typsysteme: Explizite vs. Implizite Typisierung}
      \begin{center}\SAMPLE{\Large
      "Muss ich alle statischen Typen hinschreiben?"
    }\end{center}

    \bi
    \ii Statische Typisierung erhöht die Menge an \emph{explizit} getippten Zeichen.{
      \begin{code}[tag=C++03]
        \begin{CPP}
          std::vector<int> vec;
          for (std::vector<int>::iterator it : vec) {...}
        \end{CPP}
      \end{code}
      \bi
      \ii Teilweise wäre der Datentyp aus dem Kontext heraus klar.
      \ii Beim Programmierer entsteht das Gefühl von Boilerplate:\\
      \enquote{Der Übersetzer weiß das doch eh! Warum muss ich das hinschreibeb?}
      \ei
    }\medskip
    \ii Implizite Typisierung und \textbf{Typinferenz} macht das Leben einfacher.{
        \begin{code}[tag=C++11]
        \begin{CPP}
          std::vector<int> vec;
          for (auto it : vec) {...}
        \end{CPP}
      \end{code}
      \bi
      \ii Der Übersetzer errechnet den Typen für \texttt{it} aus dem Kontext.
      \ii Fortgeschrittene Typinferenz mittels Unifikation möglich (später.)
      \ei
    }
    \ei

  \end{frame}
#+end_src

* Zusammenfassung
