#+TITLE: Programmiersprachen und Übersetzer
#+SUBTITLE: 11 - Das Objekt-Orientierte Programmierparadigma
#+SETUPFILE: setup.org
#+INCLUDE: export-prologue.org
#+PROPERTY: header-args:latex :tangle yes :noweb yes :tangle-macros yes :tangle-prologue topic :tangle-epilogue endtopic :exports none

#+NAME: topic
#+BEGIN_SRC latex :tangle no
\psuSectionStart{{{{property(ITEM)}}}}{{{{n(block)}}}}
#+END_SRC

#+NAME: endtopic
#+BEGIN_SRC latex :tangle no
\psuSectionStop{{{{property(ITEM)}}}}{{{{n(block,-)}}}}
#+END_SRC

* Gedanken zu dieser Vorlesung                                     :noexport:
- Was ist das Grundlegende Problem?
  - Softare ist Komplex => Kein Problem für die Maschiene
  - Software Complexity ist ein Problem für Menschen
  - Zum einen muss es in den Kopf eines einzigen Menschen passen.
  - Zum anderen braucht man eine gemeinsame Sprache mit seinen Mitentwicklern.

- Was ist ein Programmierparadigma?
  - https://www.info.ucl.ac.be/~pvr/VanRoyChapter.pdf
  - Paradigma: Eine Menge von zusammenhängenden Konzepten die miteinander harmonieren.This chapter is partly based on the book [50], familiarly known as CTM, which givesThis chapter is partly based on the book [50], familiarly known as CTM, which gives
  - Konzepte sind zu Paradigmen gruppiert.
  - Sprachen implementieren 1..N Paradigmen. Meistens mehrere
  - Die Paradigmen helfen dabei das Programm zu strukturieren.

- Das Imperative Paradigma
  - State + Procedure + Record
  - State: Benannter Zustand
  - Procedure:  Sequenzierung von mehreren Befehlen zu einem Ablauf
  - Record:     Strukturierte Objekte

  => Wie Dekonstruiert man damit ein großes Problem?

- Das Objekt-Orientierte Paradigma
  - Closures: Prozeduren mit teilweise aus dem Environment gebundenen Variablen
  - => Instantiierbare Namensräume mit Methoden sind Closures.

  - Was machen Leute damit?
    Sie Bilden die Strukturen der Realen Welt auf Objekte ab => User

    Design: Class Structure vs. Object Structure

    => Wie dekonstruiert man damit ein großes Problem?

  - Kritik an OO: Es gibt keine Algorithmen ohne Zustand

    The problem with object-oriented languages is they've got all this implicit environment that they carry around with them.
    You wanted a banana but what you got was a gorilla holding the banana and the entire jungle.



* Paradigmen und Komplexität
:PROPERTIES:
:CUSTOM_ID: 11-einleitung
:END:
#+begin_src latex
  \subtitle{{{{subtitle()}}}}
  \maketitleframe

  \begin{frame}{Wiederholung: Die semantische Lücke}
  \begin{columns}
    \begin{column}{0.30\textwidth}
      \begin{center}\small
        \includegraphics[width=1.5cm]{fig/01-problem}\\\relax
        [Problem]\\[1ex]
        \fbox{\parbox{0.8\textwidth}{\centering
            Hochsprache\\
            $\Uparrow$\\
            \structure{Semantische Lücke}\\
            $\Downarrow$\\
            CPU-Steuersignale
          }}\\[1ex]\relax
        [Ausführung]\\\relax
        \includegraphics[width=1.5cm]{fig/01-cpu}
      \end{center}
    \end{column}\hfill
    \begin{column}{0.65\textwidth}
      Mit unserem Übersetzer haben die semantische Lücke \advantage{überwunden}:

      \begin{center}
        Source $\rightarrow$ AST $\rightarrow$ IR $\rightarrow$ ASM $\rightarrow$ ELF
      \end{center}

      \bii
      \ii Beschreibung des Problems in Hochsprache
      \ii Schrittweises Absenken der Abstraktion
      \ii Schichten versprechen wohldefinierte Semantiken.
      \eii

      \bigskip
      \pause
      \ALERT{Aber:} \btSetTab Warum türmen wir überhaupt \\\btUseTab diese semantische Lücke auf?

      \bii
      \iida Lernkurve: Abstraktionen müssen gelernt werden.
      \iida Fehleranfällig: Übersetzer können Bugs haben
      \iida Abstraktionen erzeugen oft einen Overhead
      \eii

      \OrangeBox{Welchen Nutzen hat die semantische Lücke?}
    \end{column}
  \end{columns}
  \end{frame}

  \begin{frame}{Komplexität und Nicht-Determinismus}
    \bi
    \ii Große Systeme haben zwei Dimensionen, die das \structure{Verständnis} erschweren{%
      \bi
      \ii \structure{Komplexität}: Anzahl der interagierenden Elemente?
      \ii \structure{Nicht-Determinismus}: Wie vorhersagbar sind die Interaktionen?
      \ei
    }\bigskip
    \ii<2-> \textbf{Beispiel}: Das gesamte Universum {
      \bi
      \ii Viele Elemente (Atome), die  zufällig interagieren (Quantenmechanik)
      \ii Für das funktionieren des Universums ist das egal.
      \ii Für unser Verständnis vom Universum ein Problem.
      \ei
    }\bigskip
    \ii<3-> Ein großes Programm als ein großes System.{%
      \bi
      \ii Viele Elemente (Daten) interagieren miteinander (abhängige Operationen).
      \ii Für die Maschine egal. Operationen werden stumpf nacheinander ausgeführt.
      \ii \structure{Problem Menschen}: Da sie es nicht verstehen, können sie es nicht bauen.
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{Mensch vs. Maschine}
    \centering
    \btAnimation[height=8cm]{range=1-4:<1->}{fig/11-complexity}
  \end{frame}

  \begin{frame}{Konzepte, Paradigmen, Prinzipien}
    Damit wir Menschen \textbf{komplexe Systeme} bauen, verstehen und kommunizieren können, brauchen wir Abstraktionen und Strukturen.

    \bigskip

    \bi
    \ii Sprachen bieten Abstraktionen zum denken und kommunizieren{%
      \bi
      \ii \structure{Konzepte}: Welche Abstraktionen kann es überhaupt geben?\\[1ex]
         Beispiele: Records, Zustand, Prozeduren, Closures, Threads, Nachrichten\\[3ex]
      \ii \structure{Paradigmen}: Welche Abstraktionen nutze ich in Kombination?\\[1ex]
      Beispiel: Imperativ  = Records + Zustand + Sequenzierung + Prozeduren\\[3ex]
      \ii \structure{Prinzipien}: Wie nutze ich die Abstraktionen (ohne Knieschuss)?\\[1ex]
      Beispiel: Liskovsches Substitutionsprinzip\\
      \onslide<2>{$\Rightarrow$    Software Engineering}
      \ei
    }
    \ei
  \end{frame}


  \begin{frame}{Hierarchie der Begrifflichkeiten}
    \centering
    \btAnimation[width=0.7\textwidth]{range=1-4:<1->}{fig/11-principles}
  \medskip
    \bii
    \ii<2->  Paradigmen bündeln Konzepte zu einem konsiztenten Programmiermodell
    \ii<3-> Es gibt \ALERT<3->{viel mehr} Sprachen als Paradigmen
    \ii<4-> Die meisten Sprachen bedienen mehr als ein Paradigma.\\[1ex]
    Oft: Ein Paradigma für \structure{Grobstruktur} + Ein Paradigma für die \structure{Feinstruktur}
    \eii
  \end{frame}
#+end_src

* Das imperative Programmierparadigma

#+begin_src latex
  \dividerframe{Das Imperative Paradigma}

  \begin{frame}{In the Beginning,\ldots}
    \btAnimation[width=\textwidth]{range=1-2:<1->}{fig/11-organization}

    \medskip
    \bi
    \ii   \ldots all data was unstructured and all operations were floating.{
      \bi
      \ii<2->[+=] \structure{Records}: Daten werden zu Datenstrukturen zusammengefasst.
      \ii<2->[+=]\structure{Sequenzierung}: Befehle nacheinander ausführen. Ergebnisse weitergegeben.
      \ei
    }\medskip
    \ii<2-> Beispiel: Reverse Polish Notation (wie in PostFix) {
      \bi
      \ii Von Links nach rechts ausführen, Impliziter Stack für die Berechnung
      \ii \texttt{1 3 + 5 4 - *} == \texttt{(1 + 3) * (5 - 4)}
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{Kontrollfluss und Prozeduren}
    \begin{columns}
      \begin{column}{0.35\textwidth}
        \btAnimation[width=\textwidth]{range=1-3:<1->}{fig/11-prozeduren}
      \end{column}\hfill
      \begin{column}{0.58\textwidth}
        \bi
        \ii<2-> Komplexe Abläufe als Kontrollfluss {
          \bi
          \ii[+=] \structure{Selection}: Endlich können wir eine Operation auch mal auslassen.\\[1ex]
          \ii[+=] \structure{Iteration}: Endlich können wir eine Operation mehrfach ausführen ohne sie doppelt zu notieren.
          \ei
        }\medskip
        \ii<3-> \textbf{Wiederverwendung} durch \structure{Prozeduren} {
          \bi
          \ii Operationen werden ein Verbund und bekommen einen Namen.
          \ii Parameter und Rückgabewerte
          \ii[+=] \structure{Invokation}: Starte die Ausführung des Operationsverbundes.
          \ei
        }
        \ei
        \bigskip
        \onslide<3->{
          \scriptsize (Beinahe) Synonyme: Funktionen, Prozedur, Routinen
        }
      \end{column}
    \end{columns}
  \end{frame}

  \begin{frame}[fragile]{Entwurfs-Prinzip: Prozedurale Abstraktion}
    \bi
    \ii Prozeduren sind eine \ALERT{technische Einrichtung} der Sprache{
      \bi
      \ii Gibt uns das grundlegende Prinzip der Code-Wiederverwendung.
      \ii Die Sprache schreibt \textbf{nicht} vor, wie diese zu Verwenden sind.
      \begin{columns}
        \hfill
        \begin{column}{0.4\textwidth}
          \begin{code}[]
            \begin{py}
              def step3():
                 step1()
                 doIntermediateStep()
                 step2()
            \end{py}
          \end{code}        
        \end{column}\hfill\mbox{}
      \end{columns}
      \ei
    }\bigskip
    \ii<2-> \structure{Prozedurale Abstraktion}: Zerlegung des Problems als in Teilprobleme{
      \bi
      \ii Aufteilung des Codes anhand \textbf{problemspezifischer Grenzen}
      \ii Eine Funktionalität $\rightarrow$ Eine Prozedur
      \ii Implementierung der Funktionalität wird hinter dem Funktionsnamen versteckt und kann problemlos ausgetauscht werden (z.B. Bugfix).
      \ei
      \begin{code}[]
        \begin{CPP}
          char *strstr(const char *haystack, const char* needle);
        \end{CPP}
      \end{code}
    }
    \ei
  \end{frame}

  \begin{frame}{Benannter und veränderlicher Zustand}
    \begin{columns}
      \begin{column}{0.25\textwidth}
        \btAnimation[width=\textwidth]{range=1-3:<1->,3:<4->}{fig/11-state}
      \end{column}\hfill
      \begin{column}{0.65\textwidth}
        \bi
        \ii<2-> Eingaben und (Zwischen-)ergebnisse speichern{%
          \bi
          \ii Speicherzellen mit symbolischem Namen
          \ii Objekte werden an diese Namen gebunden
          \ii Späterer Zugriff über das Symbol
          \ei
        }\medskip
        \ii<3-> \structure{Veränderlicher Zustand} ist ein eigenes Konzept{%
          \bi
          \ii += \structure{Variablen} und \structure{Zuweisung}
          \ii Gebundene Namen können neu gebunden  werden.
          \ii Flexibler Datenfluss und Schleifen mit Auswirkung
          \ei
        }\medskip
        \ii<4-> Variablen sind Quelle unendlich vieler \ALERT{Bugs} {
          \bi
          \ii Variablen sind ein Seitenkanal zu den Parametern
          \ii Funktionsverhalten kann überraschend werden
          \ii Zustand kann inkonsistent werden.
          \ei
        }
        \ei

      \end{column}
    \end{columns}
  \end{frame}

  \begin{frame}{Das imperatives Programmierparadigma}
    \begin{center}
      \includegraphics[width=0.6\textwidth]{fig/11-procedural-paradigma.pdf}
    \end{center}

    \bi
    \ii Das \structure{imperative Programmierparadigma} umfasst mehrere Konzepte{
      \bi
      \ii Operationen: Sequenzierung, Konstrolstrukturen, Prozeduren
      \ii Daten: Strukturierte Daten, benannter und veränderlicher Zustand
      \ii Beispiele für rein imperative Sprachen: Fortran, COBOL, PL/I, C, Pascal
      \ei
    }\medskip
    \ii Imperatives Programmieren ist oft das Paradigma \structure{\enquote{im Kleinen}}{
      \bi
      \ii Starke Kontrolle des Programmierers über die Ausführung (\ALERT{--}, \advantage{+})
      \ii Java, Rust, C++ bieten alle das imperative Paradigma an.
      \ei
    }
    \ei
  
  \end{frame}
#+end_src

Was war das Problem?

Was ist das Paradigma? 

Welche Konzepte brauchen wir für Imperatives Programmieren?

Welche Probleme ergeben sich durch rein imperatives Programmieren?

* Das objekt-orientierte Programmierparadigma


#+begin_src latex
  \dividerframe{Das objektorientierte\\Programmierparadigma}

  \begin{frame}{Probleme imperativen Programmierens}
    \btAnimation[width=0.6\textwidth]{1:<1->,center,padding=1ex}{fig/11-the-object}
    \bi
    \ii Imperativ: \textbf{Betonung} der Operationen bei \ALERT{Vernachlässigung} der Daten{%
      \bi
      \ii \alert{Codeduplikation}, da Funktionen sind strikt an ihre Datentypen gekoppelt.
      \ii \alert{Keine Kontrolle}, da programmweiter Zugriff auf Datenstrukturen möglich
      \ii \alert{Leicht unübersichtlich}, da kaum bis keine Hierarchie der Funktionen.
      \ei
      $\Rightarrow$ Erfordert Disziplin und geistige Kapazität vom Entwickler.
    }\medskip
    \ii<2-> Besonders problematisch bei \textbf{großen Softwareprojekten} {
      \bi
      \ii Wartung von dupliziertem Code macht N-fachen Aufwand.
      \ii Viele Entwickler arbeiten an der gleichen Quellcodebasis.
      \ii Prozedurale Abstraktion bietet nur eine Ebene von Abstraktion.
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{\enquote{Objekte} als zentraler Begriff}
    \OrangeBox{Menschen denken eher in Objekten (Nomen) als in Aktionen (verben)}
    \begin{columns}
      \begin{column}{0.33\textwidth}
        \begin{btBlock}{Prozedural}
          Fahrrad waschen\\
          Apfel waschen
        \end{btBlock}
      \end{column}\hfill
      \begin{column}{0.33\textwidth}
        \begin{btBlock}{Objekt-Orientiert}
        Fahrrad \btSetTab waschen\\
        \btUseTab fahren
      \end{btBlock}
      \end{column}
    \end{columns}
    \medskip
    \bi
    \ii<2-> Entwurf entlang von Objekten spiegelt menschliche Erfahrungswelten {
      \bi
      \ii Eine Fabrik besteht aus: Hallen, Arbeitern, Maschienen, einem Gelände.
      \ii All diese Entitäten haben (veränderliche) \structure{Eigenschaften}.
      \ii Entitäten \structure{interagieren miteinander} anstatt verarbeitet zu werden:\\
      Arbeiter motiert Reifen $\Rightarrow$ montieren(reifen, by=arbeiter)
      \ei
    }
     \ei


   \begin{btBlock}<3->[type=alert]{}
     Diese (objekt-orientierten) Objekte sind eine Erweiterung unserer bisherigen Objekte aus Vorlesung "06 - Objekte".
   \end{btBlock}
  \end{frame}

  \begin{frame}{Nachrichten und Objekte}
    \begin{center}
      \includegraphics[width=0.7\textwidth]{fig/11-messages}    
    \end{center}

    \begin{btBlock}{Definition nach Alan Kay (Erfinder von Smalltalk)}
      \small
      \be
      \ii \structure{Messaging}: Objekte kommunizieren durch den Versand von Nachrichten.
      \ii \structure{Persistenz}: Objekte haben privaten Zustand, auch wenn sie nicht aktiv sind.
      \ii \structure{Kapselung}: Informationen werden im Objekt verborgen.
      \ii \structure{Späte Bindung}: Ausgeführte Operation wird spätmöglichst ausgewählt.
      \ee
    \end{btBlock}
  \end{frame}

  \begin{frame}{Konzepte für Objektorientierung}
    \btAnimation[height=7cm]{range=3-5:<1->,center,padding=1ex}{fig/11-the-object}
  \end{frame}


  \begin{frame}[fragile]{Die Methode als die zentrale Erweiterung}
    \bi
    \ii Methoden haben einen \structure{Ausführungskontext} mit dem Objekt{
      \bi
      \ii Objekt auf der die Methode aufgerufen wird, wird sichtbar.
      \ii Objektattribute sind in der Methode zugreifbar.
      \ii Methode ist eine Closure! (Siehe \enquote{03 - Namen})
      \ei
    }\medskip
    \ii \structure{Closure}: Eine Funktion die einen Ausführungskontext mitbringt\\ {
      \bgroup\btAnimation[width=0.8\textwidth]{1:<1-2>,2:<3>,3:<4>,center,padding}{fig/11-closure}\egroup
      \bi
      \ii Funktionen werden \textbf{immer} in einem Kontext ausgeführt.
      \ii Bei C sind nur die Argumente und die globalen Variablen enthalten
      \ii Bei Closures sind zusätzliche Objekte an Namen gebunden (z.B. \structure{\texttt{this}})
      \ei
    }
    \ei
  \end{frame}


#+end_src

FIXME: Die letzte Folie hier ist wenig informativ. Da muss eine Graphik für Closures her!

FIXME: Noch eine Folie dahiner für die drei Konzepte: Encapsulation, Polymorphie und 

Was ist das Paradigma?

Welches Konzept brauchen wir zusätzlich dazu?

Wie schlägt sich dieses Konzept technisch nieder?

** Prototyp-basierte Objektorientierung
#+begin_src latex
\dividerframe{Prototypen}
  \begin{frame}{Objekt-Orientierung ohne Klassen}
    \begin{btBlock}{}
      Da Sie alle OO auf Basis von Klassen zur Genüge kennen, werden wir eine andere Art der OO Programmierung betrachten.
    \end{btBlock}
    \medskip
    \bi
    \ii Javascript kennt \ALERT{keine Klassen} und ist \ADVANTAGE{dennoch} Objekt-Orientiert{
      \bi \def\C{\bgroup\textcolor{safegreen}\checkmark\egroup}
      \ii Javascript-Objekt haben Attribute (\C) gebundene Methoden (\C)
      \ii Methoden werden erst beim Aufruf aufgelößt (\C)
      \ii Informationen können mittels lexikalischem Scoping verborgen (\C) werden
      \ei
    }\medskip
    \ii JavaScript verwendet \structure{Prototypen-basierte Vererbung}{
      \bi
      \ii Flexibler, Erweiterbarer, und Mächtiger als klassenbasierte Vererbung
      \ii Hohe Dynamik, die besonders für eine Skriptsprache geeignet ist
      \ii Wenige Sprachmechanismen, aber ein gewisser Zoo an syntaktischem Zucker
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[fragile]{JavaScript: Die Prototypen Kette}
    \begin{columns}
      \hfill
      \begin{column}{0.49\textwidth}
        \begin{code}[]
          \begin{JS}
            var obj = { a: 23 };
            obj.zz = 42;
            [obj.a, obj["a"], obj["zz"]];
            // => [23, 23, 42]
          \end{JS}
        \end{code}
      \end{column}\hfill
    \end{columns}

    \bi
    \ii JavaScript-Objekte sind \emph{\enquote{bags} of properties}{
      \bi
      \ii Zugriff über \texttt{[]} und den Punktoperator
      \ii Recordtyp und Abbildungstyp fallen zusammen
      \ii Properties können zu einem Objekt hinzugefügt werden
      \ei
    }\medskip
    \ii<2-> \texttt{\_\_proto\_\_}: Fallback für die Suche nach Attributen{
      \bi
      \ii Situation: Ein Objekt hat das geforderte Attribut nicht
      \ii Die Suche wird beim Prototypen, der in \texttt{\_\_proto\_\_} referenziert ist, fortgesetzt.
      \ii Es entsteht die \structure{Prototypen-Kette}, die bei \texttt{\{\}} endet.
      \ei\smallskip
      \btAnimation[width=0.9\textwidth]{1:<1-2>,2:<3>,center,padding}{fig/11-prototypes}
    }
    \ei
  \end{frame}

  \begin{frame}[fragile]{JavaScript: Attribut-Lookup und \texttt{this}}
    \bi
    \ii Prototypen-Kette implementiert dynamischen und hierarchischen Lookup{%
      \bi
      \ii Objekt in der Kettenmitte erweitern $\rightarrow$ Alle Kinder werden erweitert
      \ii Speichereffizient, aber mit höhreren Lookup-Kosten verbunden.
      \ei
    }\medskip
    \ii<2-> JavaScript bindet den Namen \structure{\texttt{this}} an das aktuelle Objekt{
      \bi
      \ii Attribute können auf Funktionen verweisen.
      \ii Objekt-Attribut als Funktion aufrufen $\Rightarrow$ \texttt{this} wird das Objekt gebunden
      \ei
    }
    \ei
    \begin{columns}<2->
      \begin{column}{0.49\textwidth}
        \begin{code}[tag=JavaScript]
          \begin{JS}[]
            var obj = {
              prop: 37,
              f: function() {
                return this.prop;
              }
            };
            var ff = obj.f;
          \end{JS}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \bii
        \ii Aufruf der Funktion als Attribut\\
            \codeinline{obj.f()} $\Rightarrow$ \codeinline{37}\\[2ex]
        \ii Aufruf der \enquote{blanken} Funktion\\
            \codeinline{ff()} $\Rightarrow$ \codeinline{undefined}
        \eii
      \end{column}
    \end{columns}
  \end{frame}

  \begin{frame}[t,fragile]{JavaScript: Funktionen als Konstruktoren}
    \bi
    \ii \textbf{Alle} Funktionen können als Konstruktoren verwendet werden{
      \bi
      \ii Das Schlüsselwort \structure{\texttt{new}} ruft Funktion im Kontext eines neuen Objekts auf.
      \ii Jede Funktion hat eine \structure{\texttt{.prototype}}-Attribut, die als \texttt{\_\_proto\_\_} gesetzt wird.
      \ei
    }
    \ei

    \begin{columns}[t]
      \begin{column}{0.49\textwidth}
        \begin{code}[]
          \begin{JS}
            function Foo(name) {
              this.name = name;
            }
          \end{JS}
          \begin{onlyenv}<2->
          \vspace{1em}
          \begin{JS}
            var obj = new Foo("alice");
          \end{JS}
        \end{onlyenv}%
        \begin{onlyenv}<3->\vspace{1em}
            \begin{JS}
            Foo.prototype.getLength = \
              function() {
                return this.name.length;
              };

            obj.getLength() // => 5
          \end{JS}
        \end{onlyenv}
      \end{code}%
      \begin{onlyenv}<2>
        \begin{center}
          dies ist äquivalent zu
        \end{center}
        \begin{code}
          \begin{JS}<3->
            var obj = {
              __proto__: Foo.prototype
            }
            // Aufruf mit this == obj
            obj.constructor("alice");
          \end{JS}
        \end{code}
      \end{onlyenv}

      \end{column}\hfill
      \begin{column}{0.49\textwidth}\centering
        \btAnimation[width=2.7cm]{raisebox,range=1-3:<1->,3:<4>}{fig/11-js-constructors}
      \end{column}
    \end{columns}
    \bi
    \ii<4-> Modernes JavaScript bietet \structure{\texttt{class}} und \structure{\texttt{extends}} als syntaktischen Zucker
    \ei
  \end{frame}

  \begin{frame}{Prototypen-basierte Objektorientierung}
    \bi
    \ii Objekte erben alle Eigenschaft ihrer Prototypen {
      \bi
      \ii JavaScript: Dynamischer Lookup entlang der Prototypen-Kette
      \ii Konstruktion der Prototypen-Hierarchie mittels \structure{\texttt{new}}
      \ii Sieht aus wie klonen, ist aber effizienter.
      \ei
    }\medskip
    \ii Alle Objekte sind \structure{gleichberechtig} und können Prototypen werden {
      \bi
      \ii Keine Unterscheidung zwischen Objekten und Klassen.
      \ii JavaScript: \texttt{obj.\_\_proto\_\_} zeigt wieder auf ein Objekt
      \ii Es entsteht ein Baum von Objekten die Prototypen füreinander sind.
      \ii Die Wurzel des Baums ist das leere Objekt: \texttt{\{\}}
      \ei
    }\medskip
    \ii Veränderung eines Prototypen ändert alle erbenden Objekte {
      \bi
      \ii JavaScript: Eingebaute Objekte können erweitert werden (discouraged)
      \ii \codebox{Array.prototype.forEach = function(...) \{ ... \}}
      \ii Alle Objekte können jetzt \texttt{forEach}: \codebox{[2,3,4].forEach(...)}
      \ei
    }
    \ei
  \end{frame}
#+end_src


** Kritikpunkte am Objekt-Orientierten Paradigma
#+begin_src latex
  \dividerframe{Kritik am Objektorientierten Entwurf}

  \begin{frame}[fragile]{Konzentration auf Objekte}
    \bi
    \ii Objekt-orientierte Entwurfsmethoden fokussieren Objekte {%
      \bi
      \ii \structure{Verb/Nomen-Analyse} von Use-Case Beschreibungen\\[1ex]
          Alle Nomen werden Klassen/Objekte.\hspace{1em} Alle Verben werden Methoden.\\[2ex]
     \ii Arbeiter (Nomen) montiert (verb) Reifen (Nomen) an Auto (Nomen).\\[2ex]
          \begin{center}
          \begin{tikzpicture}
            \node[rectangle split, rectangle split parts=2,draw] {%
              Arbeiter
              \nodepart{two}%
              void montieren(Reifen, Auto)
            };
          \end{tikzpicture}
        \end{center}
        \ei
      }\bigskip
      \ii<2-> \ALERT{Kritik}: Objekt-Orientierung vernachlässigt Verben {\\[1ex]
        \begin{displayquote}[Steve Yegge, Execution in the Kingdom of Nouns][\hfill]
          Object Oriented Programming puts the Nouns \alert{first and foremost}. Why would you go to such lengths to put one part of speech on \textbf{a pedestal}? Why should one kind of concept take precedence over another? It's not as if OOP has suddenly made verbs \alert{less important} in the way we actually think.
        \end{displayquote}
      }
      \ei
    
    \overlayboxHBOX
    \begin{overlaybox}<3->[draw=srared,ultra thick]
      \includegraphics[height=5cm]{fig/11-hund}
    \end{overlaybox}
  \end{frame}

  \begin{frame}[fragile]{Konzeptionell: Verben kommen nie allein!}
    \bi
    \ii Nicht jede Funktionalität kann einem Objekt zugeordnet werden. {
      \bi
      \ii Zu welchem Objekt gehört der Algorithmus \textbf{größter gemeinsamer Teiler}?
      \ii Methode von \texttt{AlgorithmManager}-Klasse?  Unterschiedliche Instanzen?
      \ii Gehört sie zur Klasse \texttt{int}? Hat \texttt{BigInt} eine eigene \texttt{gcd()} Methode?
      \ii[$\Rightarrow$] \textbf{\enquote{Lösung}}: Nicht-instantiierte Klassen die nur statische Methoden beinhalten\\[1ex]
      \begin{center}
        \codebox{void java.lang.Math.sin(double a);}
      \end{center}
      \ei
    }\bigskip
    \ii<2-> Wir können keine blanken Funktion herumreichen {
      \bi
      \ii Callback-Funktionen müssen immer von einem Objekt \enquote{bewacht} werden
      \ii[$\Rightarrow$] Leere Objekte die nur eine Methode \enquote{\texttt{execute()/run()/do()}} haben{
        \begin{center}
          \codebox{void java.lang.Runnable.run();}
        \end{center}
      }\medskip
      \ii \structure{Designpatterns} um diese Schwäche zu umschiffen: Command, Strategy, Proxy
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{Konzeptionell: Daten kommen nie alleine!}
    \bi
    \ii Von manchen Klassen kann es nur eine Instanz geben {
      \bi
      \ii Manche Entitäten sollten in einem Programm nur einmal existieren.
      \ii Beispiel: Managerobjekt, dass \textbf{alleinige} Kontrolle über einen Aspekt hat.
      \ii \structure{Designpattern}: Singleton (nur möglich durch statische Attribute)
      \ei
    }\bigskip
    \ii<2-> Strikte Objektorientierung kennt keinen \structure{globalen Kontext} {
      \bi
      \ii An welchem Objekt würde eine globale Variable hängen? 
      \ii Globale Variablen erlauben globale Konfiguration des Programmverhaltens\\[1ex]
      \ii[$\Rightarrow$] Durchschleifen von Kontext-Objekten mit Programmoptionen\\[2ex]{
        \hspace{1cm}%
        \btSetTab\codebox{void app.grep.Searcher.search(ProgramContext);}\\
        \btUseTab\codebox{void app.grep.Searcher.iterateDirectory(ProgramContext, Directory);}\\
        \btUseTab\codebox{void app.grep.Searcher.processFile(ProgramContext, String);}\\
          \btUseTab\codebox{void app.grep.Searcher.searchLine(ProgramContext, String);}\\
      }\medskip
      \ii \structure{Designpatterns}, die dieses Problem beheben: Registry, ServiceLocator\\
      \hfill\scriptsize(Beides Singletons)
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{\enquote{Objektorientierung ist ineffizient!}}
    \bi
    \ii OO-Entwurfsprinzipien verleitet Probleme zu feinschichtig zu zerlegen{\\[1ex]
      \begin{center}
        \includegraphics[page=1,height=1.8cm]{fig/11-call-hierarchy}\hspace{2cm}
        \includegraphics[page=2,height=1.8cm]{fig/11-call-hierarchy}
      \end{center}

      \bi
      \ii Verteilung der Verantwortlichkeit auf viele Objekte
      \ii Unübersichtlicher Kontrollfluss zwischen den einzelnen Methoden
      \ii Viele Methodenaufrufe zwischen den Schichten.
      \ei
    }\medskip
    \ii<2-> Hohe Kosten für den einzelnen  Methodenaufrufe{
      \bi
      \ii \structure{Späte Bindung}: Dynamic Dispatch wählt Methode zur Laufzeit auf
      \ii \structure{this}: Der implizite durchgeschleifte Parameter ist nicht umsonst.
      \ei
      \medskip
      \begin{displayquote}[Joe Armstrong, Erlang Erfinder][\\\hfill]\small
        The problem with object-oriented languages is they've got all this implicit environment that they carry around with them. You wanted a banana but what you got was a gorilla holding the banana and the entire jungle.
      \end{displayquote}
    }
    \ei
  
    \overlayboxHBOX
    \begin{overlaybox}<3->[draw=srared,ultra thick]
      \includegraphics[height=8cm]{fig/11-callstack}
    \end{overlaybox}
  \end{frame}
#+end_src
Welche Kritikpunkte wurden an OO angebracht?

Warum würde man Nouns über Verben präferieren? Das hat negative Auswirkungen

- Nicht jede Funktion kann einer/m Klasse/Objekt zugeordnet weden
  - Von welchem Objekt ist GCD ein Methode? Wem muss ich eine Nachricht schicken um den größten gemeinsamen Teiler auszurechnen
  - Fallback über statische Funktionen in nicht-instantiierten Klassen (Math.sin())
  - Das Objekt-Modell passt einfach nicht auf alles
- Reine Klassenbasierte-Objektorientierung erlaubt keinen globalen Zustand
  - Man müsste ein globales Kontext-Objekt überall mit hin durch reichen.
  - Idee geht leider bei Libraries kaputt, da das Kontext-Objekt nicht beliebig erweiterbar ist.
  - Quick-Fix: Das Singleton Entwurfsmuster. Geht aber nur mit statischen Attributen

- Ineffizienzen
  - Funktionen kommen immer mit einem Kontext 

    Joe Armstrong (Erlang Inventor): "The problem with object-oriented languages 
       is they've got all this implicit environment that they carry around with them.
       You wanted a banana but what you got was a gorilla holding the banana and the entire jungle."

- Kreis-Elipse Problem
  => Vererbungshierarchie ist manchmal nicht eindeutig bestimmbar

* Zusammenfassung

#+begin_src latex
  \begin{frame}{Zusammenfassung}
    \bi
    \ii Programmierparadigmen sind Sammlungen von Sprachkonzepten {
      \bi
      \ii Ausweiten der Semantischen Lücke macht eine Sprache \alert{nicht mächtiger},\\
          aber den Code leichter \advantage{verständlicher}.
      \ii Paradigmen werden durch Software-Enginnering Prinzipien diszipliniert.
      \ei
    }
    \ii Das imperative Programmierparadigma {
      \bi
      \ii Sequentielles Abarbeiten von Operationen, die den Zustand verändern.
      \ii Strikte Vorgabe, wie eine Aufgabe durch zu führen ist.
      \ii Prozedurale Abstraktion zerlegt das Problem entlang von Aufgaben
      \ei
    }
    \ii Das objekt-orientierte Programmierparadigma {
      \bi
      \ii \structure{Interagierende Objekte} sollen die reale Welt abbilden
      \ii Objekte senden \structure{Nachrichten} bzw. rufen sich ihre Methoden gegenseitig auf
      \ii Prototypen erlauben \structure{klassenlose Objektorientierung}
      \ei
    }
    \ii Objekt-Orientierung hat ebenfalls \alert{Probleme} {
      \bi
      \ii Funktionen werden immer von Objekten dominiert.
      \ii Globaler Kontext nur über statische Methoden/Attribute
      \ii Designpatterns müssen konzeptionelle Schwächen ausgleichen
      \ei
    }
    \ei
  
  \end{frame}
#+end_src

