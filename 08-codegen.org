#+TITLE: Programmiersprachen und Übersetzer
#+SUBTITLE: 08 - Zwischencodeerzeugung
#+SETUPFILE: setup.org
#+INCLUDE: export-prologue.org
#+PROPERTY: header-args:latex :tangle yes :noweb yes :tangle-macros yes :tangle-prologue topic :tangle-epilogue endtopic :exports none

#+NAME: topic
#+BEGIN_SRC latex :tangle no
\psuSectionStart{{{{property(ITEM)}}}}{{{{n(block)}}}}
#+END_SRC

#+NAME: endtopic
#+BEGIN_SRC latex :tangle no
\psuSectionStop{{{{property(ITEM)}}}}{{{{n(block,-)}}}}
#+END_SRC

* Gedanken zu dieser Vorlesung                                     :noexport:
- Maschinenmodell für den Zwischencode
  - Register und Stackmaschinen
  - Registermaschine mit unendlichen Registern
  - 3-Address-Codes oder Quadrupel
  - Vorstellung unserer IR Maschine


- Abbildungen der Sprachkonstrukte
  - Der CFG als Datenstruktur
  - Variablenbbildung
  - Einfache Operationen
  - Kontrollflusskonstrukte
  - Extra: (komplexere) Typen + dynamischer Dispatch

* Was leistet die "Zwischencodeerzeugung"?
:PROPERTIES:
:CUSTOM_ID: 08-einleitung
:END:

#+begin_src latex
  \subtitle{{{{subtitle()}}}}
  \begin{frame}
    \maketitle
  \end{frame}

  \begin{frame}{Einordnung in die Vorlesung: Zwischencodeerzeugung}
    \begin{center}
      \includegraphics[page=6,width=0.9\linewidth]{fig/01-overview-small}
    \end{center}
    \bi
    \ii \structure{Zwischencodeerzeugung}: Linearisierung und Übersetzung des ASTs{%
      \bi
      \ii \structure{Zielarchitektur}: Virtuelle Maschinen mit wohldefiniertem Funktionsumfang
      \ii Konkret genug für  Assemblererzeugung, Abstrakt genug für Optimierungen
      \ii Wiederverwendung des Middle- und Backend für \advantage{mehrere Frontend-Sprachen}
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{Einordnung in den Übersetzerbau}
    \btAnimation[width=\textwidth]{1:<-2>,2:<3>}{fig/08-retargable-compiler}%
    \footnote{Zahlen für Clang (C/C++ Frontend, 700k) und LLVM 9.0 (18 Backends, 1.4M)}

    \bi
    \ii Die Konstruktion eines Übersetzers ist aufwändig und schwierig!{
      \bi
      \ii Assembler im Parser erzeugen ist (manchmal) möglich \hfill(One-Pass Compiler)
      \ii Wiederverwendung von Komponenten erleichtert das portieren (\textasciitilde 60\,\% Re-Use)
      \ei
    }\medskip
    \ii<2-> \structure{Zwischenrepresentation} erhält die Programm-Semantik{
      \bi
      \ii AST ist bereits eine \structure{Intermediate Representation} (IR-Form)
      \ii Der klassische IR-Code: CFG mit Instruktionen für eine sequentielle Maschine
      \ei
    }
    \ei

  \end{frame}
#+end_src

* Virtuelle Maschinen für Zwischencode
#+begin_src latex
  \dividerframe{Virtuelle Maschinen\\für die\\Zwischencodeereugung}

  \begin{frame}[fragile,t]{Virtuelle Stack- und Register-Maschinen}
    \begin{center}
      \begin{tikzpicture}
        \node[operation,rectangle] {+}
          child {node[alt=<1>{operand}{operation,rectangle}] {\alt<1>{3}{Op1}}}
          child {node[alt=<1>{operand}{operation,rectangle}] {\alt<1>{4}{Op2}}};
      \end{tikzpicture}
    \end{center}
  
    \begin{columns}
      \begin{column}{0.49\textwidth}
        \columntitle{Stack-Maschine}
        \bii
        \ii Berechnung findet auf Stack statt
        \ii Operanden gehen über den Stack
        \ii Datenfluss ist implizit
        \ii Unendlich großer Stack
        \eii

        \begin{code}
          \begin{onlyenv}<1>
          \begin{codetext}
            push 3
            push 4
            add     // = push(pop() + pop())
          \end{codetext}
          \end{onlyenv}
          \begin{onlyenv}<2->
          \begin{codetext}
            // code(Op1) ->  1 Element am Stack
            // code(Op2) ->  1 Element am Stack
            add     // = push(pop() + pop())
          \end{codetext}
          \end{onlyenv}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \columntitle{Register-Maschine}
        \bii
        \ii Operationen manipulieren Register
        \ii Operanden gehen durch \enquote{Register}
        \ii Register machen Datenfluss sichtbar
        \ii Beliebig viele Register
        \eii
        \begin{code}[]
          \begin{onlyenv}<1>
          \begin{codetext}
            r0 = 3
            r1 = 4
            r2 = add r1, r2
          \end{codetext}
          \end{onlyenv}
          \begin{onlyenv}<2->
          \begin{codetext}
            // r1 = code(Op1)
            // r2 = code(Op2)
            r2 = add r1, r2
          \end{codetext}
          \end{onlyenv}
        \end{code}
      \end{column}
    \end{columns}

    \bigskip
    \uncover<3->{$\Rightarrow$ Codeerzeugung für Stack- und Register-Maschinen sieht ähnlich aus.}
  \end{frame}

  \begin{frame}{Design-Kriterien für Virtuelle Maschinen}
    \OrangeBox{\textbf{Vorneweg}: Die Spezifikation einer Virtuellen Maschine ist schwierig}
    \medskip
    \bi
    \ii Wahl des Abstraktionsniveaus: Endlicher oder \alert<2->{unendlicher Registersatz?}{%
      \bi
      \ii Abstraktere Semantik $\Rightarrow$ IR-Code ist näher an Programmstruktur
      \ii Leichtere Codeerzeugung und Optimierung, komplexeres Backend
      \ei
    }\medskip
    \ii Ausführungsmodell: \alert<2->{Register-Maschine} oder Stack-Maschine?{%
      \bi
      \ii Stack-Maschinen haben besonders kompakte Programmdarstellung
      \ii Register-Maschinen sind näher an real-existierenden Prozessoren 
      \ei
    }\medskip
    \ii Verbraucher der IR-Form: Interpreter oder \alert<2->{Übersetzer-Backend}?{
      \bi
      \ii Übersetzer brauchen eine gut analysierbare und veränderbare IR-Form
      \ii Bei Interpretern soll die Ausführung möglichst schnell starten
      \ei
    }
    \bigskip
    \ii<2>[$\Rightarrow$] Wir wählen eine Register-Maschine mit unendlich vielen Registern 
    \ei
  \end{frame}


#+end_src

#+begin_src latex
\begin{frame}{3-Address Code (Quadrupel-Notation) }
    \bi
    \ii Programm wird als Folge von Quadrupeln dargestellt {
      \bi
      \ii Quadrupel besteht aus einem Operator und \textbf{maximal} drei Operanden {
        \begin{center}
        \medskip
        \texttt{x := op y, z} 
        \medskip
      \end{center}

      }
      \ii Operanden (\texttt{x,y,z}) können sein:{
        \bi
        \ii \structure{Variablen/temporäre Register} halten ein Maschinenwort
        \ii \structure{Literale} als konstante Operanden
        \ii \structure{Label} dressieren andere Operationen
        \ei
      }
      \ei
    }\medskip
    \ii Nur (un-)bedingte Sprünge, keine Schleifen oder Bedingungen {
      \bi
      \ii Sprachkonstrukte werden mit \texttt{goto}/\texttt{ifgoto} linearisiert
      \ii 3-Address Code passt perfekt in Basisblock/CFG Struktur
      \ei
    }
    \ei
    \begin{btBlock}[type=example]{Beispiel: \texttt{if ((*a) <= (4 + b)) ...}}\ttfamily
      t1 := \ircmd{Load} a\\
      t2 := \ircmd{Add} 4, b\\
      t3 := \ircmd{LessEqual} t1, t2\\
      \ircmd{IfGoto} t3, .BB1, .BB2
    \end{btBlock}
  \end{frame}
#+end_src

#+begin_src latex
  \begin{frame}{Für PSÜ: Ein beispielhafter Zwischencode}
    \begin{btBlock}{}
      Für Vorlesung und Übung entwickeln wir einen Zwischencode auf Basis einer Registermaschine mit unendlich vielen Registern. Dazu schauen wir uns Semantik und Notation an.
    \end{btBlock}

    \begin{columns}[t]
      \begin{column}{0.49\textwidth}
        \bi
        \ii \structure{Operanden} können sein:{
          \bi
          \ii (C) Konstante Ganzzahlen: \texttt{3}, \texttt{4}
          \ii (L) Statische Label:  \texttt{.BB2}
          \ii (V) Variablen: \texttt{a}, \texttt{t1}
          \ei
        }
        \ei
      \end{column}\hfill
      \begin{column}{0.49\textwidth}\small
        \bii
        \ii \textbf{Variablen} sind funktions lokal
        \ii Beliebig viele temporäre Variablen
        \ii Alle Werte sind 32-Bit breit 
        \ii Keine Typisierung
        \eii
      \end{column}
    \end{columns}

    \medskip
  
    \bi
    \ii Einfache \structure{Operationen} (6 Befehle) {
      \bi
      \ii \ircmd{Assign}: Einer Variable einen Wert zuweisen \hfill\texttt{V := \ircmd{Assign} b}
      \ii 4 arithmetrische Operationen: \ircmd{Add}, \ircmd{Sub}, \ircmd{Mul}, \ircmd{Div}  \hfill\texttt{V := \ircmd{Add} CV, CV}
      \ii 1 logische Operation: \ircmd{LessEqual} \hfill\texttt{V := \ircmd{LessEqual} CV, CV}\\
          Falsch: \enquote{0}, Wahr: \enquote{!= 0}
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{Für PSÜ: Ein beispielhafter Zwischencode (2)}
    \bi
    \ii \structure{Speichermanipulationen} (3 Befehle) {
      \bi
      \ii \ircmd{Ref}: \hspace{1.2em}\btSetTab Erzeugen einer Referenz          \hfill\texttt{V := \ircmd{Ref} LV}
      \ii \ircmd{Load}: \btUseTab Lesen des addressierten Speicherwortes        \hfill\texttt{V := \ircmd{Load} V}
      \ii \ircmd{Store}: \btUseTab Schreiben eines Wertes an ein Speicherstelle \hfill\texttt{*V := Store CV}
      \ei
    }\medskip
    \ii \structure{Speichermanagement} (3 Befehle) {
      \bi
      \ii \ircmd{StackAlloc}: \btSetTab Speicherallokation im Call-Frame\hfill\texttt{V := StackAlloc C}
      \ii \ircmd{HeapAlloc}:  \btUseTab Speicherallocation dem Heap\hfill\texttt{V := HeapAlloc C}
      \ii \ircmd{HeapFree}:   \btUseTab Freigabe eines Heap-Objekts\hfill\texttt{HeapFree V}
      \ei
    }\medskip
    \ii \structure{Funktions-lokale Kontrollflüsse} (2 Befehle) {
      \bi
      \ii \ircmd{Goto}:   Sprung an das gegebene Label \hfill\texttt{\ircmd{Goto} L}
      \ii \ircmd{IfGoto}: Bedingter Sprung   \hfill\texttt{\ircmd{IfGoto CV, L, L}}
      \ei
    }\medskip
    \ii \structure{Interprozedurale Kontrollflüsse} (2 Befehle) {
      \bi
      \ii \ircmd{Call}: Funktionsaufruf mit beliebig vielen Argumenten \hfill\texttt{\ircmd{Call} LV, [CV]*}
      \ii \ircmd{Return}: Rückkehr aus einer Funktionsinstanz \hfill\texttt{\ircmd{Return} CV}
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[fragile]{Für PSÜ: Ein Beispielhafter Zwischencode (3)}
    \bi
    \ii \structure{Basisblöcke} {
      \bi
      \ii Geordnete Liste von Operationen
      \ii Jeder Basisblock hat ein (funktions-lokal) eindeutiges Label  \hfill{\texttt{.BB0}},\ldots
      \ii Der letzte Befehl eines Basisblocks muss ein \ircmd{Goto} oder \ircmd{IfGoto} sein.
      \ii[$\Rightarrow$] Maximale Basisblöcke
      \ei

 
    }\bigskip
    \ii \structure{Funktionen} {
      \bi
      \ii Ungeordnete Menge von Basisblöcken mit einem Eingangsblock
      \ii Funktionen haben ein Label, können aber nicht direkt angesprungen werden
      \ii Beliebig viele lokale Variablen und temporäre Register
      \ii Beliebig viele Parameter, die als Variablen zugänglich sind
      \ei
    }
    \ei
    \medskip

    \begin{columns}[t]
      \begin{column}{0.49\textwidth}
        \begin{code}
        \begin{py}
          class BasicBlock:
              def __init__(self, label):
                  self.label = label
                  self.instructions = []
                  self.successors = []
        \end{py}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \begin{code}
        \begin{py}
          class Function:
              def __init__(self, label):
                  self.label = label
                  self.parameters = []
                  self.variables  = []
                  self.entry_block  = None
                  self.basic_blocks = []
        \end{py}
        \end{code}
      \end{column}
    \end{columns}
  \end{frame}

  \begin{frame}[fragile]{Iterativer Fibonacci als Zwischencode}
    \begin{columns}
      \begin{column}{0.45\textwidth}
        \includegraphics[height=0.85\textheight]{fig/08-fib-iter}      
      \end{column}\hfill
      \begin{column}{0.54\textwidth}
        \bi
        \ii Beobachtungen {
          \bi
          \ii BB0 initialisiert die Startwerte
          \ii BB1/2 sind eine while-Schleife
          \ii \texttt{Goto .BB1} spaltet BB0/1
          \ei
        }
        \ei

        \begin{code}[]
          \begin{lzero}
            func fib_iter(n : int) : int {
              var a : int;
              var b : int;
              a := 0;
              b := 1;
              while (n >= 0) {
                var tmp : int;
                tmp := a;
                a := a + b;
                b := tmp;
                n := n - 1;
              }
              return a;
            }
          \end{lzero}
        \end{code}
      \end{column}
    \end{columns}
  \end{frame}
#+end_src

* Codeerzeugung für Zwischencode
** CFG als Datenstruktur
#+begin_src latex
  \dividerframe{Codeerzeugung}
  \begin{frame}{Notwendige Operationen auf CFG und Basisblöcken}
    \begin{btBlock}{}
    \textbf{Schlachtplan}: Wir traversieren den AST einer Funktion und erzeugen dabei einen CFG mit Basisblöcken voller IR-Operationen.
  \end{btBlock}

  \bigskip
  \bii
  \ii Erstelle ein Funktionsobjekt\hspace{1cm}       \btSetTab \siginline{Programm.create\_function}{string}{Function}{%
    \bi
    \ii Funktionen haben den Namen als Label (\scriptsize\codebox{func.label})
    \ii Parameter und Variablen werden beim traversieren erstellt\\[2ex]
    \ei
  }
  \ii Erstelle einen Basisblock          \btUseTab \siginline{Function.create\_block}{()}{BasicBlock}
  \ii Erstelle einen Parameter           \btUseTab \siginline{Function.create\_parameter}{name}{Variable}
  \ii Erstelle eine Variable             \btUseTab \siginline{Function.create\_variable}{}{Variable} {
    \bi
    \ii Variablen und Parameter werden im Funktionsscope verwaltet
    \ii Der erste erstellte Basisblock wird automatisch zum Eingangsblock\\[2ex]
    \ei
  }

  \ii Hänge eine Operation an            \btUseTab \siginline{BasicBlock.append}{Operation, Operands}{()}{%
    \bi
    \ii Das Label für den Basisblock wird automatisch von der Funktion vergeben
    \ii Ein \ircmd{Goto}/\ircmd{IfGoto} schließt den Basisblock ab
    \ei
  }

  \eii

  \end{frame}
#+end_src
** Codeerzeugung für Ausdrücke
#+begin_src latex
  \begin{frame}[fragile]{Codeerzeugung für Ausdrücke}
    \textbf{Erinnerung}: Ausdrücke sind AST-Unterbäume die Werte berechnen.

    \bi
    \ii Jeder AST-Knotentyp erzeugt anderen Code {
      \bi
      \ii Dynamischer Dispatch anhand des Knotentyps \hfill$\Rightarrow$ Visitor-Pattern
      \ii Fas Ergebnis des Ausdrucks wird in einer temporäre Variable gespeichert. {\\
        \begin{btBlock}[type=info,text width=0.85\textwidth]{}
          Wir werden beliebig viele virtuelle Register erzeugen. Die Abbildung auf reale Register ist Aufgabe der Maschinencode-Erzeugung
        \end{btBlock}
      }
      \ei
    }\medskip
    \ii<2-> Wer entscheidet wo das Ergebnis des Ausdrucks gespeichert wird? {
      \bi
      \ii \textbf{Bottom-Up}: Codegenerierung des Unterbaums erzeugt die Zielvariable{
        \smallskip
        \hspace{1em}\siginline{rvalue\_Add}{Add}{Variable}
        \smallskip
      }
      \ii \textbf{Top-Down}: Codegenerierung bekommt Zielvariable als Parameter{
        \smallskip
        \hspace{1em}\siginline{rvalue\_Add}{Add, Variable}{()}
        \smallskip
      }
      \ii Beide Strategien weitgehend equivalent und Mischungen sind möglich
      \ei
    }
    \ei

  \end{frame}

  \begin{frame}[fragile]{Bottom-Up Codeerzeugung für die Addition}
    \begin{columns}
      \begin{column}{0.28\textwidth}
        \btAnimation[width=\textwidth]{1:<1->}{fig/08-codegen-add}
      \end{column}\hfill%
      \begin{column}{0.7\textwidth}
        \begin{code}[]
          \begin{py}
            class CodeGen:
              ...
              def rvalue_Add(self, expr):
                l = self.rvalue(expr.LHS) # <- dynamic dispatch
                r = self.rvalue(expr.RHS) # <- 
                ret = self.current_function.create_variable()
                self.current_block.append(Add, ret, l, r)
                return ret
          \end{py}
        \end{code}
      \end{column}
    \end{columns}\medskip

    \bi \ii Codegenerierung delegiert das Berechnen der Unterbäume { \bi \ii Alle Visit-Funktionen für Ausdrücke liefern Ergebnis als Rückgabewert \ii Nur Berechnung des R-Werts.
  L-Wert wird Sonderfall in \ircmd{Assign} \ei }\medskip \ii Explizite Traversierung bei der Code Erzeugung{ \bi \ii Wir verwenden absichtlich keine automatische Traversierung des Baums \ii Generierungs-Funktionn verwenden Referenz auf aktuelle Funktion/Block \ii Sie haben als \textbf{Seiteneffekt} das \structure{emittieren} einzelner Instruktionen \ei } \ei
  \end{frame}

  \begin{frame}[fragile]{Code-Erzeugung für Funktionsaufruf und Zuweisung}
    \bi
    \ii \structure{Funktionsaufrufe}{\\[1ex]
    \begin{code}[]
      \begin{py}
        def rvalue_CallExpr(self, call_expr):
          args   = [self.rvalue(arg) for arg in call_expr.arguments]
          callee = self.lvalue(call_expr.callee)
          ret    = self.current_function.create_variable()
          self.current_block.append(Call, ret, callee, *args)
          return ret
      \end{py}
    \end{code}
    \bi
    \ii Wir entscheiden über eine Auswertungsreihenfolge der Argumente
    \ii Auswertung des Callee könnte Label oder Referenz liefern
    \ei
  }\bigskip
  \ii<2-> \structure{Zuweisung} braucht den L-Wert der linken Seite{
    \bi
    \ii Spezieller Visitor für die linken Seiten liefert Referenz \hfill\codebox{\scriptsize lvalue\_Variable()}
    \ii Funktioniert immer: Emittieren eines \ircmd{Store} Befehls
    \ii<3-> \advantage{Optimierung}: Sonderfall für Variablen auf der linken Seite macht IR kompakter
    \ei
    \begin{columns}
      \begin{column}<2->{0.35\textwidth}
        \begin{code}[]
          \begin{codetext}
            t0  := Add 2, 3
            t1  := Reference var
            ,*t1 := Store t0
          \end{codetext}
        \end{code}
      \end{column}\hfill
      \begin{column}<3->{0.35\textwidth}
        \begin{code}[]
          \begin{codetext}
            t0  := Add 2, 3
            var := Assign t0
          \end{codetext}
        \end{code}
      \end{column}
    \end{columns}
  }
  \ei
  \end{frame}
#+end_src
** Codeerzeugung für Kontrollflusskonstrukte
#+begin_src latex
  \begin{frame}[fragile]{Kontrollfluss: Sequenzierung}
    \bi
    \ii \structure{Sequenzierung}: Sequenzielle Codegenerierung für alle Statements {
      \begin{center}
        \begin{minipage}{0.5\linewidth}
          \begin{code}[]
            \begin{py}
              def visit_Block(self, block):
                for stmt in block.statements:
                  self.visit(stmt)
            \end{py}
          \end{code}
        \end{minipage}
      \end{center}
      \bi
      \ii Unterfunktionen hängen Operationen \textit{implizit} an den \codebox{\scriptsize current\_block}\\[0.5ex]
      \ii Invariante: Nach jedem Statement kommt der Kontrollfluss wieder zusammen\\[2ex]
      \uncover<2->{\btAnimation[width=0.7\textwidth]{center,1:<-2>,2:<3>,3:<4>,4:<5->}{fig/08-sequencing}}
      \ei
    }
    \ii<5-> Die Statements etablieren die komplexeren Kontrollflüsse {
      \bi
      \ii Anlegen neuer Basisblöcke und Verbindung über \ircmd{Goto} und \ircmd{IfGoto}
      \ii \textbf{Wichtig}: Ein \texttt{visit()}-Aufruf kann den \texttt{current\_block}-Zeiger umbiegen
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{Kontrollfluss: Selektion}
    \btAnimation[width=\textwidth]{center,range=1-8:<1->}{fig/08-condition}
  \end{frame}

  \begin{frame}{Kontrollfluss: Iteration}
    \btAnimation[width=\textwidth]{center,range=1-8:<1->}{fig/08-loop}
  \end{frame}

  \begin{frame}{Diskussion: Optimierte Codegenerierung}
    \bi
    \ii Die gezeigte Codeerzeugung generiert \alert{ineffizienten Code} {
      \bi
      \ii Fehlender Else-Teil führt zu einem leeren Else-Block und doppeltem \ircmd{Goto}
      \ii Bottom-Up Auswertung führt zu unnötigem \ircmd{Assign} bei der Zuweisung
      \ii Keine Wiederverwendung von temporäre Variablen
      \ei
    }\medskip
    \ii<2-> \textbf{Das ist Absicht!} Es soll die Codeerzeugung vereinfachen. {
      \bi
      \ii Optimierte Codeerzeugung braucht viele Sonderfälle
      \ii Komplexität erhöht die Fehleranfälligkeit
      \ei
    }\medskip
    \ii<3-> Wir verlagern die Arbeit in die Optimierungsphase {
      \bi
      \ii \structure{Copy-Propagation} wird unötige Zuweisungen tilgen
      \ii \structure{Constant-Folding} ersetzt Auswertungen mit konstanten Operanden
      \ii \structure{Dead-Code Elimination}: Sprünge auf Sprünge auflösen, tote Blöcke löschen\\[1ex]
      \ii[$\Rightarrow$] Weiterer Vorteil durch diese \textbf{Trennung der Belange}:\\ Optimierungen werden ebenfalls auf den Code des Benutzers angewendet
      \ei
    }
    \ei

    \OrangeBox<4->{Eine valide Entscheidung für Übersetzer, aber nicht für Interpreter.}
  \end{frame}
#+end_src
** Fallstudie für komplexe Objekte: Records
#+begin_src latex
\dividerframe{Komplexere Objekte\\und\\Operationen}
  \begin{frame}{Komplexere Objekte: Records}
    \begin{btBlock}{Intentionale Unvollständigkeit der Vorlesung}\small
      Der \advantage{Grundstock der Codeerzeugung} ist gelegt und kann beliebig erweitern werden. Um ihnen einen Einblick zu geben, ohne Sie mit endlosen Erzeugungsregeln zu langweilen, werfe ich nur ein \structure{Schlaglicht auf Records}.
    \end{btBlock}

    \bi
    \ii<2-> Records haben mehrere benannte und typisierte Felder {
      \bi
      \ii Ein Record-Objekt kann größer sein als ein einzelnes Maschinenwort
      \ii \ALERT{Aber}: Unsere IR-Maschine kann nur 32-Bit Zahlen speichern und verarbeiten
      \ei
    }\medskip
    \ii<3-> Wir müssen eine Übersetzung des Sprachkonstrukts vornehmen:{
        \bi
        \ii Die Record-Objekte müssen in den Speicher gelegt werden
        \ii Berechnung der relativen und absoluten Feldadressen
        \ii Zugriffe erfolgen über \ircmd{Load}/\ircmd{Store} 
        \ei
    }
    \ei
  \end{frame}

  \begin{frame}[t]{Record-Typen: Datenlayout}
    \bi
    \ii \textbf{Erinnerung (Record)}: Geordnete Sequenz von Paaren (Name, Typ)\\\medskip
    \begin{center}
      \texttt{type(struct bar) = }\typeinline{ = record(("a", int), ("b", foo\_t), ("c", int))}
     \end{center}\medskip
     \ii<2-> Um dessen Objekte im Speicher abzulegen brauchen wir ein \structure{Datenlayout}{%
    \begin{columns}[t]
      \begin{column}{0.49\textwidth}
        \mbox{\strut}\\
        \texttt{layout(struct bar) = }\\[1ex]
        {\small
        \begin{tabular}{lrrr}\toprule
          Name & \uncover<4->{Offset} & Typ    & \uncover<3->{Länge} \\\midrule
          \only<7->{*TAG* & 0 & type\_t  & 4\\}
          a    & \only<4-6>{0} \only<7->{4}    & int    & \uncover<3->{4}     \\
          b    & \only<4-6>{4} \only<7->{8}    & foo\_t & \uncover<3->{5}     \\
  \only<5->{-- & \only<4-6>{9} \only<7->{13}    &        & 3\\}
          c    & \only<5-6>{12}\only<7->{16}    & int    & \uncover<3->{4}  \\\bottomrule
        \end{tabular}
        }
      
        \only<6->{\mbox{}\\[2ex]\texttt{sizeof(struct bar) = } \alt<6>{16}{20}}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \vspace{-1em}
        \bi
        \ii Übersetzer leitet das Layout ab {
          \bi
          \ii<3-> Jeder enthaltende Typ belegt eine gewisse \alert{Anzahl an Bytes} im Speicher.
          \ii<4-> Berechnung eines \structure{Feld-Offsets}.
          \ii<5-> Zusätzliche \structure{Alignment}-Bedingungen durch das Einfügen von Lücken.
          \ii<6-> Es ergibt sich die Größe \textbf{dieses Typs}.
          \ii<7-> Mit dynamische Typen: Tag-Feld
          \ei
        }\smallskip
        \ii<8-> Verwendung des Layout-Deskriptors {
          \bi
          \ii Codeerzeugung
          \ii Debug-Informationen
          \ii Dynamische Introspektion
          \ei
        }
        \ei
      \end{column}
    \end{columns}
  }\ei
  \end{frame}

  \begin{frame}[fragile]{Records: Codeerzeugung}
    \bi
    \ii Codeerzeugung muss an mehreren Stellen angepasst werden {
      \bi
      \ii Variablendeklarationen, Feldzugriffe, Referenzerzeugung
      \ii Parameterübergabe, Rückgabewerte
      \ii Wir streben (beispielhaft) ein Wertemodell für Variablen an
      \ei
    }\medskip
    \ii<2-> \structure{Deklaration einer lokalen Variable} mit Record-Typ{
      \bi
      \ii Unsere IR-Maschine kann nur 32-Bit Variablen $\Rightarrow$ IR-Variable hält Pointer
      \ii Allokation am Stack mittels \ircmd{StackAlloc} und \texttt{sizeof(Type)}
      \ei
      \begin{columns}[t]
        \begin{column}<2->{0.49\textwidth}
          \begin{code}[]
            \begin{py}[style=smaller]
              def visit_VarDecl(self, decl):
                bb = self.current_block
                cf = self.current_function

                # IR-Variable 
                var = cf.create_variable(decl.name)
                decl.IR_var = var

                # ggf. Objekt am Stack anlegen
                if decl.Type.sizeof > 4:
                  bb.append(StackAlloc(var, sizeof))
                    if self.dynamic_types:
                       bb.append(Store, var,
                                 decl.Type.tag)
               \end{py}
          \end{code}
        \end{column}\hfill
        \begin{column}{0.49\textwidth}
          \begin{code}[]
            \begin{lzero}
              var obj : struct foo;
            \end{lzero}
          \end{code}
          \begin{center}
            $\Downarrow$
          \end{center}
          \begin{code}<3->[]
            \begin{codetext}
              obj  := StackAlloc 20
              *obj := Store 12345   // Typ-Tag
            \end{codetext}
          \end{code}\bigskip
        
          \uncover<4->{\textbf{Alternative}: Größere Objekte auf den Heap (\ircmd{HeapAlloc}, \ircmd{HeapFree})}
        \end{column}
      \end{columns}

    }
    \ei
  \end{frame}
  #+end_src
#+begin_src latex
  \begin{frame}[fragile]{Records: Zuweisungen}
    \bi
    \ii Für die Zuweisung brauchen wir \structure{R- und L-Wert} des Record-Objekts {
      \bi
      \ii \textbf{Problem}: Nur Referenz, nicht aber Objekt, passt nicht in eine IR-Variable
      \ii Unsere einfache IR-Sprache erfordert komplexere Codeerzeugung
      \ii<2->[$\Rightarrow$] Wir verwenden die Referenz sowohl als R- als auch als L- Wert
      \ei
      \medskip
      \begin{columns}<2->
        \begin{column}{0.49\textwidth}
          \begin{code}[]
            \begin{py}[style=smaller]
              def rvalue_Identifier(self, expr):
                ...
                if isinstance(expr.Type, RecordType):
                   return expr.decl.IR_var
            \end{py}
          \end{code}
        \end{column}\hfill
        \begin{column}{0.49\textwidth}
          \begin{code}[]
            \begin{py}[style=smaller]
              def rvalue_Identifier(self, expr):
                ...
                if isinstance(expr.Type, RecordType):
                   return expr.decl.IR_var
            \end{py}
          \end{code}
        \end{column}
      \end{columns}

    }
    \bigskip
    \ii<3-> \structure{Zuweisungs}-Operation für größere Objekte (> 4 Bytes){
      \bi
      \ii Am Zuweisungskonten kommen 2 Zeiger für Quelle, als auch für Ziel an
      \ii Verwendung der \texttt{memcpy()}-Hilfsfunktion mit konstanter Größe
      \ei
    }

    \begin{columns}
      \hfill
      \begin{column}{0.30\textwidth}
        \begin{code}[]
          \begin{lzero}
            var x : struct foo;
            var y : struct foo;
            x := y;
          \end{lzero}
        \end{code}
      \end{column}\hfill$\Rightarrow$\hfill
      \begin{column}{0.40\textwidth}
        \begin{code}[]
          \begin{codetext}
            x  := StackAlloc 16
            y  := StackAlloc 16
            t1 := Call memcpy, y, x, 20
          \end{codetext}
        \end{code}
      \end{column}
      \hfil
    \end{columns}

    \ei
  
  \end{frame}

  \begin{frame}[fragile]{Records: Feldzugriffe}
    \begin{columns}
      \begin{column}[t]{0.49\textwidth}
        \btAnimation[width=0.8\textwidth]{raisebox,center,1:<1->}{fig/08-field-access}
      \end{column}\hfill
      \begin{column}[t]{0.23\textwidth}
        \columntitle {L-Wert}
        \begin{code}[]
          \begin{lzero}
            obj.c := 100;
          \end{lzero}
        \end{code}
        \begin{center}
          $\Downarrow$
        \end{center}
        \begin{code}[]
        \begin{codetext}[style=smaller]
            t0  := Add obj, 16
            ,*t0 := Store 100
          \end{codetext}
        \end{code}
      \end{column}
      \begin{column}[t]{0.23\textwidth}
        \columntitle {R-Wert}
        \begin{code}[]
          \begin{lzero}
             y := obj.c;
          \end{lzero}
        \end{code}
        \begin{center}
          $\Downarrow$
        \end{center}
        \begin{code}[]
          \begin{codetext}[style=smaller]
            t0 := Add obj, 16
            t1 := Load t0
            y  := Assign t1
          \end{codetext}
        \end{code}
      \end{column}
    \end{columns}

    \medskip

    \bi
    \ii Ableitung der Feld-Adresse aus Objekt-Adresse und Feld-Offset\\[1ex]{

    \begin{columns}
      \begin{column}{0.49\textwidth}
        \columntitle{L-Wert}
        \bii
        \ii L-Wert von \texttt{lhs} ist \structure{Basisadresse}
        \ii Offset \textbf{statisch} aus Layout bestimmen
        \ii Feldadresse ist Basis+Offset
        \eii

        \columntitle{R-Wert}
        \bii
        \ii Dereferenzierung des L-Werts
        \ii Re-Use: \texttt{lvalue\_FieldAccess()}
        \eii

      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \begin{code}[]
          \begin{py}[style=smaller]
            def lvalue_FieldAccess(self, expr):
              # Basisadresse des Objekts
              lhs_ptr = self.lvalue(expr.lhs)
              # Konstanter Offset des Felds
              layout = expr.Type.layout
              offset = layout[expr.name].offset
              # Adressberechung
              ret = self.current_function\
                    .create_variable()
              self.current_block\
                 .append(Add, ret, lhs_ptr, offset)
              return ret
          \end{py}
        \end{code}
      \end{column}
    \end{columns}
}

    \ei


  \end{frame}
#+end_src


#+begin_src latex
  \begin{frame}[fragile]{Records: Funktionsaufrufe}
    \begin{btBlock}{}
      \textbf{Erinnerung}: Wir wollen Wertemodell für Variablen in der Sprache.
    \end{btBlock}

    \bi
    \ii Wir müssen Record-Objekte in Funktionen und wieder heraus bekommen{%
      \bi
      \ii \textbf{Problem}: Wir können nur 32-Bit Wörter übergeben
      \ii \structure{Call-by-Value}: Der Aufgerufene soll eine Kopie des Objekts bekommen{
        \begin{columns}
          \hfill\begin{column}{0.70\textwidth}
            \begin{code}[]
              \begin{lzero}
                func f(obj : struct foo) : struct foo {
                  obj.c := 33;
                  return obj.c;
                }
              \end{lzero}
            \end{code}
          \end{column}\hfill
        \end{columns}
      }
      \ei
    }\medskip
    \ii<2-> \textbf{Lösung}: Wir führen ein \structure{Aufrufkonvention} für größere Objekte ein{
      \bi
      \ii Für \structure{Parameter}: \btSetTab Der Aufrufende gibt Zeiger auf Orginalobjekt mit.\\
      \btUseTab Der Aufgerufene legt sich eine Kopie als lokales Objekt an\\[2ex]
      \ii Für \structure{Rückgabe}: \btUseTab Aufrufer gibt Zieladdresse als zusätzlichen Parameter mit\\
      \btUseTab Ausschleusen des Rückggabewerts durch \texttt{memcpy()}
      \ei
    }
    \ei
  \end{frame}


  \begin{frame}[fragile]{Records: Beispiel für Funktionsaufruf}
    \begin{columns}[t]
      \begin{column}{0.49\textwidth}
        \columntitle{Aufrufstelle}
        \begin{code}[]
          \begin{lzero}
            var src : struct foo;
            var dst : struct foo;
            dst := f(src);
          \end{lzero}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \columntitle{Funktion}
        \begin{code}[]
          \begin{lzero}[style=smaller]
            func f(obj :struct foo) : struct foo {
              return obj;
            }
          \end{lzero}
        \end{code}
      \end{column}
    \end{columns}

    \begin{columns}[t]
      \begin{column}{0.49\textwidth}
        \begin{center}
          $\Downarrow$
          \begin{code}[]
            \begin{codetext}
              src := StackAlloc 16
              dst := StackAlloc 16
              t0  := Call f, dst, src
            \end{codetext}
          \end{code}
        \end{center}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \begin{center}
          $\Downarrow$
          \begin{code}[]
            \begin{codetext}[style=smaller]
              <Function: f> {
                parameters = [__ret, src]
                variables = [__src]
                <BB: BB0> {
                  // Prologue
                  __src := StackAlloc 16
                  t0  := Call memcpy, __src, src
                  // Function Return
                  t1  := Call memcpy, __ret, __src
                  Return __ret
                }
              }
            \end{codetext}
          \end{code}
        \end{center}
      \end{column}
    \end{columns}
  \end{frame}
#+end_src
* Zusammenfassung

#+begin_src latex
  \begin{frame}{Zusammenfassung}
    \bi
    \ii Zwischencode für eine \structure{sequentielle virtuelle Maschine} {
      \bi
      \ii Stack-Maschine oder Register-Maschine mit unendlich vielen Registern
      \ii 3-Adress-Code bzw. Quadrupel-Notation
      \ei
    }\medskip 
    \ii \structure{CFG-Datenstruktur} nimmt Code während der Erzeugung auf{
      \bi
      \ii Erzeugen neuer Funktionen, Basisblöcke und lokaler Variablen
      \ii Anhängen einer Operation an den aktuellen Basisblock
      \ei
    }\medskip
    \ii Unterschiedliche Codeerzeugung für L-/R-Werte {
      \bi
      \ii \structure{L-Wert}: Visitor erzeugt eine temporäre Variable, die die Referenz enthält
      \ii \structure{R-Wert}: Zurückgegebene Variable enthält berechneten Wert
      \ei
    }\medskip
    \ii \structure{Kontrollstrukturen} (\texttt{if, while}) werden linearisiert {
      \bi
      \ii Erzeugen neuer Basisblöcke und Abbildung des Kontrollflusses auf \ircmd{(If)Goto}
      \ii Trennung der Belange zwischen Codeerzeugung und Optimierer
      \ei
    }\medskip
    \ii Fallbeispiel: Records als \structure{komplexeres Sprachkonstrukt}
    \ei

  \end{frame}
#+end_src
