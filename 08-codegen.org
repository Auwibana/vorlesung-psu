#+TITLE: Programmiersprachen und Übersetzer
#+SUBTITLE: 08 - Zwischencodeerzeugung
#+SETUPFILE: setup.org
#+INCLUDE: export-prologue.org
#+PROPERTY: header-args:latex :tangle yes :noweb yes :tangle-macros yes :tangle-prologue topic :tangle-epilogue endtopic :exports none

#+NAME: topic
#+BEGIN_SRC latex :tangle no
\psuSectionStart{{{{property(ITEM)}}}}{{{{n(block)}}}}
#+END_SRC

#+NAME: endtopic
#+BEGIN_SRC latex :tangle no
\psuSectionStop{{{{property(ITEM)}}}}{{{{n(block,-)}}}}
#+END_SRC

* Gedanken zu dieser Vorlesung                                     :noexport:
- Maschinenmodell für den Zwischencode
  - Register und Stackmaschinen
  - Registermaschine mit unendlichen Registern
  - 3-Address-Codes oder Quadrupel
  - Vorstellung unserer IR Maschine


- Abbildungen der Sprachkonstrukte
  - Der CFG als Datenstruktur
  - Variablenbbildung
  - Einfache Operationen
  - Kontrollflusskonstrukte
  - Extra: (komplexere) Typen + dynamischer Dispatch

* Was leistet die "Zwischencodeerzeugung"?
:PROPERTIES:
:CUSTOM_ID: 08-einleitung
:END:

#+begin_src latex
  \subtitle{{{{subtitle()}}}}
  \begin{frame}
    \maketitle
  \end{frame}

  \begin{frame}{Einordnung in die Vorlesung: Zwischencodeerzeugung}
    \begin{center}
      \includegraphics[page=6,width=0.9\linewidth]{fig/01-overview-small}
    \end{center}
    \bi
    \ii \structure{Zwischencodeerzeugung}: Linearisierung und Übersetzung des ASTs{%
      \bi
      \ii \structure{Zielarchitektur}: Virtuelle Maschinen mit wohldefiniertem Funktionsumfang
      \ii Konkret genug für  Assemblererzeugung, Abstrakt genug für Optimierungen
      \ii Wiederverwendung des Middle- und Backend für \advantage{mehrere Frontend-Sprachen}
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}<handout:3>{Einordnung in den Übersetzerbau}
    \btAnimation[width=\textwidth]{1:<-2>,2:<3>}{fig/08-retargable-compiler}%
    \footnote{Zahlen für Clang (C/C++ Frontend, 700k) und LLVM 9.0 (18 Backends, 1.4M)}

    \bi
    \ii Die Konstruktion eines Übersetzers ist aufwändig und schwierig!{
      \bi
      \ii Assembler im Parser erzeugen ist (manchmal) möglich \hfill(One-Pass Compiler)
      \ii Wiederverwendung von Komponenten erleichtert das portieren (\textasciitilde 60\,\% Re-Use)
      \ei
    }\medskip
    \ii<2-> \structure{Zwischenrepresentation} erhält die Programm-Semantik{
      \bi
      \ii AST ist bereits eine \structure{Intermediate Representation} (IR-Form)
      \ii Der klassische IR-Code: CFG mit Instruktionen für eine sequentielle Maschine
      \ei
    }
    \ei

  \end{frame}
#+end_src

Nachdem wir uns in den letzten zwei Vorlesungen wieder mit Elementen von Programmiersprachen beschäftigt haben, wollen wir uns in dieser, und den nächsten beiden, Vorlesungen anschauenen, wie wir Objekte und Operationen auf die reale Maschine abbilden.
Letztendlich werden wir durch diese Abbildung die verbleibende *Semantische Lücke* zum Maschinencode hin schließen.
Ausgangspunkt dieser Abbildung ist der abstrakte Syntaxbaum, Endpunkt ist eine Programmdatei welche wir zur Ausführung bringen.
Wir befinden uns in den nächsten drei Vorlesungen wieder im Übersetzer, wo wir "von unten" auf die Sprachsemantik blicken und diese "nach unten" auf die Hardware abbilden.
Dazu werden wir einige Konzepte und Techniken kennen lernen, die es uns erlauben einen übersichtlichen Übersetzer zu konstruieren, sowie effiziente Programme zu erzeugen.
Wollen wir also Beginnen.


Der abstrakte Syntaxbaum ist eine hierarchische Darstellung des Programms, welche wir im Parser erzeugt und in der semantischen Analyse auf Validität hin geprüft haben.
Allerdings kennt keine unserer echten Maschinen hierarchische Befehle, sondern am Ende sind alle real-existierenden CPUs sequentielle Maschinen, die einen Befehl nach dem anderen (entlang des Kontrollflusses) ausführen.
Wir müssen die hierarchische Struktur des ASTs *linearisieren*, um sie die sequentielle Semantik der Maschinen abzubilden.

Während Übersetzer in der Frühzeit der Informatik aus dem AST direkt Maschinencode erzeugt haben, hat sich gezeigt, dass ein zusätzlicher Zwischenschritt, in Form von *Zwischencode*, fruchtbar ist.
Er erlaubt es Übersetzer einfacher zu strukturieren, Optimierungen leichter durchzuführen und Komponenten des Übersetzers für verschiedene Programmiersprachen und Zielplattformen wieder zu verwenden.
Dieser Zwischencode, in den wir das Programm übersetzen, ist der Maschinencode einer virtuellen Maschine, die wir einzig und allein zu diesem Zecke definieren.

Den Aspekt der Wiederverwendbarkeit von Übersetzerkomponenten möchte ich an dieser Stelle besonders herausstellen:
Zwar ist es möglich für jede neue Programmiersprache, die man sich erdenkt, auf der grünen Wiese einen neuen Übersetzer anzufangen, jedoch würde ich es Ihnen nicht raten. 
Denn, Übersetzer sind komplexe Programme und die Anwender möchten beständig neue Sprach-Features, effizientere Programme und Support für ihren Lieblingsprozessor.
Ganz selbstverständlich, quasi nebenbei, soll Ihr Übersetzer natürlich auch immer korrekt funktionieren und die versprochene Sprachsemantik eins zu eins einhalten.
Und wehe, wenn ein Anwender eine Besonderheit in ihrer Implementierung (=Bug) gefunden hat und sich, für sein Mission-Critical Programm, darauf verlässt.
Kurzum, eigentlich wollen Sie keinen ganzen Übersetzer schreiben, sondern nur an den Teilen arbeiten für die Sie sich begeistern, den ihre Kunden ihnen bezahlen; der Rest darf von der Stange kommen.

Um nicht für jede Kombination auf Frontend-Sprache und Backend-Platform einen ganzen Übersetzer konstruieren zu müssen, hat der Zwischencode eine zentrale *Scharnierfunktion*.
Jedes Sprach-Frontend hat seinen eigenen Parser und prüft die Sprachregeln ganz nach der intendierten Facón, generiert aber am Ende Zwischenrepresentation des Programms als Zwischencode.
Hierbei ist zu betonen, dass die ASTs der einzelnen Frontends auch schon Zwischenrepresentationen sind, die Semantik des Programms einfangen, aber diese sind nicht kompatibel zueinander.
Erst mit der *Zwischencode-Erzeugung* kommen wir zu einer Zwischenrepresentation (oder "Immediate Representation"), die einer einheitlichen Sprache entspricht.

Auf diesem IR-Code, der Befehle für eine wohldefinierte virtuelle Maschine enthält, können wir Semantik-erhaltende Optimierungen durchführen, bevor wir das Programm an die Plattformabhängigen Backends geben. Dort werden die Befehle der IR-Maschine auf Befehle des jeweiligen Backends abgebildet.

Ein Übersetzer, der diesem Prinzip als Kerngedanke mit sich trägt, ist die Kombination aus *Clang und LLVM*.
Clang ist das Sprachfrontend für C und C++.
Es generiert LLVM IR-Code generiert und hat insgesamt einen Umfang von ungefähr 700.000 Zeilen C++ Code.
Jedoch gibt es noch andere Frontends, die ebenfalls LLVM IR erzeugen:
Das Frontend für Go hat 91k Codezeilen und für Rust sind es 382k Codezeilen.
Hätten wir für jede dieser Sprachen die 1.4M Codezeilen neu entwickelt, so würden wir jetzt auf einem Berg von 5.4M Codezeilen sitzen anstatt jetzt 2.6M.
Natürlich hätten wir, auf dem Weg, im selben Maße mehr Bugs erzeugt und Entwicklerstunden verbraten.
Zwischencode spart also nicht nur Geld, sondern auch Nerven, und ermöglicht schnelle Fortschritte bei der Entwicklung neuer Programmiersprachen zu machen.

Um ihnen einen Eindruck über den LLVM  IR-Code zu geben, zeige ich ihnen kurz den IR-Code für einen rekursiven Fibonacci:

#+begin_example
; Function Attrs: noinline nounwind optnone uwtable
define dso_local i32 @fib(i32) #0 {
  %2 = alloca i32, align 4
  %3 = alloca i32, align 4
  store i32 %0, i32* %3, align 4
  %4 = load i32, i32* %3, align 4
  %5 = icmp sle i32 %4, 1
  br i1 %5, label %6, label %7

; <label>:6:                                      ; preds = %1
  store i32 1, i32* %2, align 4
  br label %15

; <label>:7:                                      ; preds = %1
  %8 = load i32, i32* %3, align 4
  %9 = sub nsw i32 %8, 1
  %10 = call i32 @fib(i32 %9)
  %11 = load i32, i32* %3, align 4
  %12 = sub nsw i32 %11, 2
  %13 = call i32 @fib(i32 %12)
  %14 = add nsw i32 %10, %13
  store i32 %14, i32* %2, align 4
  br label %15

; <label>:15:                                     ; preds = %7, %6
  %16 = load i32, i32* %2, align 4
  ret i32 %16
}
#+end_example

* Virtuelle Maschinen für Zwischencode
:PROPERTIES:
:CUSTOM_ID: 08-ir-code-definition
:END:

Um die Übersetzung vom AST in IR-Code vorzunehmen, müssen wir zunächst die virtuelle Maschine definieren, für die wir die Codeerzeugung durchführen wollen.
Eine solche IR-Maschine zu definieren ist mehr eine Kunst als eine exakte Wissenschaft.
Unterschiedliche Maschinenen-Typen und -Ausprägungen eigenen sich für manche Arten der Optimierungen besser als andere (und umgekehrt).
Auch ist das Abstraktions-Niveau, welches man der IR-Code noch bietet eine Design-Entscheidung, die Einfluss auf die Komplexität des Übersetzers hat.
Daher bedienen sich manche Übersetzer nicht nur einer IR-Maschine, sondern sie haben mehrerere virtuelle Maschinen, die sukkzessive weniger Abstraktionen bieten.
So hat der Rust Übersetzer nicht nur LLVM als Zwischensprache, sondern hat noch eine [[https://blog.rust-lang.org/2016/04/19/MIR.html][High-Level IR (HIR) und eine Mid-Level IR]].

#+begin_src latex
  \dividerframe{Virtuelle Maschinen\\für die\\Zwischencodeereugung}

  \begin{frame}[fragile,t]{Virtuelle Stack- und Register-Maschinen}
    \vspace{-1em}
    \begin{center}
      \begin{tikzpicture}
        \node[operation,rectangle] {+}
          child {node[alt=<1>{operand}{operation,rectangle}] {\alt<1>{3}{Op1}}}
          child {node[alt=<1>{operand}{operation,rectangle}] {\alt<1>{4}{Op2}}};
      \end{tikzpicture}
    \end{center}
  
    \begin{columns}
      \begin{column}{0.49\textwidth}
        \columntitle{Stack-Maschine}
        \bii
        \ii Berechnung findet auf Stack statt
        \ii Operanden gehen über den Stack
        \ii Datenfluss ist implizit
        \ii Unendlich großer Stack
        \eii

        \begin{code}
          \begin{onlyenv}<handout:1|1>
          \begin{codetext}
            push 3
            push 4
            add     // = push(pop() + pop())
          \end{codetext}
          \end{onlyenv}
          \begin{onlyenv}<handout:2-|2->
          \begin{codetext}
            // code(Op1) ->  1 Element am Stack
            // code(Op2) ->  1 Element am Stack
            add     // = push(pop() + pop())
          \end{codetext}
          \end{onlyenv}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \columntitle{Register-Maschine}
        \bii
        \ii Operationen manipulieren Register
        \ii Operanden gehen durch \enquote{Register}
        \ii Register machen Datenfluss sichtbar
        \ii Beliebig viele Register
        \eii
        \begin{code}[]
          \begin{onlyenv}<handout:1|1>
          \begin{codetext}
            r0 = 3
            r1 = 4
            r2 = add r1, r2
          \end{codetext}
          \end{onlyenv}
          \begin{onlyenv}<handout:2-|2->
          \begin{codetext}
            // r1 = code(Op1)
            // r2 = code(Op2)
            r2 = add r1, r2
          \end{codetext}
          \end{onlyenv}
        \end{code}
      \end{column}
    \end{columns}

    \bigskip
    \uncover<handout:2-|3->{$\Rightarrow$ Codeerzeugung für Stack- und Register-Maschinen sieht ähnlich aus.}
  \end{frame}

  \begin{frame}{Design-Kriterien für Virtuelle Maschinen}
    \OrangeBox{\textbf{Vorneweg}: Die Spezifikation einer Virtuellen Maschine ist schwierig}
    \medskip
    \bi
    \ii Wahl des Abstraktionsniveaus: Endlicher oder \alert<2->{unendlicher Registersatz?}{%
      \bi
      \ii Abstraktere Semantik $\Rightarrow$ IR-Code ist näher an Programmstruktur
      \ii Leichtere Codeerzeugung und Optimierung, komplexeres Backend
      \ei
    }\medskip
    \ii Ausführungsmodell: \alert<2->{Register-Maschine} oder Stack-Maschine?{%
      \bi
      \ii Stack-Maschinen haben besonders kompakte Programmdarstellung
      \ii Register-Maschinen sind näher an real-existierenden Prozessoren 
      \ei
    }\medskip
    \ii Verbraucher der IR-Form: Interpreter oder \alert<2->{Übersetzer-Backend}?{
      \bi
      \ii Übersetzer brauchen eine gut analysierbare und veränderbare IR-Form
      \ii Bei Interpretern soll die Ausführung möglichst schnell starten
      \ei
    }
    \bigskip
    \ii<2>[$\Rightarrow$] Wir wählen eine Register-Maschine mit unendlich vielen Registern 
    \ei
  \end{frame}


#+end_src

Grundlegend gibt es zwei Arten von Maschinene-Typen, die für IR-Maschinenen heran gezogen werden: Stack-Maschinen und Register-Maschinen. Beide Typen von Maschinen sind (natürlich) gleich mächtig, haben jedoch ein grundlegend andere virtuelle Architektur. 

Bei der *Stack-Maschine* ist der zentrale Ort der Berechnung ein Operandenstack.
Jeder Befehl verwendet diesen Operandenstack als impliziten Parameter. So legt ~push~ den angegebenen Wert auf den Stack; ~add~ nimmt die obersten beiden Elemente vom Stack, addiert sie, und legt das Ergebnis auf den Stack. Eine Stack-Maschine ist daher ähnlich zur umgekehrten Polnischen Notation (~3 4 +~), bei der die selbe Auswertungsmethode angewendet wird.
Durch den Operandenstack ist der Datenfluss, inbesondere langen Operationssequenzen, nicht mehr offensichtlich, da wir im Programmtext keinen Hinweis darauf finden wo ein Operand herkommt. Wir müssten, beim Betrachten solcher IR-Programme, immer den Operandenstack im Kopf mitdenken. Dazu habe ich keine Lust und ich lehne Stack-Maschinen daher ab[fn::Zur Ehrenrettung von Stack-Maschinen ist aber zu sagen, dass sie für den Übersetzerbau eine wundervolle Eigenschaft haben: Reine Stack-Maschinen-Programme sind automatisch in SSA Form.].

Das prominenteste Beispiel für eine Stack-Maschine als Zwischenrepresentation ist die Java Virtual Maschine, deren IR-Code (der Java-Byte-Code) genau nach diesem Muster funktioniert. Die Zwischenrepresentation von .NET verwendet, mit der Common Interpreter Language (CIL), ebenfalls eine Stack-basierte Zwischensprache.
In beiden Fällen wir der IR-Code allerdings nicht hauptsächlich als Eingabe für ein Übersetzerbackend verwendet, sondern als Eingabeformat für eine interpretierte und Just-in-Time übersetzte Ausführung.

Der andere Typus von IR-Maschinen sind die *Register-Maschinen*.
Dort sind alle Operanden, sowohl Quell- als auch Zieloperanden, explizit an den Operationen vermerkt und sichtbar.
Im Unterschied zu den real-existierenden Register-Maschinen nehmen wir allerdings an, dass es nicht nur eine begrenzte Anzahl von Registern gibt, sondern unendlich viele.
Mit dieser Annahme von unendlich vielen Register verhindern wir, dass wir uns zu früh auf eine konkrete Zielplattform fest legen. Stellen Sie sich vor, wir hätten gesagt, unsere Maschine hat genau 16 Register und am Ende hat die Zielplattform dann 32 oder 8 Register; in beiden Fällen müssten wir das Programm umstrukturieren um eine Abbildung vorzunehmen.

Da die Register nur virtuell sind, können wir ihnen auch symbolische Namen geben (~arg0_a~), anstatt Nummern (~r23~) zu verwenden.
Auf diese Weise wird der IR-Code für uns lesbarer, während es für den Übersetzer (beinahe) keinen Unterschied machen.
Die virtuellen Register sind also sehr ähnlich zu Variablen, weswegen ich auch, im Folgenden, IR-Register und IR-Variablen als austauschbare Begriffe verwende.

Die Codeerzegugung für beide Maschinen-Typen sieht sehr ähnlich aus.
Führen wir bei der Stack-Maschine einen AST-Unterbäumen aus, so beläßt die Berechung ihr Ergebnis auf dem Stack liegen.
Bei Register-Maschinen wird das Ergebnis in ein explizit benanntes Register geschrieben und von anderen Befehlen weiter verarbeitet.

#+begin_src latex
\begin{frame}{3-Address Code (Quadrupel-Notation) }
    \bi
    \ii Programm wird als Folge von Quadrupeln dargestellt {
      \bi
      \ii Quadrupel besteht aus einem Operator und \textbf{maximal} drei Operanden {
        \begin{center}
        \medskip
        \texttt{x := op y, z} 
        \medskip
      \end{center}

      }
      \ii Operanden (\texttt{x,y,z}) können sein:{
        \bi
        \ii \structure{Variablen/temporäre Register} halten ein Maschinenwort
        \ii \structure{Literale} als konstante Operanden
        \ii \structure{Sprungmarke} adressieren andere Operationen
        \ei
      }
      \ei
    }\medskip
    \ii Nur (un-)bedingte Sprünge, keine Schleifen oder Bedingungen {
      \bi
      \ii Sprachkonstrukte werden mit \texttt{goto}/\texttt{ifgoto} linearisiert
      \ii 3-Address Code passt perfekt in Basisblock/CFG Struktur
      \ei
    }
    \ei
    \begin{btBlock}[type=example]{Beispiel: \texttt{if ((*a) <= (4 + b)) ...}}\ttfamily
      t1 := \ircmd{Load} *a\\
      t2 := \ircmd{Add} 4, b\\
      t3 := \ircmd{LessEqual} t1, t2\\
      \ircmd{IfGoto} t3, .BB1, .BB2
    \end{btBlock}
  \end{frame}
#+end_src

Für unsere Register-Maschine wählen wir eine *3-Adress-Maschine*, deren Programme wir in *Quadrupel-Notation* aufschreiben.
Dies bedeutet, dass jeder Befehl einen Operations-Code und maximal drei Operanden adressieren kann.
Dadurch, dass wir 3 Operanden benennen können, kann eine solche Maschine eine zwei-stellige Operation (wie ~Add~) auszuführen ohne einen ihrerer Quelloperanden als impliziten Zieloperanden zu verwenden.

Die Operanden können dabei virtuelle Register (== Variablen), literale Konstanten oder Sprungmarken (Labels) sein. Hervorzuheben ist, dass alle Werte eine feste Maschinenwort-Breite haben; ein weiterer Schritt bei der Annäherung an die Funktionalität einer echten Maschine.

Weiterhin beherrscht eine solche 3-Adress Maschine keine Schleifen oder Bedingungen, sondern ausschließlich *bedingte und unbedingte Sprünge*. Diese Beschränkung auf 2 Kontrollfluss-Operationen passt hervorragend auf die Struktur eines Kontrollflussgraph.
Außerdem sind 3-Adress-Maschinen sehr nahe daran, wie aktuelle RISC Prozessoren funktionieren, die für einfache Operationen ebenfalls 3 Register als Operanden haben.

#+begin_src latex
  \begin{frame}{Für PSÜ: Ein beispielhafter Zwischencode}
    \begin{btBlock}{}
      Für Vorlesung und Übung entwickeln wir einen Zwischencode auf Basis einer Registermaschine mit unendlich vielen Registern. Dazu schauen wir uns Semantik und Notation an.
    \end{btBlock}

    \begin{columns}[t]
      \begin{column}{0.49\textwidth}
        \bi
        \ii \structure{Operanden} können sein:{
          \bi
          \ii (C) Konstante Ganzzahlen: \texttt{3}, \texttt{4}
          \ii (L) Statische Label:  \texttt{.BB2}
          \ii (V) Variablen: \texttt{a}, \texttt{t1}
          \ei
        }
        \ei
      \end{column}\hfill
      \begin{column}{0.49\textwidth}\small
        \bii
        \ii \textbf{Variablen} sind funktions lokal
        \ii Beliebig viele temporäre Variablen
        \ii Alle Werte sind 32-Bit breit 
        \ii Keine Typisierung
        \eii
      \end{column}
    \end{columns}

    \medskip
  
    \bi
    \ii Einfache \structure{Operationen} (6 Befehle) {
      \bi
      \ii \ircmd{Assign}: Einer Variable einen Wert zuweisen \hfill\texttt{V := \ircmd{Assign} CV}
      \ii 4 arithmetrische Operationen: \ircmd{Add}, \ircmd{Sub}, \ircmd{Mul}, \ircmd{Div}  \hfill\texttt{V := \ircmd{Add} CV, CV}
      \ii 1 logische Operation: \ircmd{LessEqual} \hfill\texttt{V := \ircmd{LessEqual} CV, CV}\\
          Falsch: \enquote{0}, Wahr: \enquote{!= 0}
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{Für PSÜ: Ein beispielhafter Zwischencode (2)}
    \bi
    \ii \structure{Speichermanipulationen} (3 Befehle) {
      \bi
      \ii \ircmd{Ref}: \hspace{1.2em}\btSetTab Erzeugen einer Referenz          \hfill\texttt{V := \ircmd{Ref} V}
      \ii \ircmd{Load}: \btUseTab Lesen des addressierten Speicherwortes        \hfill\texttt{V := \ircmd{Load} *V}
      \ii \ircmd{Store}: \btUseTab Schreiben eines Wertes an ein Speicherstelle \hfill\texttt{*V := Store CV}
      \ei
    }\medskip
    \ii \structure{Speichermanagement} (3 Befehle) {
      \bi
      \ii \ircmd{StackAlloc}: \btSetTab Speicherallokation im Call-Frame\hfill\texttt{V := StackAlloc C}
      \ii \ircmd{HeapAlloc}:  \btUseTab Speicherallocation dem Heap\hfill\texttt{V := HeapAlloc C}
      \ii \ircmd{HeapFree}:   \btUseTab Freigabe eines Heap-Objekts\hfill\texttt{HeapFree V}
      \ei
    }\medskip
    \ii \structure{Funktions-lokale Kontrollflüsse} (2 Befehle) {
      \bi
      \ii \ircmd{Goto}:   Sprung an das gegebene Label \hfill\texttt{\ircmd{Goto} L}
      \ii \ircmd{IfGoto}: Bedingter Sprung   \hfill\texttt{\ircmd{IfGoto CV, L, L}}
      \ei
    }\medskip
    \ii \structure{Interprozedurale Kontrollflüsse} (2 Befehle) {
      \bi
      \ii \ircmd{Call}: Funktionsaufruf mit beliebig vielen Argumenten \hfill\texttt{\ircmd{Call} L, [CV]*}
      \ii \ircmd{Return}: Rückkehr aus einer Funktionsinstanz \hfill\texttt{\ircmd{Return} CV}
      \ei
    }
    \ei
  \end{frame}
#+end_src

Um uns die Codeerzeugung im Detail anschauen zu können, wollen wir nun eine *beispielhafte* 3-Address-Maschine mit zugehörigem Zwischencode definieren.
Dabei der Funktionsumfang dieser Maschine nicht vollumfänglich, sodass jede beliebige Programmiersprache darauf abgebildet werden kann.
Insbesondere ist der Umfang der arithmetrischen, logischen und  bit-weisen Operationen sehr eingeschränkt.

Zweck dieser IR-Code-Beschreibung ist es eine Grundlage für die darauf folgende IR-Code-Erzeugung zu legen.
Weiterhin werden wir genau diesen in der Übung verwenden um ein vollständiges Backend, inklusive einem einfachen Optimierer, zu konstruieren.

Grundlegend ist, wie gesagt, unsere IR-Code-Maschine eine Register-Maschine mit unendlich vielen Registern, die wir im folgenden auch Variablen nennen.
Alle Variablen, sowie angegebene Konstanten, sind 32 Bit breit und die Maschine kennt keinerlei Art von Typisierung.
Es wird Sie also niemand davon abhalten das Ergebnis von ~100 * 200~ im Speicher zu dereferenzieren oder dort eine ~23~ hin zu schreiben.
Auf Ebene des IR-Codes gibt es kein Safety-Netz und wir können uns beliebig in den Fuß schießen.
Genau wie auf einer echten Maschine.


Bei den Operanden-Typen haben wir die bereits genannten:
Konstanten (C), Variablen (V) und Label (L).
Auf den Folien sehen Sie bei jeder Operation von welchem Typ die Operanden sein dürfen.
So darf bei der Zuweisungs-Operation (~Assign~) auf der rechten Seite entweder eine Konstante *oder* eine Variable, auf der linken Seite aber nur eine Variable, stehen.
Der Zuweisungs-Operator verändert ausschließlich die explizit angegebene Variable und es wird keine weitere Adressberechnung durchgeführt.

Bei den Variablen ist ebenfalls wichtig, dass unsere Maschine nur funktion-lokale Variablen kennt.
Aus dem vorangegangenen Satz lernen wir 2 Dinge:

1. Es gibt keine globalen Variablen![fn::Diese Einschränkung macht unseren IR-Code ungeeignet als Zielplattform für C zu dienen. Jedoch macht es Optimierung und Backend deutlich einfacher, da nicht an jeder Stelle unterschieden werden muss, ob wir gerade eine lokale oder eine globale Variable vor uns haben.]
2. Es gibt Funktionen!


Insbesondere der zweite Punkt ist bemerkenswert, da Funktionen ja eigentlich ein starke Abstraktion ist, die normale Prozessoren so nicht kennen.
Die Entscheidung diesen Teil des IR-Codes auf einer höheren Abstraktionsstufe zu belassen, ist eine sehr bewusste:
Wir müssen uns an dieser Stelle noch keine Gedanken darum machen, wo unsere lokalen Variablen gespeichert werden, wie wir an unsere Parameter kommen oder wie genau man eine Funktion am Ende aufruft.
Außerdem können wir jede Funktion für sich übersetzen, optimieren und zu Maschinencode überführen.
Sie können sich die IR-Funktionen und ihre Funktionsaufrufe wie ein Hochsprachen-Gerüst vorstellen, welches wir mit Befehlen von deutlich niedrigerem Abstraktionsgrad füllen.

Bei den *einfachen Befehlen* beschränken wir uns auf die 4 Grundrechenarten und lassen alle Bit-Weisen Operationen aus. Zwar könnten wir all diese ebenfalls in den Funktionsumfang aufnehmen, würden dadurch jedoch nur wenig Erkenntnis gewinnen, außer dass man an allen Stellen nicht nur zwischen 4 Operationen, sonder zwischen 45 Operationen unterscheiden muss. Zu gunsten der Übersichtlichkeit bleiben wir hier, absichtlich, unvollständig.

Bei den *logischen Operationen* beschränken wir uns auf das Kleiner-Gleich (~<=~).
Dies ist tatsächlich keine Einschränkung, da alle anderen Vergleichsoperationen daraus abgeleitet werden können.
So kann man ein ~a == b~ zu einem ~(a <= b) * (b <= a)~ umformen.
Die Multiplikation übernimmt an dieser Stelle die Aufgabe des logischen UNDs.
Auf unserer Maschine sind Wahrheitswerte ~0~ (falsch) oder ~!=0~ (wahr).

Neben der Möglichkeit Werte in Variablen zu schreiben, hat unsere Maschine Befehle zur *Speichermanipulation*:K
Sie kann Zeiger auf Variablen mit dem ~Ref~-Befehl erzeugen und in einer Ziel-Variable ablegen.
Der Zeiger-indirekter Zugriff erfolgt dann über den ~Load~ und den ~Store~-Befehl, welche jeweils das adressierte Wort lesen bzw. schreiben.
Die Sternchen an beiden Operationen sind reine Notation und Zierde und sollen uns nur anzeigen, welche der beiden Variablen der Zeiger und welche Ziel- bzw. Quellvariable sind.

Bezüglich der Speichermodells definieren wir, dass unsere Maschine einen Wort-Adressierten Speicher hat.
Es ist einem IR-Programm auch erlaubt einen Zeiger mittels Zeigerarithmetik zu manipulieren, jedoch muss der Zeiger immer innerhalb der Grenzen des gleichen Objekts bleiben.
Dies bedeutet auch, dass eine Referenz auf eine Variable niemals verändert werden kann, da die Variable ja nur ein Wort breit ist.
Ausschließlich Zeiger auf dynamisch angeforderten Speicher können wohldefiniert verändert werden.

Für das *Speichermanagement* stellen wir drei Befehle zur Verfügung um Objekte dynamisch anzulegen:
Mit dem ~StackAlloc~ Befehl kann ein Funktions-lokales Objekt mit der angegebenen Größe (in Worten) im Call-Frame allokiert werden.
Der Rückgabewert von ~StackAlloc~ ist ein Zeiger auf das erste Wort des neuen Objekts.
Funktions-lokale Objekte werden automatisch mit dem Verlassen der aktuellen Funktionsinstanz verworfen.
Anders sieht es mit Heap-allokierten Objekten aus, die mittels ~HeapAlloc~ erstellt und explizit mit ~HeapFree~ wieder frei gegeben werden müssen.
Zu beachten ist hier auch, dass die Größen der allokierten Objekte als Konstanten angegeben werden müssen.

Für die Funktions-lokalen Kontrollflüsse haben wir ~Goto~ (mit einem Label) und ~IfGoto~ (mit einer Bedingung und zwei Labeln).
Beide Befehle leiten den eingehenden Kontrollfluss sicher an eines der angegeben Ziele um und es gibt kein implizites Durchfallen zum nächsten Befehl.
Die Bedingung von ~IfGoto~ wird als Wahrheitswert (~0~ oder ~!= 0~) ausgewertet und bei wahr wird das erste Label, bei falsch das zweite Label angesprungen.

Für den interprozeduralen Kontrollfluss gibt es ~Call~ und ~Return~. Wie bereits gesagt, bleiben beide Befehle auf einem hohen Abstraktionsniveau und ~Call~ bricht sogar das 3-Adress-Modell, da es beliebig viele Argumente transportieren kann.


Insgesamt hat unsere IR-Maschine 16 Befehle. Also eher übersichtlich. 

#+begin_src latex
  \begin{frame}[fragile]{Für PSÜ: Ein Beispielhafter Zwischencode (3)}
    \bi
    \ii \structure{Basisblöcke} {
      \bi
      \ii Geordnete Liste von Operationen
      \ii Jeder Basisblock hat ein (funktions-lokal) eindeutiges Label  \hfill{\texttt{.BB0}},\ldots
      \ii Der letzte Befehl muss ein \ircmd{Goto}, \ircmd{IfGoto}, oder \ircmd{Return} sein.
      \ii[$\Rightarrow$] Maximale Basisblöcke
      \ei

 
    }\bigskip
    \ii \structure{Funktionen} {
      \bi
      \ii Ungeordnete Menge von Basisblöcken mit einem Eingangsblock
      \ii Funktionen haben ein Label, können aber nicht direkt angesprungen werden
      \ii Beliebig viele lokale Variablen und temporäre Register
      \ii Beliebig viele Parameter, die als Variablen zugänglich sind
      \ei
    }
    \ei
    \medskip

    \begin{columns}[t]
      \begin{column}{0.49\textwidth}
        \begin{code}
        \begin{py}
          class BasicBlock:
              def __init__(self, label):
                  self.label = label
                  self.instructions = []
        \end{py}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \begin{code}
        \begin{py}
          class Function:
              def __init__(self, label):
                  self.label = label
                  self.parameters = []
                  self.variables  = []
                  self.entry_block  = None
                  self.basic_blocks = []
        \end{py}
        \end{code}
      \end{column}
    \end{columns}
  \end{frame}

  \begin{frame}[fragile]{Iterativer Fibonacci als Zwischencode}
    \begin{columns}
      \begin{column}{0.45\textwidth}
        \includegraphics[height=0.85\textheight]{fig/08-fib-iter}      
      \end{column}\hfill
      \begin{column}{0.54\textwidth}
        \bi
        \ii Beobachtungen {
          \bi
          \ii BB0 initialisiert die Startwerte
          \ii BB1/2 sind eine while-Schleife
          \ii \texttt{Goto .BB1} spaltet BB0/1
          \ei
        }
        \ei

        \begin{code}[]
          \begin{lzero}
            func fib_iter(n : int) : int {
              var a : int;
              var b : int;
              a := 0;
              b := 1;
              while (n >= 0) {
                var tmp : int;
                tmp := a;
                a := a + b;
                b := tmp;
                n := n - 1;
              }
              return a;
            }
          \end{lzero}
        \end{code}
      \end{column}
    \end{columns}
  \end{frame}
#+end_src

Unser Programm strukturieren wir in Funktionen, die aus mehreren Basisblöcken bestehen.
Dabei hat jeder Basisblock ein eindeutiges Label und besteht aus einer Sequenz von IR-Befehlen, wobei der letzte Befehl eines jeden Blocks ein ~Goto~, ein ~IfGoto~ oder ein ~Return~ sein muss.
Durch diese Verpflichtung jeden Block mit einem Sprung zu beenden befreit uns auf Ebene einer Funktion von der Last über implizites Durchfallen und die Reihenfolge der Basisblöcke nachzudenken.

Daher bestehen Funktionen aus einer ungeordneten Menge von Basisblöcken, von denen einer allerdings der Eingangsblock ist.
An diesem Eingangsblock beginnt die Ausführung beim Funktionsaufruf.
Weiterhin haben Funktionen eine geordnete Liste an Parameter-Variablen und an sonstigen lokalen Variablen.

Auf den Folien finden Sie noch einen iterativen Fibonacci als Beispiel für eine IR-Funktion.


* Vom AST zum Zwischencode
:PROPERTIES:
:CUSTOM_ID: 08-codegen
:END:
** CFG als Datenstruktur
#+begin_src latex
  \dividerframe{Codeerzeugung}
  \begin{frame}{Notwendige Operationen auf CFG und Basisblöcken}
    \begin{btBlock}{}
    \textbf{Schlachtplan}: Wir traversieren den AST einer Funktion und erzeugen dabei einen CFG mit Basisblöcken voller IR-Operationen.
  \end{btBlock}

  \bigskip
  \bii
  \ii Erstelle ein Funktionsobjekt\hspace{1cm}       \btSetTab \siginline{Programm.create\_function}{string}{Function}{%
    \bi
    \ii Funktionen haben den Namen als Label (\scriptsize\codebox{func.label})
    \ii Parameter und Variablen werden beim traversieren erstellt\\[2ex]
    \ei
  }
  \ii Erstelle einen Basisblock          \btUseTab \siginline{Function.create\_block}{()}{BasicBlock}
  \ii Erstelle einen Parameter           \btUseTab \siginline{Function.create\_parameter}{name}{Variable}
  \ii Erstelle eine Variable             \btUseTab \siginline{Function.create\_variable}{}{Variable} {
    \bi
    \ii Variablen und Parameter werden im Funktionsscope verwaltet
    \ii Der erste erstellte Basisblock wird automatisch zum Eingangsblock\\[2ex]
    \ei
  }

  \ii Hänge eine Operation an            \btUseTab \siginline{BasicBlock.append}{Operation, Operands}{()}{%
    \bi
    \ii Das Label für den Basisblock wird automatisch von der Funktion vergeben
    \ii Ein \ircmd{Goto}/\ircmd{IfGoto} schließt den Basisblock ab
    \ei
  }

  \eii

  \end{frame}
#+end_src

Nach der Beschreibung des IR-Codes wollen wir unser eigentliches Ziel definieren:
Wir möchten aus dem abstrakten Syntaxbaum ein IR-Programm ableiten, welches ein Funktions-Objekt mit Basisblöcken voller Befehle für jede Funktion auf AST-Ebene enthält.
Dazu werden wir den AST traversieren und sukkzessive IR-Objekte erzeugen und hierarchisch ineinander Schachteln:
Das Programm enthält mehrere Funktionen; Jede Funktion enthält einen oder mehrere Basisisblöcke; Jeder Basisblock ist eine Sequenz von Befehlen die mit einem Sprungbefehl abgeschlossen wird.

Um diese IR-Objekte zu erzeugen verwenden wir das auf den Folien notierte Programmierschnittstelle.
So hängt die ~create_block()~-Methode einen Basisblock an die aktuelle Funktion an und gibt uns eine Referenz auf den Block zurück[fn::Erinnern Sie sich daran das Python, welches wir im Folgenden verwenden ein Referenzmodell für Variablen hat.
Alle Variablen referenzieren also nur Objekte, sie enthalten niemals ein Objekt und es gibt keine expliziten Zeiger.
Sehr zu meinem Leidwesen....].
Sollten sie bei einer der Funktionen unsicher ob der Semantik sein, so können Sie im Übungsübersetzer nachschlagen.

** Codeerzeugung für Ausdrücke
#+begin_src latex
  \begin{frame}[fragile]{Codeerzeugung für Ausdrücke}
    \textbf{Erinnerung}: Ausdrücke sind AST-Unterbäume die Werte berechnen.

    \bi
    \ii Jeder AST-Knotentyp erzeugt anderen Code {
      \bi
      \ii Dynamischer Dispatch anhand des Knotentyps \hfill$\Rightarrow$ Visitor-Pattern
      \ii Fas Ergebnis des Ausdrucks wird in einer temporäre Variable gespeichert. {\\
        \begin{btBlock}[type=info,text width=0.85\textwidth]{}
          Wir werden beliebig viele virtuelle Register erzeugen. Die Abbildung auf reale Register ist Aufgabe der Maschinencode-Erzeugung
        \end{btBlock}
      }
      \ei
    }\medskip
    \ii<2-> Wer entscheidet wo das Ergebnis des Ausdrucks gespeichert wird? {
      \bi
      \ii \textbf{Bottom-Up}: Codegenerierung des Unterbaums erzeugt die Zielvariable{
        \smallskip
        \hspace{1em}\siginline{rvalue\_Add}{Add}{Variable}
        \smallskip
      }
      \ii \textbf{Top-Down}: Codegenerierung bekommt Zielvariable als Parameter{
        \smallskip
        \hspace{1em}\siginline{rvalue\_Add}{Add, Variable}{()}
        \smallskip
      }
      \ii Beide Strategien weitgehend equivalent und Mischungen sind möglich
      \ei
    }
    \ei

  \end{frame}

  \begin{frame}[fragile]{Bottom-Up Codeerzeugung für die Addition}
    \begin{columns}
      \begin{column}{0.28\textwidth}
        \btAnimation[width=\textwidth]{1:<1->}{fig/08-codegen-add}
      \end{column}\hfill%
      \begin{column}{0.7\textwidth}
        \begin{code}[]
          \begin{py}
            class CodeGen:
              ...
              def rvalue_Add(self, expr):
                l = self.rvalue(expr.LHS) # <- dynamic dispatch
                r = self.rvalue(expr.RHS) # <- 
                ret = self.current_function.create_variable()
                self.current_block.append(Add, ret, l, r)
                return ret
          \end{py}
        \end{code}
      \end{column}
    \end{columns}\medskip

    \bi \ii Codegenerierung delegiert das Berechnen der Unterbäume { \bi \ii Alle Visit-Funktionen für Ausdrücke liefern Ergebnis als Rückgabewert \ii Nur Berechnung des R-Werts.
  L-Wert wird Sonderfall in \ircmd{Assign} \ei }\medskip \ii Explizite Traversierung bei der Code Erzeugung{ \bi \ii Wir verwenden absichtlich keine automatische Traversierung des Baums \ii Generierungs-Funktionn verwenden Referenz auf aktuelle Funktion/Block \ii Sie haben als \textbf{Seiteneffekt} das \structure{emittieren} einzelner Instruktionen \ei } \ei
  \end{frame}

  \begin{frame}[fragile]{Code-Erzeugung für Funktionsaufruf und Zuweisung}
    \bi
    \ii \structure{Funktionsaufrufe}{\\[1ex]
    \begin{code}[]
      \begin{py}
        def rvalue_CallExpr(self, call_expr):
          args   = [self.rvalue(arg) for arg in call_expr.arguments]
          callee = self.lvalue(call_expr.callee)
          ret    = self.current_function.create_variable()
          self.current_block.append(Call, ret, callee, *args)
          return ret
      \end{py}
    \end{code}
    \bi
    \ii Wir entscheiden über eine Auswertungsreihenfolge der Argumente
    \ii Auswertung des Callee könnte Label oder Referenz liefern
    \ei
  }\bigskip
  \ii<2-> \structure{Zuweisung} braucht den L-Wert der linken Seite{
    \bi
    \ii Spezieller Visitor für die linken Seiten liefert Referenz \hfill\codebox{\scriptsize lvalue\_Variable()}
    \ii Funktioniert immer: Emittieren eines \ircmd{Store} Befehls
    \ii<3-> \advantage{Optimierung}: Sonderfall für Variablen auf der linken Seite macht IR kompakter
    \ei
    \begin{columns}
      \begin{column}<2->{0.35\textwidth}
        \begin{code}[]
          \begin{codetext}
            t0  := Add 2, 3
            t1  := Reference var
            ,*t1 := Store t0
          \end{codetext}
        \end{code}
      \end{column}\hfill
      \begin{column}<3->{0.35\textwidth}
        \begin{code}[]
          \begin{codetext}
            t0  := Add 2, 3
            var := Assign t0
          \end{codetext}
        \end{code}
      \end{column}
    \end{columns}
  }
  \ei
  \end{frame}
#+end_src
** Codeerzeugung für Kontrollflusskonstrukte
#+begin_src latex
  \begin{frame}[fragile]{Kontrollfluss: Sequenzierung}
    \bi
    \ii \structure{Sequenzierung}: Sequenzielle Codegenerierung für alle Statements {
      \begin{center}
        \begin{minipage}{0.5\linewidth}
          \begin{code}[]
            \begin{py}
              def visit_Block(self, block):
                for stmt in block.statements:
                  self.visit(stmt)
            \end{py}
          \end{code}
        \end{minipage}
      \end{center}
      \bi
      \ii Unterfunktionen hängen Operationen \textit{implizit} an den \codebox{\scriptsize current\_block}\\[0.5ex]
      \ii Invariante: Nach jedem Statement kommt der Kontrollfluss wieder zusammen\\[2ex]
      \uncover<2->{\btAnimation[width=0.7\textwidth]{center,1:<-2>,2:<3>,3:<4>,4:<5->}{fig/08-sequencing}}
      \ei
    }
    \ii<5-> Die Statements etablieren die komplexeren Kontrollflüsse {
      \bi
      \ii Anlegen neuer Basisblöcke und Verbindung über \ircmd{Goto} und \ircmd{IfGoto}
      \ii \textbf{Wichtig}: Ein \texttt{visit()}-Aufruf kann den \texttt{current\_block}-Zeiger umbiegen
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{Kontrollfluss: Selektion}
    \btAnimation[width=\textwidth]{center,range=1-8:<1->}{fig/08-condition}
  \end{frame}

  \begin{frame}{Kontrollfluss: Iteration}
    \btAnimation[width=\textwidth]{center,range=1-8:<1->}{fig/08-loop}
  \end{frame}

  \begin{frame}{Diskussion: Optimierte Codegenerierung}
    \bi
    \ii Die gezeigte Codeerzeugung generiert \alert{ineffizienten Code} {
      \bi
      \ii Fehlender Else-Teil führt zu einem leeren Else-Block und doppeltem \ircmd{Goto}
      \ii Bottom-Up Auswertung führt zu unnötigem \ircmd{Assign} bei der Zuweisung
      \ii Keine Wiederverwendung von temporäre Variablen
      \ei
    }\medskip
    \ii<2-> \textbf{Das ist Absicht!} Es soll die Codeerzeugung vereinfachen. {
      \bi
      \ii Optimierte Codeerzeugung braucht viele Sonderfälle
      \ii Komplexität erhöht die Fehleranfälligkeit
      \ei
    }\medskip
    \ii<3-> Wir verlagern die Arbeit in die Optimierungsphase {
      \bi
      \ii \structure{Copy-Propagation} wird unötige Zuweisungen tilgen
      \ii \structure{Constant-Folding} ersetzt Auswertungen mit konstanten Operanden
      \ii \structure{Dead-Code Elimination}: Sprünge auf Sprünge auflösen, tote Blöcke löschen\\[1ex]
      \ii[$\Rightarrow$] Weiterer Vorteil durch diese \textbf{Trennung der Belange}:\\ Optimierungen werden ebenfalls auf den Code des Benutzers angewendet
      \ei
    }
    \ei

    \OrangeBox<4->{Eine valide Entscheidung für Übersetzer, aber nicht für Interpreter.}
  \end{frame}
#+end_src
** Fallstudie für komplexe Objekte: Records
#+begin_src latex
\dividerframe{Komplexere Objekte\\und\\Operationen}
  \begin{frame}{Komplexere Objekte: Records}
    \begin{btBlock}{Intentionale Unvollständigkeit der Vorlesung}\small
      Der \advantage{Grundstock der Codeerzeugung} ist gelegt und kann beliebig erweitern werden. Um ihnen einen Einblick zu geben, ohne Sie mit endlosen Erzeugungsregeln zu langweilen, werfe ich nur ein \structure{Schlaglicht auf Records}.
    \end{btBlock}

    \bi
    \ii<2-> Records haben mehrere benannte und typisierte Felder {
      \bi
      \ii Ein Record-Objekt kann größer sein als ein einzelnes Maschinenwort
      \ii \ALERT{Aber}: Unsere IR-Maschine kann nur 32-Bit Zahlen speichern und verarbeiten
      \ei
    }\medskip
    \ii<3-> Wir müssen eine Übersetzung des Sprachkonstrukts vornehmen:{
        \bi
        \ii Die Record-Objekte müssen in den Speicher gelegt werden
        \ii Berechnung der relativen und absoluten Feldadressen
        \ii Zugriffe erfolgen über \ircmd{Load}/\ircmd{Store} 
        \ei
    }
    \ei
  \end{frame}

  \begin{frame}[t]{Record-Typen: Datenlayout}
    \bi
    \ii \textbf{Erinnerung (Record)}: Geordnete Sequenz von Paaren (Name, Typ)\\\medskip
    \begin{center}
      \texttt{type(struct bar) = }\typeinline{ = record(("a", int), ("b", foo\_t), ("c", int))}
     \end{center}\medskip
     \ii<2-> Um dessen Objekte im Speicher abzulegen brauchen wir ein \structure{Datenlayout}{%
    \begin{columns}[t]
      \begin{column}{0.49\textwidth}
        \mbox{\strut}\\
        \texttt{layout(struct bar) = }\\[1ex]
        {\small
        \begin{tabular}{lrrr}\toprule
          Name & \uncover<4->{Offset} & Typ    & \uncover<3->{Länge} \\\midrule
          \only<7->{*TAG* & 0 & type\_t  & 4\\}
          a    & \only<4-6>{0} \only<7->{4}    & int    & \uncover<3->{4}     \\
          b    & \only<4-6>{4} \only<7->{8}    & foo\_t & \uncover<3->{5}     \\
  \only<5->{-- & \only<4-6>{9} \only<7->{13}    &        & 3\\}
          c    & \only<5-6>{12}\only<7->{16}    & int    & \uncover<3->{4}  \\\bottomrule
        \end{tabular}
        }
      
        \only<6->{\mbox{}\\[2ex]\texttt{sizeof(struct bar) = } \alt<6>{16}{20}}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \vspace{-1em}
        \bi
        \ii Übersetzer leitet das Layout ab {
          \bi
          \ii<3-> Jeder enthaltende Typ belegt eine gewisse \alert{Anzahl an Bytes} im Speicher.
          \ii<4-> Berechnung eines \structure{Feld-Offsets}.
          \ii<5-> Zusätzliche \structure{Alignment}-Bedingungen durch das Einfügen von Lücken.
          \ii<6-> Es ergibt sich die Größe \textbf{dieses Typs}.
          \ii<7-> Mit dynamische Typen: Tag-Feld
          \ei
        }\smallskip
        \ii<8-> Verwendung des Layout-Deskriptors {
          \bi
          \ii Codeerzeugung
          \ii Debug-Informationen
          \ii Dynamische Introspektion
          \ei
        }
        \ei
      \end{column}
    \end{columns}
  }\ei
  \end{frame}

  \begin{frame}[fragile]{Records: Codeerzeugung}
    \bi
    \ii Codeerzeugung muss an mehreren Stellen angepasst werden {
      \bi
      \ii Variablendeklarationen, Feldzugriffe, Referenzerzeugung
      \ii Parameterübergabe, Rückgabewerte
      \ii Wir streben (beispielhaft) ein Wertemodell für Variablen an
      \ei
    }\medskip
    \ii<2-> \structure{Deklaration einer lokalen Variable} mit Record-Typ{
      \bi
      \ii Unsere IR-Maschine kann nur 32-Bit Variablen $\Rightarrow$ IR-Variable hält Pointer
      \ii Allokation am Stack mittels \ircmd{StackAlloc} und \texttt{sizeof(Type)}
      \ei
      \begin{columns}[t]
        \begin{column}<2->{0.49\textwidth}
          \begin{code}[]
            \begin{py}[style=smaller]
              def visit_VarDecl(self, decl):
                bb = self.current_block
                cf = self.current_function

                # IR-Variable 
                var = cf.create_variable(decl.name)
                decl.IR_var = var

                # ggf. Objekt am Stack anlegen
                if decl.Type.sizeof > 4:
                  bb.append(StackAlloc(var, sizeof))
                    if self.dynamic_types:
                       bb.append(Store, var,
                                 decl.Type.tag)
               \end{py}
          \end{code}
        \end{column}\hfill
        \begin{column}{0.49\textwidth}
          \begin{code}[]
            \begin{lzero}
              var obj : struct foo;
            \end{lzero}
          \end{code}
          \begin{center}
            $\Downarrow$
          \end{center}
          \begin{code}<3->[]
            \begin{codetext}
              obj  := StackAlloc 20
              *obj := Store 12345   // Typ-Tag
            \end{codetext}
          \end{code}\bigskip
        
          \uncover<4->{\textbf{Alternative}: Größere Objekte auf den Heap (\ircmd{HeapAlloc}, \ircmd{HeapFree})}
        \end{column}
      \end{columns}

    }
    \ei
  \end{frame}
  #+end_src
#+begin_src latex
  \begin{frame}[fragile]{Records: Zuweisungen}
    \bi
    \ii Für die Zuweisung brauchen wir \structure{R- und L-Wert} des Record-Objekts {
      \bi
      \ii \textbf{Problem}: Nur Referenz, nicht aber Objekt, passt nicht in eine IR-Variable
      \ii Unsere einfache IR-Sprache erfordert komplexere Codeerzeugung
      \ii<2->[$\Rightarrow$] Wir verwenden die Referenz sowohl als R- als auch als L- Wert
      \ei
      \medskip
      \begin{columns}<2->
        \begin{column}{0.49\textwidth}
          \begin{code}[]
            \begin{py}[style=smaller]
              def rvalue_Identifier(self, expr):
                ...
                if isinstance(expr.Type, RecordType):
                   return expr.decl.IR_var
            \end{py}
          \end{code}
        \end{column}\hfill
        \begin{column}{0.49\textwidth}
          \begin{code}[]
            \begin{py}[style=smaller]
              def rvalue_Identifier(self, expr):
                ...
                if isinstance(expr.Type, RecordType):
                   return expr.decl.IR_var
            \end{py}
          \end{code}
        \end{column}
      \end{columns}

    }
    \bigskip
    \ii<3-> \structure{Zuweisungs}-Operation für größere Objekte (> 4 Bytes){
      \bi
      \ii Am Zuweisungskonten kommen 2 Zeiger für Quelle, als auch für Ziel an
      \ii Verwendung der \texttt{memcpy()}-Hilfsfunktion mit konstanter Größe
      \ei
    }

    \begin{columns}
      \hfill
      \begin{column}{0.30\textwidth}
        \begin{code}[]
          \begin{lzero}
            var x : struct foo;
            var y : struct foo;
            x := y;
          \end{lzero}
        \end{code}
      \end{column}\hfill$\Rightarrow$\hfill
      \begin{column}{0.40\textwidth}
        \begin{code}[]
          \begin{codetext}
            x  := StackAlloc 16
            y  := StackAlloc 16
            t1 := Call memcpy, y, x, 20
          \end{codetext}
        \end{code}
      \end{column}
      \hfil
    \end{columns}

    \ei
  
  \end{frame}

  \begin{frame}[fragile]{Records: Feldzugriffe}
    \begin{columns}
      \begin{column}[t]{0.49\textwidth}
        \btAnimation[width=0.8\textwidth]{raisebox,center,1:<1->}{fig/08-field-access}
      \end{column}\hfill
      \begin{column}[t]{0.23\textwidth}
        \columntitle {L-Wert}
        \begin{code}[]
          \begin{lzero}
            obj.c := 100;
          \end{lzero}
        \end{code}
        \begin{center}
          $\Downarrow$
        \end{center}
        \begin{code}[]
        \begin{codetext}[style=smaller]
            t0  := Add obj, 16
            ,*t0 := Store 100
          \end{codetext}
        \end{code}
      \end{column}
      \begin{column}[t]{0.23\textwidth}
        \columntitle {R-Wert}
        \begin{code}[]
          \begin{lzero}
             y := obj.c;
          \end{lzero}
        \end{code}
        \begin{center}
          $\Downarrow$
        \end{center}
        \begin{code}[]
          \begin{codetext}[style=smaller]
            t0 := Add obj, 16
            t1 := Load *t0
            y  := Assign t1
          \end{codetext}
        \end{code}
      \end{column}
    \end{columns}

    \medskip

    \bi
    \ii Ableitung der Feld-Adresse aus Objekt-Adresse und Feld-Offset\\[1ex]{

    \begin{columns}
      \begin{column}{0.49\textwidth}
        \columntitle{L-Wert}
        \bii
        \ii L-Wert von \texttt{lhs} ist \structure{Basisadresse}
        \ii Offset \textbf{statisch} aus Layout bestimmen
        \ii Feldadresse ist Basis+Offset
        \eii

        \columntitle{R-Wert}
        \bii
        \ii Dereferenzierung des L-Werts
        \ii Re-Use: \texttt{lvalue\_FieldAccess()}
        \eii

      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \begin{code}[]
          \begin{py}[style=smaller]
            def lvalue_FieldAccess(self, expr):
              # Basisadresse des Objekts
              lhs_ptr = self.lvalue(expr.lhs)
              # Konstanter Offset des Felds
              layout = expr.Type.layout
              offset = layout[expr.name].offset
              # Adressberechung
              ret = self.current_function\
                    .create_variable()
              self.current_block\
                 .append(Add, ret, lhs_ptr, offset)
              return ret
          \end{py}
        \end{code}
      \end{column}
    \end{columns}
}

    \ei


  \end{frame}
#+end_src


#+begin_src latex
  \begin{frame}[fragile]{Records: Funktionsaufrufe}
    \begin{btBlock}{}
      \textbf{Erinnerung}: Wir wollen Wertemodell für Variablen in der Sprache.
    \end{btBlock}

    \bi
    \ii Wir müssen Record-Objekte in Funktionen und wieder heraus bekommen{%
      \bi
      \ii \textbf{Problem}: Wir können nur 32-Bit Wörter übergeben
      \ii \structure{Call-by-Value}: Der Aufgerufene soll eine Kopie des Objekts bekommen{
        \begin{columns}
          \hfill\begin{column}{0.70\textwidth}
            \begin{code}[]
              \begin{lzero}
                func f(obj : struct foo) : struct foo {
                  obj.c := 33;
                  return obj.c;
                }
              \end{lzero}
            \end{code}
          \end{column}\hfill
        \end{columns}
      }
      \ei
    }\medskip
    \ii<2-> \textbf{Lösung}: Wir führen ein \structure{Aufrufkonvention} für größere Objekte ein{
      \bi
      \ii Für \structure{Parameter}: \btSetTab Der Aufrufende gibt Zeiger auf Orginalobjekt mit.\\
      \btUseTab Der Aufgerufene legt sich eine Kopie als lokales Objekt an\\[2ex]
      \ii Für \structure{Rückgabe}: \btUseTab Aufrufer gibt Zieladdresse als zusätzlichen Parameter mit\\
      \btUseTab Ausschleusen des Rückggabewerts durch \texttt{memcpy()}
      \ei
    }
    \ei
  \end{frame}


  \begin{frame}[fragile]{Records: Beispiel für Funktionsaufruf}
    \begin{columns}[t]
      \begin{column}{0.49\textwidth}
        \columntitle{Aufrufstelle}
        \begin{code}[]
          \begin{lzero}
            var src : struct foo;
            var dst : struct foo;
            dst := f(src);
          \end{lzero}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \columntitle{Funktion}
        \begin{code}[]
          \begin{lzero}[style=smaller]
            func f(obj :struct foo) : struct foo {
              return obj;
            }
          \end{lzero}
        \end{code}
      \end{column}
    \end{columns}

    \begin{columns}[t]
      \begin{column}{0.49\textwidth}
        \begin{center}
          $\Downarrow$
          \begin{code}[]
            \begin{codetext}
              src := StackAlloc 16
              dst := StackAlloc 16
              t0  := Call f, dst, src
            \end{codetext}
          \end{code}
        \end{center}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \begin{center}
          $\Downarrow$
          \begin{code}[]
            \begin{codetext}[style=smaller]
              <Function: f> {
                parameters = [__ret, src]
                variables = [__src]
                <BB: BB0> {
                  // Prologue
                  __src := StackAlloc 16
                  t0  := Call memcpy, __src, src
                  // Function Return
                  t1  := Call memcpy, __ret, __src
                  Return __ret
                }
              }
            \end{codetext}
          \end{code}
        \end{center}
      \end{column}
    \end{columns}
  \end{frame}
#+end_src

#+begin_src latex
  \begin{frame}{Records: Fazit}
    \bi
    \ii Records und Wertemodell haben nicht gut in unser IR-Modell gepasst {
      \bi
      \ii Variablen sind nur 32-Bit
      \ii Abbildung des Wertemodell auf Referenzen 
      \ei
    }\bigskip
    \ii Codeerzeugung verhält sich abhängig vom Typ völlig anders {
      \bi
      \ii Zuweisungs-Operation bekommt Referenz auf Record-Objekte als R-Wert
      \ii Besondere Aufrufkonvention für Record-Objekte
      \ii Zeiger auf Record-Objekte sind kein Problem (\codebox{\scriptsize \&struct foo})
      \ei
    }\bigskip
    \ii Notwendigkeit einer Bibliothek mit Laufzeitfunktionen {
      \bi
      \ii Übersetzer verlässt sich auf die Existenz von Bibliotheksfunktionen (\texttt{memcpy()}
      \ii Erweiterung des IR-Codes durch Funktionen (\ircmd{Call}: Komplexbefehl)
      \ei
    }
    \ei
  
  \end{frame}
#+end_src
* Zusammenfassung

#+begin_src latex
  \begin{frame}{Zusammenfassung}
    \bi
    \ii Zwischencode für eine \structure{sequentielle virtuelle Maschine} {
      \bi
      \ii Stack-Maschine oder Register-Maschine mit unendlich vielen Registern
      \ii 3-Adress-Code bzw. Quadrupel-Notation
      \ei
    }\medskip 
    \ii \structure{CFG-Datenstruktur} nimmt Code während der Erzeugung auf{
      \bi
      \ii Erzeugen neuer Funktionen, Basisblöcke und lokaler Variablen
      \ii Anhängen einer Operation an den aktuellen Basisblock
      \ei
    }\medskip
    \ii Unterschiedliche Codeerzeugung für L-/R-Werte {
      \bi
      \ii \structure{L-Wert}: Visitor erzeugt eine temporäre Variable, die die Referenz enthält
      \ii \structure{R-Wert}: Zurückgegebene Variable enthält berechneten Wert
      \ei
    }\medskip
    \ii \structure{Kontrollstrukturen} (\texttt{if, while}) werden linearisiert {
      \bi
      \ii Erzeugen neuer Basisblöcke und Abbildung des Kontrollflusses auf \ircmd{(If)Goto}
      \ii Trennung der Belange zwischen Codeerzeugung und Optimierer
      \ei
    }\medskip
    \ii Fallbeispiel: Records als \structure{komplexeres Sprachkonstrukt}
    \ei

  \end{frame}
#+end_src
