#+TITLE: Programmiersprachen und Übersetzer
#+SUBTITLE: 08 - Zwischencodeerzeugung
#+SETUPFILE: setup.org
#+INCLUDE: export-prologue.org
#+PROPERTY: header-args:latex :tangle yes :noweb yes :tangle-macros yes :tangle-prologue topic :tangle-epilogue endtopic :exports none

#+NAME: topic
#+BEGIN_SRC latex :tangle no
\psuSectionStart{{{{property(ITEM)}}}}{{{{n(block)}}}}
#+END_SRC

#+NAME: endtopic
#+BEGIN_SRC latex :tangle no
\psuSectionStop{{{{property(ITEM)}}}}{{{{n(block,-)}}}}
#+END_SRC

* Gedanken zu dieser Vorlesung                                     :noexport:
- Maschinenmodell für den Zwischencode
  - Register und Stackmaschinen
  - Registermaschine mit unendlichen Registern
  - 3-Address-Codes oder Quadrupel
  - Vorstellung unserer IR Maschine


- Abbildungen der Sprachkonstrukte
  - Der CFG als Datenstruktur
  - Variablenbbildung
  - Einfache Operationen
  - Kontrollflusskonstrukte
  - Extra: (komplexere) Typen + dynamischer Dispatch

* Was leistet die "Zwischencodeerzeugung"?
:PROPERTIES:
:CUSTOM_ID: 08-einleitung
:END:

#+begin_src latex
  \subtitle{{{{subtitle()}}}}
  \begin{frame}
    \maketitle
  \end{frame}

  \begin{frame}{Einordnung in die Vorlesung: Zwischencodeerzeugung}
    \begin{center}
      \includegraphics[page=6,width=0.9\linewidth]{fig/01-overview-small}
    \end{center}
    \bi
    \ii \structure{Zwischencodeerzeugung}: Linearisierung und Übersetzung des ASTs{%
      \bi
      \ii \structure{Zielarchitektur}: Virtuelle Maschinen mit wohldefiniertem Funktionsumfang
      \ii Konkret genug für  Assemblererzeugung, Abstrakt genug für Optimierungen
      \ii Wiederverwendung des Middle- und Backend für \advantage{mehrere Frontend-Sprachen}
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{Einordnung in den Übersetzerbau}
    \btAnimation[width=\textwidth]{1:<-2>,2:<3>}{fig/08-retargable-compiler}%
    \footnote{Zahlen sind für Clang (C/C++ Frontend, 700k)und LLVM 9.0 (1.4M)}

    \bi
    \ii Die Konstruktion eines Übersetzers ist aufwändig und schwierig!{
      \bi
      \ii Assembler im Parser erzeugen ist (manchmal) möglich \hfill(One-Pass Compiler)
      \ii Wiederverwendung von Komponenten erleichtert das portieren (\textasciitilde 60\,\% Re-Use)
      \ei
    }\medskip
    \ii<2-> \structure{Zwischenrepresentation} erhält die Programm-Semantik{
      \bi
      \ii AST ist bereits eine \structure{Intermediate Representation} (IR-Form)
      \ii Der klassische IR-Code: CFG mit Instruktionen für eine virtuelle Maschine
      \ei
    }
    \ei

  \end{frame}
#+end_src

* Virtuelle Maschinen für Zwischencode
#+begin_src latex
  \dividerframe{Virtuelle Maschinen\\für die\\Zwischencodeereugung}

  \begin{frame}[fragile,t]{Virtuelle Stack- und Register-Maschinen}
    \begin{center}
      \begin{tikzpicture}
        \node[operation,rectangle] {+}
          child {node[alt=<1>{operand}{operation,rectangle}] {\alt<1>{3}{Op1}}}
          child {node[alt=<1>{operand}{operation,rectangle}] {\alt<1>{4}{Op2}}};
      \end{tikzpicture}
    \end{center}
  
    \begin{columns}
      \begin{column}{0.49\textwidth}
        \columntitle{Stack-Maschine}
        \bii
        \ii Berechnung findet auf Stack statt
        \ii Operanden gehen über den Stack
        \ii Datenfluss ist implizit
        \ii Unendlich großer Stack
        \eii

        \begin{code}
          \begin{onlyenv}<1>
          \begin{codetext}
            push 3
            push 4
            add     // = push(pop() + pop())
          \end{codetext}
          \end{onlyenv}
          \begin{onlyenv}<2->
          \begin{codetext}
            // code(Op1) ->  1 Element am Stack
            // code(Op2) ->  1 Element am Stack
            add     // = push(pop() + pop())
          \end{codetext}
          \end{onlyenv}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \columntitle{Register-Maschine}
        \bii
        \ii Operationen manipulieren Register
        \ii Operanden gehen durch \enquote{Register}
        \ii Register machen Datenfluss sichtbar
        \ii Beliebig viele Register
        \eii
        \begin{code}[]
          \begin{onlyenv}<1>
          \begin{codetext}
            r0 = 3
            r1 = 4
            r2 = add r1, r2
          \end{codetext}
          \end{onlyenv}
          \begin{onlyenv}<2->
          \begin{codetext}
            // r1 = code(Op1)
            // r2 = code(Op2)
            r2 = add r1, r2
          \end{codetext}
          \end{onlyenv}
        \end{code}
      \end{column}
    \end{columns}

    \bigskip
    \uncover<3->{$\Rightarrow$ Codeerzeugung für Stack- und Register-Maschinen sieht ähnlich aus.}
  \end{frame}

  \begin{frame}{Design-Kriterien für Virtuelle Maschinen}
    \OrangeBox{\textbf{Vorneweg}: Die Spezifikation einer Virtuellen Maschine ist schwierig}
    \medskip
    \bi
    \ii Wahl des Abstraktionsniveaus: Endlicher oder \alert<2->{unendlicher Registersatz?}{%
      \bi
      \ii Abstraktere Semantik $\Rightarrow$ IR-Code ist näher an Programmstruktur
      \ii Leichtere Codeerzeugung und Optimierung, komplexeres Backend
      \ei
    }\medskip
    \ii Ausführungsmodell: \alert<2->{Register-Maschine} oder Stack-Maschine?{%
      \bi
      \ii Stack-Maschinen haben besonders kompakte Programmdarstellung
      \ii Register-Maschinen sind näher an real-existierenden Prozessoren 
      \ei
    }\medskip
    \ii Verbraucher der IR-Form: Interpreter oder \alert<2->{Übersetzer-Backend}?{
      \bi
      \ii Übersetzer brauchen eine gut analysierbare und veränderbare IR-Form
      \ii Bei Interpretern soll die Ausführung möglichst schnell starten
      \ei
    }
    \bigskip
    \ii<2>[$\Rightarrow$] Wir wählen eine Register-Maschine mit unendlich vielen Registern 
    \ei
  \end{frame}


#+end_src

#+begin_src latex
\begin{frame}{3-Address Code (Quadrupel-Notation) }
    \bi
    \ii Programm wird als Folge von Quadrupeln dargestellt {
      \bi
      \ii Quadrupel besteht aus einem Operator und \textbf{maximal} drei Operanden {
        \begin{center}
        \medskip
        \texttt{x := op y, z} 
        \medskip
      \end{center}

      }
      \ii Operanden (\texttt{x,y,z}) können sein:{
        \bi
        \ii \structure{Variablen/temporäre Register} halten ein Maschinenwort
        \ii \structure{Literale} als konstante Operanden
        \ii \structure{Label} dressieren andere Operationen
        \ei
      }
      \ei
    }\medskip
    \ii Nur (un-)bedingte Sprünge, keine Schleifen oder Bedingungen {
      \bi
      \ii Sprachkonstrukte werden mit \texttt{goto}/\texttt{ifgoto} linearisiert
      \ii 3-Address Code passt perfekt in Basisblock/CFG Struktur
      \ei
    }
    \ei
    \begin{btBlock}[type=example]{Beispiel: \texttt{if ((*a) <= (4 + b)) ...}}\ttfamily
      t1 := \ircmd{Load} a\\
      t2 := \ircmd{Add} 4, b\\
      t3 := \ircmd{LessEqual} t1, t2\\
      \ircmd{IfGoto} t3, .BB1, .BB2
    \end{btBlock}
  \end{frame}
#+end_src

#+begin_src latex
  \begin{frame}{Für PSÜ: Ein beispielhafter Zwischencode}
    \begin{btBlock}{}
      Für Vorlesung und Übung entwickeln wir einen Zwischencode auf Basis einer Registermaschine mit unendlich vielen Registern. Dazu schauen wir uns Semantik und Notation an.
    \end{btBlock}

    \begin{columns}[t]
      \begin{column}{0.49\textwidth}
        \bi
        \ii \structure{Operanden} können sein:{
          \bi
          \ii (C) Konstante Ganzzahlen: \texttt{3}, \texttt{4}
          \ii (L) Statische Label:  \texttt{.BB2}
          \ii (V) Variablen: \texttt{a}, \texttt{t1}
          \ei
        }
        \ei
      \end{column}\hfill
      \begin{column}{0.49\textwidth}\small
        \bii
        \ii \textbf{Variablen} sind funktions lokal
        \ii Beliebig viele temporäre Variablen
        \ii Alle Werte sind 32-Bit breit 
        \ii Keine Typisierung
        \eii
      \end{column}
    \end{columns}

    \medskip
  
    \bi
    \ii Einfache \structure{Operationen} (6 Befehle) {
      \bi
      \ii \ircmd{Assign}: Einer Variable einen Wert zuweisen \hfill\texttt{V := \ircmd{Assign} b}
      \ii 4 arithmetrische Operationen: \ircmd{Add}, \ircmd{Sub}, \ircmd{Mul}, \ircmd{Div}  \hfill\texttt{V := \ircmd{Add} CV, CV}
      \ii 1 logische Operation: \ircmd{LessEqual} \hfill\texttt{V := \ircmd{LessEqual} CV, CV}\\
          Falsch: \enquote{0}, Wahr: \enquote{!= 0}
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{Für PSÜ: Ein beispielhafter Zwischencode (2)}
    \bi
    \ii \structure{Speichermanipulationen} (3 Befehle) {
      \bi
      \ii \ircmd{Ref}: \hspace{1.2em}\btSetTab Erzeugen einer Referenz          \hfill\texttt{V := \ircmd{Ref} LV}
      \ii \ircmd{Load}: \btUseTab Lesen des addressierten Speicherwortes        \hfill\texttt{V := \ircmd{Load} V}
      \ii \ircmd{Store}: \btUseTab Schreiben eines Wertes an ein Speicherstelle \hfill\texttt{*V := Store CV}
      \ei
    }\medskip
    \ii \structure{Speichermanagement} (3 Befehle) {
      \bi
      \ii \ircmd{StackAlloc}: \btSetTab Speicherallokation im Call-Frame\hfill\texttt{V := StackAlloc C}
      \ii \ircmd{HeapAlloc}:  \btUseTab Speicherallocation dem Heap\hfill\texttt{V := HeapAlloc C}
      \ii \ircmd{HeapFree}:   \btUseTab Freigabe eines Heap-Objekts\hfill\texttt{HeapFree V}
      \ei
    }\medskip
    \ii \structure{Funktions-lokale Kontrollflüsse} (2 Befehle) {
      \bi
      \ii \ircmd{Goto}:   Sprung an das gegebene Label \hfill\texttt{\ircmd{Goto} L}
      \ii \ircmd{IfGoto}: Bedingter Sprung   \hfill\texttt{\ircmd{IfGoto CV, L, L}}
      \ei
    }\medskip
    \ii \structure{Interprozedurale Kontrollflüsse} (2 Befehle) {
      \bi
      \ii \ircmd{Call}: Funktionsaufruf mit beliebig vielen Argumenten \hfill\texttt{\ircmd{Call} LV, [CV]*}
      \ii \ircmd{Return}: Rückkehr aus einer Funktionsinstanz \hfill\texttt{\ircmd{Return} CV}
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[fragile]{Für PSÜ: Ein Beispielhafter Zwischencode (3)}
    \bi
    \ii \structure{Basisblöcke} {
      \bi
      \ii Geordnete Liste von Operationen
      \ii Jeder Basisblock hat ein (funktions-lokal) eindeutiges Label  \hfill{\texttt{.BB0}},\ldots
      \ii Der letzte Befehl eines Basisblocks muss ein \ircmd{Goto} oder \ircmd{IfGoto} sein.
      \ii[$\Rightarrow$] Maximale Basisblöcke
      \ei

 
    }\bigskip
    \ii \structure{Funktionen} {
      \bi
      \ii Ungeordnete Menge von Basisblöcken mit einem Eingangsblock
      \ii Funktionen haben ein Label, können aber nicht direkt angesprungen werden
      \ii Beliebig viele lokale Variablen und temporäre Register
      \ii Beliebig viele Parameter, die als Variablen zugänglich sind
      \ei
    }
    \ei
    \medskip

    \begin{columns}[t]
      \begin{column}{0.49\textwidth}
        \begin{code}
        \begin{py}
          class BasicBlock:
              def __init__(self, label):
                  self.label = label
                  self.instructions = []
                  self.successors = []
        \end{py}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \begin{code}
        \begin{py}
          class Function:
              def __init__(self, label):
                  self.label = label
                  self.parameters = []
                  self.variables  = []
                  self.entry_block  = None
                  self.basic_blocks = []
        \end{py}
        \end{code}
      \end{column}
    \end{columns}
  \end{frame}

  \begin{frame}[fragile]{Iterativer Fibonacci als Zwischencode}
    \begin{columns}
      \begin{column}{0.45\textwidth}
        \includegraphics[height=0.85\textheight]{fig/08-fib-iter}      
      \end{column}\hfill
      \begin{column}{0.54\textwidth}
        \bi
        \ii Beobachtungen {
          \bi
          \ii BB0 initialisiert die Startwerte
          \ii BB1/2 sind eine while-Schleife
          \ii \texttt{Goto .BB1} spaltet BB0/1
          \ei
        }
        \ei

        \begin{code}[]
          \begin{lzero}
            func fib_iter(n : int) : int {
              var a : int;
              var b : int;
              a := 0;
              b := 1;
              while (n >= 0) {
                var tmp : int;
                tmp := a;
                a := a + b;
                b := tmp;
                n := n - 1;
              }
              return a;
            }
          \end{lzero}
        \end{code}
      \end{column}
    \end{columns}
  \end{frame}
#+end_src

* Codeerzeugung für Zwischencode
** CFG als Datenstruktur
#+begin_src latex
  \dividerframe{Codeerzeugung}
  \begin{frame}{Notwendige Operationen auf CFG und Basisblöcken}
    \begin{btBlock}{}
    \textbf{Schlachtplan}: Wir traversieren den AST einer Funktion und erzeugen dabei einen CFG mit Basisblöcken voller IR-Operationen.
  \end{btBlock}

  \bigskip
  \bii
  \ii Erstelle ein Funktionsobjekt\hspace{1cm}       \btSetTab \siginline{Programm.create\_function}{string}{Function}{%
    \bi
    \ii Funktionen haben den Namen als Label (\scriptsize\codebox{func.label})
    \ii Parameter und Variablen werden beim traversieren erstellt\\[2ex]
    \ei
  }
  \ii Erstelle einen Basisblock          \btUseTab \siginline{Function.create\_block}{()}{BasicBlock}
  \ii Erstelle einen Parameter           \btUseTab \siginline{Function.create\_parameter}{name}{Variable}
  \ii Erstelle eine Variable             \btUseTab \siginline{Function.create\_variable}{}{Variable} {
    \bi
    \ii Variablen und Parameter werden im Funktionsscope verwaltet
    \ii Der erste erstellte Basisblock wird automatisch zum Eingangsblock\\[2ex]
    \ei
  }

  \ii Hänge eine Operation an            \btUseTab \siginline{BasicBlock.append}{Operation, Operands}{()}{%
    \bi
    \ii Das Label für den Basisblock wird automatisch von der Funktion vergeben
    \ii Ein \ircmd{Goto}/\ircmd{IfGoto} schließt den Basisblock ab
    \ei
  }

  \eii

  \end{frame}
#+end_src
** Codeerzeugung für Ausdrücke
#+begin_src latex
  %%ONLY%%
  \begin{frame}[fragile]{Codeerzeugung für Ausdrücke}
    \textbf{Erinnerung}: Ausdrücke sind AST-Unterbäume die Werte berechnen.

    \bi
    \ii Jeder AST-Knotentyp erzeugt anderen Code {
      \bi
      \ii Dynamischer Dispatch anhand des Knotentyps \hfill$\Rightarrow$ Visitor-Pattern
      \ii Fas Ergebnis des Ausdrucks wird in einer temporäre Variable gespeichert. {\\
        \begin{btBlock}[type=info,text width=0.85\textwidth]{}
          Wir werden beliebig viele virtuelle Register erzeugen. Die Abbildung auf reale Register ist Aufgabe der Maschinencode-Erzeugung
        \end{btBlock}
      }
      \ei
    }\medskip
    \ii<2-> Wer entscheidet wo das Ergebnis des Ausdrucks gespeichert wird? {
      \bi
      \ii \textbf{Bottom-Up}: Codegenerierung des Unterbaums erzeugt die Zielvariable{
        \smallskip
        \hspace{1em}\siginline{visit\_Add}{Add}{Variable}
        \smallskip
      }
      \ii \textbf{Top-Down}: Codegenerierung bekommt Zielvariable als Parameter{
        \smallskip
        \hspace{1em}\siginline{visit\_Add}{Add, Variable}{()}
        \smallskip
      }
      \ii Beide Strategien weitgehend equivalent und Mischungen sind möglich
      \ei
    }
    \ei

  \end{frame}

  \begin{frame}[fragile]{Bottom-Up Codeerzeugung für die Addition}
    \begin{columns}
      \begin{column}{0.28\textwidth}
        \btAnimation[width=\textwidth]{1:<1->}{fig/08-codegen-add}
      \end{column}\hfill%
      \begin{column}{0.7\textwidth}
        \begin{code}[]
          \begin{py}
            class CodeGen:
              ...
              def visit_Add(self, expr):
                l = self.visit(expr.LHS) # <- dynamic dispatch
                r = self.visit(expr.RHS) # <- 
                ret = self.current_function.create_variable()
                self.current_block.append(Add, ret, l, r)
                return ret
          \end{py}
        \end{code}
      \end{column}
    \end{columns}\medskip

    \bi \ii Codegenerierung delegiert das Berechnen der Unterbäume { \bi \ii Alle Visit-Funktionen für Ausdrücke liefern Ergebnis als Rückgabewert \ii Nur Berechnung des R-Werts.
  L-Wert wird Sonderfall in \ircmd{Assign} \ei }\medskip \ii Explizite Traversierung bei der Code Erzeugung{ \bi \ii Wir verwenden absichtlich keine automatische Traversierung des Baums \ii Generierungs-Funktionn verwenden Referenz auf aktuelle Funktion/Block \ii Sie haben als \textbf{Seiteneffekt} das \structure{emittieren} einzelner Instruktionen \ei } \ei
  \end{frame}

  \begin{frame}[fragile]{Code-Erzeugung für Funktionsaufruf und Zuweisung}
    \bi
    \ii \structure{Funktionsaufrufe}{\\[1ex]
    \begin{code}[]
      \begin{py}
        def visit_CallExpr(self, call_expr):
          args   = [self.visit(arg) for arg in call_expr.arguments]
          callee = self.visit(call_expr.callee)
          ret    = self.current_function.create_variable()
          self.current_block.append(Call, ret, callee, *args)
          return ret
      \end{py}
    \end{code}
    \bi
    \ii Wir entscheiden über eine Auswertungsreihenfolge der Argumente
    \ii Auswertung des Callee könnte Label oder Referenz liefern
    \ei
  }\bigskip
  \ii<2-> \structure{Zuweisung} braucht den L-Wert der linken Seite{
    \bi
    \ii Spezieller Visitor für die linken Seiten liefert Referenz \hfill\codebox{\scriptsize lvalue\_Variable()}
    \ii Funktioniert immer: Emittieren eines \ircmd{Store} Befehls
    \ii<3-> \advantage{Optimierung}: Sonderfall für Variablen auf der linken Seite macht IR kompakter
    \ei
    \begin{columns}
      \begin{column}<2->{0.35\textwidth}
        \begin{code}[]
          \begin{codetext}
            t0  := Add 2, 3
            t1  := Reference var
            ,*t1 := Store t0
          \end{codetext}
        \end{code}
      \end{column}\hfill
      \begin{column}<3->{0.35\textwidth}
        \begin{code}[]
          \begin{codetext}
            t0  := Add 2, 3
            var := Assign t0
          \end{codetext}
        \end{code}
      \end{column}
    \end{columns}
  }
  \ei
  \end{frame}
#+end_src
** Codeerzeugung für Kontrollflusskonstrukte

** Fallstudie für komplexe Objekte: Records

** Fallstudie für komplexe Operationen: Dynamischer Dispatch
