#+TITLE: Programmiersprachen und Übersetzer
#+SUBTITLE: 06 - Objekte
#+SETUPFILE: setup.org
#+INCLUDE: export-prologue.org
#+PROPERTY: header-args:latex :tangle yes :noweb yes :tangle-macros yes :tangle-prologue topic :tangle-epilogue endtopic :exports none

#+NAME: topic
#+BEGIN_SRC latex :tangle no
\psuSectionStart{{{{property(ITEM)}}}}{{{{n(block)}}}}
#+END_SRC

#+NAME: endtopic
#+BEGIN_SRC latex :tangle no
\psuSectionStop{{{{property(ITEM)}}}}{{{{n(block,-)}}}}
#+END_SRC

* Gedanken zu dieser Vorlesung                                     :noexport:
Stoffsammlung:
  - Lebenszyklus eines Objekts, Lebenszeit
  - Geburt und Initialisierung
    - Speicherallokation
    - Initialisierung 
    - Referenz vs. Value Model
  - Während der Lebenszeit
    - Getter und Setter
    - Problem: Paralleler Zugriff
    - Ownership of an Object
    - Read-Only Access
    - Immutable Objects
  - Garbage Collection  und Tod
    - Deinitialisierung
    - Reference Counting
    - Automatic Garbage Collection

Was soll der Studierende aus dieser Vorlesung mitnehmen?
  - Welche Besonderheiten kann eine Sprache bzgl. ihrer Objekte haben? [Effektiv]
  - Was bedeutet es ein Objekt zu kopieren?                            [Effizient]
* Was ist ein "Objekt"?
:PROPERTIES:
:CUSTOM_ID: 06-einleitung
:END:

#+begin_src latex
  \subtitle{{{{subtitle()}}}}
  \begin{frame}
    \maketitle
  \end{frame}

  \begin{frame}{Einordnung in die Vorlesung: Objekte}
    \begin{center}
      \includegraphics[page=13,width=0.6\linewidth]{fig/01-overview-small}
    \end{center}
    \bi
    \ii Objekte sind die datentragenden Elemente in einer Laufzeitumgebung {
      \bi
      \ii Die virtuelle Sprach-Maschine definiert \alert{Geburt, Leben und Tod} von Objekten.
      \ii Effiziente Programme gehen \advantage{sparsam und sorgsam} mit Objekten um.
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{Was ist ein Objekt?}
    \begin{center}
      \includegraphics[width=0.75\textwidth]{fig/06-object-types}
    \end{center}
    \bi
    \ii \textbf{Erinnerung 1. Vorlesung}: Maschinenmodell der virtuellen Maschine:{
      \bi
      \ii \structure{Speicher/Objekte}: Wie kann man Informationen ablegen und wieder abrufen?
      \ii \structure{Befehle/Operationen}: Wie kann man Informationen miteinander kombinieren?
      \ei
    }
    \ei
    \pause
    \begin{btBlock}{Definition: Objekt}
      Ein Objekt ist ein existentiell-abhängiger Verbund von Informationen.
    \end{btBlock}
    \pause
    \hspace{-1em}\textbf{Wichtig:} \btSetTab (1) Variablen $\subset$ Objekte! Variablen können Objekte beinhalten.\\
    \btUseTab (2) Diese Definition umfasst auch primitive Objekte, wie Zahlen!
  \end{frame}
#+end_src

Nachdem wir uns im Kapitel zur semantischen Analyse stark mit Techniken beschäftigt haben, welche in einem Übersetzer zum Einsatz kommen, wollen wir uns in diesem Kapitel wieder den *Konzepten von Programmiersprachen* widmen.
Genauer gesagt, wollen wir betrachten, was eigentlich ein *Objekt* ausmacht und welchen Wandel ein einzelnes Objekt im Verlauf eines Programms durchmacht.
Dabei werde ich ein viel breiteres und gleichzeitig viel engeres Verständnis von "Objekt" annehmen, als man dies in den sogenannten Objekt-Orientierten Programmiersprachen verwendet.
Breiter deshalb, weil ich jedes Datum und jede Ansammlung von Daten als Objekt betrachte, und enger, weil ich dabei nur auf die passiven Informationen und nicht auf die damit verbundenen (aktiven) Operationen eingehe.
Diese werde ich erst im nächsten Kapitel genauer diskutieren.

Es lohnt sich jedoch Objekt einmal in Isolation, losgelößt von ihren Operationen, zu betrachten.
Objekte sind jene Entitäten mit deren Hilfe wir Informationen im Programmverlauf hin und her werfen.
Daher ist es für den /effektiven Programmierer/ essentiell zu verstehen wie Objekte entstehen, wie wir sie verwenden und wie sie zerstört werden.
Um diesen Wandel einzelner Objekte zu verdeutlichen, werde ich für diese Vorlesung die Metapher vom Lebenszyklus eines Objekts verwenden, welche sich in vielen etablierten programmiersprachlichen Begriffen, wie der Lebenszeit eines Objekts, wiederfindet.
Der /effiziente Programmierer/ lernt in dieser Vorlesung, welche Kosten bei unterschiedlichen Typen von Objekten und Zugriffen entstehen und was es bedeutet wenn eine Sprache automatisches Speichermanagement (Garbage Collection) durchführt.

Zunächst müssen wir aber definieren, was wir, für diese Vorlesung, unter einem "Objekt" überhaupt verstehen.
Dazu möchte ich noch einmal das Maschinenmodell aus der ersten Vorlesung in Erinnerung rufen:
Die virtuelle Maschine der Sprache definiert wie wir Informationen ablegen (Objekte im Speicher) und wie wir diese Daten verarbeiten können (Operationen).
Schauen wir mit dieser Brille auf einen real-existierenden Prozessor, so kennt dessen Maschinenmodell nur Zahlen als Objekte, welche in Registern bzw. dem Hauptspeicher abgelegt werden können.
Weiterhin ist jede Zahl ein Verbund von 8, 16, 32 oder 64 einzelnen Bits, welche die grundlegendste informations-tragende Entität ist.

Verallgemeinern wir dies, so könnten wir sagen, dass ein Objekt ein Verbund von Informationen ist, der existentiell voneinander abhängig ist und logisch zusammengehört.
Logisch-zusammengehörig deswegen, weil die Definition unabhängig davon ist, an welchen Orten die Informationen gespeichert sind.
So sind die einzelnen Bits eines Maschinenworts in unterschiedlichen Flip-Flops bzw.
DRAM-Zellen[fn::Im Fall von DRAM können die einzelnen Bits einer Speicherzelle sogar auf mehrere Chips verteilt sein.]
verteilt.
Dies hält uns aber nicht davon ab, die logisch-zusammengehörigen Bits als eine Zahl zu sehen. Löschen wir die Zahl, zum Beispiel durch überschreiben der Speicherzelle, so gehen auch die Wahrheitswerte der einzelnen Bits verloren. Die Bits sind also in ihrer Existenz abhängig von der Zahl.

Betten wir ein Objekt ein, so entsteht ein neues, größeres Objekt und die Einbettung wird existentiell abhängig:
Das Array von Zahlen ist ein Verbund einzelner Zahlen, löschen wir das Array von Zahlen, so löschen wir auch die enthaltenen Zahlen.
Dabei ist egal, dass die Zahlen weiterhin im Speicher an der Stelle stehen, wo früher das Objekt stand. Für die Programmiersprache sind die Zahl-Objekte verloren.

Auf Ebene der Programmiersprache haben wir eine deutlich größere Auswahl an verschiedenartigen und strukturierten Objekten als einfach nur Zahlen.
Einen Einblick in solch strukturierte Daten haben wir bereits in der Typen-Vorlesung kennen gelernt[fn::Damals haben wir Typen, unter anderem, *denotationell* definiert: Typen sind die Menge von Objekten die sie beschreiben.
Die Objekte dieser Typen sind es, mit denen wir uns nun beschäftigen werden.]:
Zahlen, Arrays, Records, Referenzen, etc.
Diese Objekte können alleine stehen (die Zahl) oder als Einbettung eines größeren Objekts auftreten (Array von Zahlen).
Auf den Folien ist jeder umrandete Kasten ein einzelnes Objekt.

Anders ist es, wenn wir eine Referenz auf ein anderes Objekt einbetten.
In diesem Fall haben wir zwei unterschiedliche Objekte, da das referenzierte Objekt *unabhängig* von referenzierenden Objekt existieren könnte.
Das Löschen des einen Objekts führt nicht zwingend zur Löschung des anderen Objekts.

#+begin_src latex
  \begin{frame}<handout:4>{Lebenszyklus eines Objekts}
    \hspace{-1em}\textbf{Vereinfachung:} Objekte residieren in zusammenhängendem Speicher
    \medskip
  
    \btAnimation[width=\textwidth]{range=1-4:<1->}{fig/06-lifecycle}

    \bi
    \ii \structure{Geburt}: Initialisierung von frisch allokiertem Speicher\\
    \small Objekt-Zustand muss so präpariert werden, dass die Typ-Invarianten gelten.
    \smallskip
    \ii<2-> \structure{Leben}: Objekte transportieren Informationen im Programmablauf\\
    \small Sprache kann es uns erleichtern die Typ-Invarianten zu erhalten, sonst: Bugs.
    \smallskip
    \ii<3-> \structure{Tod}: Kontrolliertes Aufräumen des Zustands und Freigabe der Ressourcen\\
    \small Der Zeitpunkt und der Verantwortliche für das Aufräumen ist sprachabhängig.
    \ei
  \end{frame}
#+end_src

Deutlich spannender als die Frage, welche Art von Objekten es gibt, ist der *Lebenszyklus* von Objekten, denn viele Sprachkonstrukte drehen sich um das Management dieses Lebenszyklus:
Durch Allokation und Initialisierung wird ein Objekt geboren.
Während des Lebens, hat es einen, oder mehrere, Besitzer, die es ausgelesen, verändern und an Dritte weitergegeben.
Und mit der Deinitialisierung und der Freigabe des Speichers, verlässt es uns wieder.

Während der gesamten Lebenszeit ist ein Objekt nur deswegen Objekt, weil es die Regeln seines Typen, die *Typ-Invarianten*, einhält.
Diese Invarianten werden bei der Objekt-Geburt, durch die passende Belegung des Speichers, etabliert und müssen während der gesamten Lebenszeit aufrecht erhalten werden.
Verletzen wir diese Invarianten, zum Beispiel indem wir das 0-Byte am Ende eines C-Strings überschreiben, so verletzen wir das Typsystem und es kommt zu einem Bug.
Erst beim Tod des Objekts dürfen die Typinvarianten wieder verletzt werden.
Die Dauer dieses Lebenszyklus ist die *Lebenszeit* eines Objekts.

Mit diesen drei Phasen des Lebenszyklus (Geburt, Leben und Tod) werden wir uns in dieser Vorlesung beschäftigen.

#+begin_src latex
  \begin{frame}[fragile]{Beispiel: Leben eines Loggers}
    \begin{columns}
      \begin{column}{0.49\textwidth}
        \begin{code}[tag=C]
          \begin{C}[style=smaller]
            typedef enum {
              DEBUG, INFO, WARN, ERROR, 
            } level_t;
          
            typedef struct {
              level_t level;
              int fd;
            } log_t;

            int main() {
              // Geburt
              log_t *L = log_init();

              // Leben
              log(L, INFO, "message");
              L->level = DEBUG;
              log(L, INFO, "message");

              // Tod
              log_deinit(L);
            }
          \end{C}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \begin{code}[]
          \begin{C}[style=smaller]
            log_t * log_init() {
              // Allokation: Speicher am Heap
              log_t *l = malloc(sizeof(log_t));
              // Initialisierung des Zustands
              l->level = WARN;
              l->fd    = open("/dev/stderr", 0);
              return l;
            }
          \end{C}
        \end{code}

        \begin{code}[]
          \begin{C}[style=smaller]
            void
            log(log_t *l, level_t ll, char *m) {
              if (ll >= l->level) {
                write(l->fd, m, strlen(m));
              }
            }
          \end{C}
        \end{code}

        \begin{code}[]
          \begin{C}[style=smaller]
            void log_deinit(log_t *l) {
              close(l->fd); // Datei schließen
              free(l);      // Speicher freigeben
            }
          \end{C}
        \end{code}
      \end{column}
    \end{columns}

    \bi
    \ii<2-> Kaum Sprachunterstützung: \codeinline{struct log_t} kann man leicht falsch halten!{
      \bi
      \ii Benutzer kann Invarianten verletzen:\btSetTab\codeinline{L->fd = 23;}
      \ii Use-after-free Bugs: \btUseTab\codeinline{log_deinit(L); log(L, ERROR, "panic");}
      \ii Vergessen das Objekt frei zu geben $\rightarrow$ Memory Leak
      \ei
    }
    \ei
    
  \end{frame}
#+end_src

Um den Lebenszyklus eines Objekts zu verdeutlichen schauen wir uns einen Logger in C an.
Hier werden die drei Phasen besonders deutlich, da nichts vom Lebenszyklus durch Sprachkonstrukte vor unserem Auge versteckt bzw.
abstrahiert wird.

Die ~log_t~-Objekte sind durch eine C-struct Deklaration beschrieben, und sie bestehen aus einem Log-Level (~level_t~) und einem Unix-Dateideskriptor. Beide Unterobjekte sind als Einbettung in der Struktur existentiell abhängig von den ~log_t~-Objekten[fn::Allerdings ist der Dateideskriptor, ohne dass wir das auf Sprachebene sehen, eine Referenz auf ein Objekt im Betriebssystem. Aber das ist Thema von Grundlagen der Betriebssysteme.].

Die Geburt eines ~log_t~-Objekts findet in der ~log_init()~-Funktion statt.
Dort wird der nötige Speicher alloziert und die beiden Felder so initialisiert, dass sie die Invarianten des Objekts erfüllen.
Leider sind diese Invarianten an dieser Stelle nicht gut sichtbar, weswegen ich sie ihnen verrate:
(1) ~level~ is ein valides Loglevel.
(2) ~fd~ is ein offener Dateideskriptor.
Die anderen Funktionen (~log()~, ~log_deinit()~) verlassen sich auf diese Invarianten um nicht jedesmal prüfen zu müssen ob das übergebene Argument wirklich ein valides ~log_t~-Objekt ist.

Die ~log_init()~-Funktion gibt eine Referenz auf das Objekt zurück, womit die ~main()~-Funktion der Besitzer des Objekts wird.
Als Besitzer kann ~main()~ das Objekt verändern, indem es zum Beispiel das Loglevel neu setzt oder das Objekt per Parameterübergabe weitergibt.

Das Ende unseres Objekts findet in ~log_deinit()~ statt:
Dort wird der, bei der Konstruktion, angeforderte Dateideskriptor geschlossen und der angeforderte Speicher zurück gegeben.
Nach diesem Zeitpunkt existiert das Objekt nicht mehr.

Auch sichtbar an diesem Beispiel wird, dass uns C nicht sehr dabei hilft sorgsam mit Objekten umzugehen:
So erlaubt es uns C nicht die Typ-Invarianten zu beschreiben und kann uns daher nicht daran hindern diese zu verletzen.
Auch wäre es möglich den Speicher an dem einst das Objekt gelebt hat, weiter zu verwenden und einen use-after-free Bug zu provozieren, da die Referenz in ~L~ nicht invalidiert wird.
Außerdem wäre es ein leichtes gewesen die Freigabe des Objekts zu vergessen, womit ein Speicherleck (Memory Leak) entstanden wäre.
In anderen Sprachen, Konstrukte und Regeln die es uns schwer oder vollständig unmöglich machen solche Probleme und Bugs zu provozieren.
Alle hängen damit zusammen, wie uns die Sprache erlaubt Objekte zu erzeugen und mit ihnen um zu gehen.


* Geburt von Objekten
:PROPERTIES:
:CUSTOM_ID: 06-birth
:END:
** Speicher-Allokation
:PROPERTIES:
:CUSTOM_ID: 06-allocation
:END:
#+begin_src latex
  \dividerframe{Geburt von Objekten}

  \begin{frame}[fragile]{Allokation: Wo kommt der Speicherplatz her?}
    \hspace{-1em}\textbf{Meistens} residieren Objekte in einem zusammenhängenden Speicherbereich
    \medskip
    \begin{center}
      \texttt{allocate(bytes\_t N)} $\longrightarrow$ Startadresse des zukünfigen Objekts
    \end{center}

    \bi
    \ii<2-> \structure{Statische Allokation} durch Übersetzer: Lebenszeit = Programlaufzeit {
      \bi
      \ii Absolute Adresse des Objekts steht vor der Laufzeit fest
      \ii Bsp.: globale Variablen, konstante Literale, Maschinencode einer Funktion
      \ii 2 statische Objekte: \codeinline{char *global = "foobar";}
      \ei
    }\medskip
    \ii<3-> \structure{Stack Allokation}: Objekte können auf den Aufrufstapel{
      \bi
      \ii Allokation als Einbettung des Call-Frames einer Funktionsinstanz.
      \ii Lebenszeit des Objekts ist $\le$ Lebenszeit des Call-Frames.
      \ii Beispiele: Argumente, lokale Variablen, \codeinline{alloca()}
      \ei
    }\medskip
    \ii<4-> \structure{Heap Allokation}: Laufzeitsystem betreibt separaten Speicherpool {
      \bi
      \ii Lebenszeit unabhängig von Aufrufhierarchie, beliebige Allokations-Zeitpunkte
      \ii Benötigt komplexeres Speichermanagement und ist daher teurer.
      \ii Speicher muss irgendwann freigeben werden (manuell oder garbage collection)
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{Allokationen im größeren Kontext}
    \begin{center}
      \includegraphics[width=0.8\textwidth]{fig/06-process-mem}
    \end{center}

    \bi
    \ii Im klassisches UNIX-Modell wachsen Stack und Heap aufeinander zu.{
      \bi
      \ii Das ELF beschreibt die statisch allokierten Objekte (.text, .data, .bss)
      \ii Realität ist komplexer: Mehrere Stacks/Heaps, Addressspace-Randomization
      \smallskip
      \ii[$\rightarrow$] Genauere Betrachtung in Grundlagen der Betriebssysteme (GBS)
      \ei
    }\medskip
    \ii Für Programmiersprachen und Übersetzer nehmen wir an, dass... {
      \bi
      \ii Wir globale Objekte im Assembler anlegen können.
      \ii Der Prozess einen Stack hat und wir den Stackpointer kontrollieren.
      \ii Das Laufzeitsystem \codebox{void *malloc(size\_t)}/\codebox{free(void*)} bereitstellt.
      \ei
    }
    \ei
  \end{frame}
#+end_src

Der erste Schritt bei der Geburt eines Objekts ist die *Allokation von Speicher*.
Das Ziel der Allokation ist es eine Menge von Speicherzellen für dieses Objekt zu reservieren. Diese Speicherzellen sind dann ausschließlich für dieses Objekt reserviert.
Dabei können wir meinst davon ausgehen, dass der Speicherbereich für das Objekt zusammenhängend ist; die Speicherzellen, ab einer Startadresse, fortlaufend für das Objekt reserviert werden[fn::Wie alles in der Informatik, ist auch dies kein Naturgesetz, sondern eine Entscheidung des Menschen. Wenn man sehr viele gleichartige Objekte hat, kann man die Objekte an den Attributen aufteilen und spaltenweise speichern. Dazu gibt es einen sehr guten Talk von Mike Acton auf der CppCon2014: [[https://www.youtube.com/watch?v=rX0ItVEVjHc][Data-Oriented Design and C++]]].
Um genügend Speicher zu reservieren, brauchen wir die Größe des Objekts, eine Information, die uns normalerweise das Typssystem liefert und rufen eine Allokator-Funktion auf.

Die Ihnen wahrscheinlich bekannteste Allokationsfunktion ist wahrscheinlich ~malloc()~.
Allerdings gibt es noch weitere Arten Speicher für Objekte zu reservieren, die nicht zwingend mit dem Aufruf einer Funktion verbunden sind.

Bei der *statischen Allokation* übernimmt der Übersetzer, zusammen mit dem Linker und Loader, die Allokation des Speicherbereichs.
Dabei wird, von vornherein, eine Ort für das Objekt in der Binärdatei vorgemerkt, sodass die Adresse des Objekts bereits vor der Laufzeit fest steht.
Die Lebenszeit dieser statisch allokierten Objekte ist normalerweise gleich mit der Laufzeit des Programms; sie werden beim Start des Programs[fn::Oft vor der ~main()~-Funktion.] initialisiert und erst vor dem Beenden des Prozesses werden sie wieder zerstört.
Das klassische Beispiel für statische Allokation ist die Definition einer *globale Variable*. Aber auch konstante Literale, wie ~"foobar"~ oder die übersetzten Funktionen[fn::In der Binärdatei wird jede Funktion zu eine Sequenz von Maschineninstruktionen. Auch diese benötigen Platz und haben eine Startadresse.] werdem vom Übersetzer statisch alloziert.
Die statische Allokation ist die inflexibelste Art Speicher zu reservieren, da die maximale Anzahl der Objekte bereits vor der Laufzeit fest stehen muss.
Allerdings ist sie auch die effizienteste, da keinerlei Kosten zur Laufzeit entstehen.

Bei der *Stackallokation*, wird der Laufzeit- bzw. Aufrufstapel verwendet um Speicher für Objekte zu allokieren.
Diesen Mechanismus haben wir bereits im Kapitel über Namensauflösung{{{see(04-call-frames, Function-Call Frames)}}} kennen gelernt, als wir uns mit Funktions-lokalen Variablen beschäftigt haben.
Objekte, die mittels Stackallokation alloziert werden, sind Einbettung des Function-Call Frames und leben daher maximal so lange wie dieser existiert.
Normalerweise endet die Lebenszeit der stack-allozierten Objekte also mit der Rückkehr aus der Funktion[fn::Rufen Sie sich in Erinnerung, wann dies nicht der Fall ist.].
Verglichen mit der statischen Allokation, ist die Stackallokation deutlich flexibler, da wir nun dynamisch Objekte allozieren können.
Allerdings ist die Lebenszeit dieser Objekte strikt and die Aufrufhierarchie gebunden und wir können nicht einfach die Adresse eines stack-allozierten Objekts zurückgeben.
Da die Allokation nur aus der Subtraktion der Objektgröße auf den Stackzeiger besteht, hat bringt die Stackallokation nur wenig Laufzeitkosten.

Mit der *Heap Allokation* (~malloc()~) überwinden wir die Einschränkung der statischen und der Stackallokation, handeln uns aber höhere Verwaltungskosten ein.
Durch der Aufruf von ~malloc()~ reservieren wir einen Speicherbereich, der völlig unabhängig von der Programmstruktur ist; die darin abgelegeten Objekte können eine beliebige Lebenszeit haben.
Die so allozierten Speicherbereiche müssen allerdings, da ihne Lebenszeit nicht am Programmablauf hängt, explizit freigegeben werden (~free()~).
Dies kann entweder manuell geschehen oder automatisch durch einen Garbage Collector (dt.
Speicherbereinigung).
Später in dieser Vorlesung werden wir uns noch Strategien zur (semi-)automatischen Speicherbereinigung anschauen.

In allen Fällen, ist das Ergebnis der Speicherallokation die Startadresse des resevierten Speicherbereichs.
Ab dieser Adresse aufsteigend (zu den hohen Adressen) wird unser Neugeborenes Objekt leben.

** Initialisierung
:PROPERTIES:
:CUSTOM_ID: 06-init
:END:
#+begin_src latex
  \begin{frame}{Initialisierung und Konstruktoren}
    \begin{btBlock}{}
      Wie wird aus dem allozierten, noch blanken, Speicherbereich ein Objekt?    
    \end{btBlock}

    \bi
    \ii \structure{Sprachabhängige} Initialisierung etabliert Meta-Informationen\\[1ex]
        \small\emph{Was macht ein Stück Speicher für meine Sprache zu einem Objekt?}\\[1ex]
        {
          \bi
          \ii Einige Sprachfeatures  erfordern zusätzliche Informationen an jedem Objekt.
          \ii Zum Beispiel  \btSetTab -- Dynamische Typinformationen in Form eines \structure{Typ-Tags}.\\
                            \btUseTab -- Registrierung des Objekts am Garbage Collector (später mehr)
          \ei
        }\medskip
    \ii<2-> \structure{Benutzerdefinierte} Initialisierung durch \textbf{Konstruktoren}\\[1ex]{
      \small\emph{Was möchte der Benutzer bei der Geburt eines Objekts tun?}\\[1ex]
      \bi
      \ii Initiale Belegungen der Objekt-Attribute
      \ii Parametrisierte Konstruktion
      \ii Intention des Benutzers: Etablierung der \textbf{semantischen Invarianten}
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[fragile]{Sprachregeln für Konstruktoren }
    \begin{columns}
      \begin{column}{0.49\textwidth}
        \begin{code}[tag=C++]
          \begin{CPP}
            class Object {
              public: 
                Object(int x)    { ... }
                Object(string x) { ... }
            };
          \end{CPP}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \begin{code}[tag=Java]
          \begin{java}
            class Object {
              public Object(int x)    { ... }
              public Object(String x) { ... }
            };
          
          \end{java}
        \end{code}
      \end{column}
    \end{columns}

    \bi
    \ii \structure{Definition} von eigenen Konstruktoren {
      \bi
      \ii Definieren wir keine eigenen, werden Default-Konstruktoren erzeugt
      \ii Konstruktoren haben Parameter und können Überladen werden
      \ii Sehen aus wie Funktionen, haben aber keinen Rückgabewert
      \ei
    }\medskip
  
    \ii \structure{Aufruf} von Konstruktoren {
      \bi
      \ii Konstruktoren werden bei Objekterstellung \alert{automatisch} aufgerufen.
      \ii Bei Vererbung: Eltern-Konstruktoren vor Kind-Konstruktoren\\
          $\Rightarrow$ Kind-Konstruktoren finden ein valides Eltern-Objekt vor.
      \ei
    }
    \ei
  \end{frame}

  


#+end_src

Nun, da wir genügend Speicher haben, der allerdings noch und oft von undefiniertem Inhalt ist[fn::Den Speicher immer zu nullen, würde unnötige Kosten erzeugen.]
können wir damit anfangen unser Objekt zu *initialisieren*.
Das Ziel der Initialisierung ist es, den Speicher mit Werten zu füllen, damit er wie ein Objekt vom passenden Typen aussieht.
Diese Bedingung, was ein Objekt ausmacht, zerfällt in zwei separate Teilaspekte:
den Sprachspezifischen und den Nutzerspezifischen.

Der *sprachabhängige Teil der Initialisierung* ist vom Sprachprozessor (Übersetzer bzw.
Interpreter) und der Laufzeitumgebung abhängig.
So müssen wir alle Informationen, die wir zur Laufzeit benötigen um die Features der Sprachezu implementieren, mit in das Objekt schreiben.
Unterstützt unsere Sprache, zum Beispiel, dynamische Typen, so müssen wir die Typinformationen, in Form eines Typ-Tags der eines ~vtable~-Zeigers, in den Speicherbereich des Objekts schreiben.
Andernfalls hätten wir später keine Möglichkeit mehr den dynamischen Typen des Objekts heraus zu finden.

Eine andere Sorte der sprachabhängigen Initialisierung ist die Registrierung des Objekts beim Garbage Collector (GC). Wie wir später sehen werden, benötigt der GC eine globale Sicht auf alle existierenden Objekte. Eine Möglichkeit dies zu schaffen ist es, jedes Objekt, bei seiner Erstellung, in eine verkettete Liste einzufügen. 

Zum Vergleich: Bei der Sprache C gibt es keine sprachabhängige Initialisierung von Objekten.
Jedes Stück Speicher sieht für ein C Programm erstmal wie ein valides Objekt aus.
Sie können sich denken, welche Probleme, aber auch welche Effizienz, wir durch diese Entscheidung bekommen.

Bei der *benutzerdefinierten Initialisierung*, darf der Benutzer Code ausführen, der die Felder des Objekts nach seinem Geschmack richtig belegt.
Diesen Code nennen wir *Konstruktor* und es ist die Aufgabe des Konstruktors die semantischen Invarianten des Typs zu etablieren.
Außerdem können Konstruktoren noch weitere Resourcen (wie Dateideskriptoren oder andere Objekte) anfordern.
Nach der Ausführung des Konstruktors ist das Objekt nicht nur aus Sicht der Laufzeitumgebung, sondern auch aus Sicht des Programmierers ein vollständiges, ordentliches, einsatzfähiges Objekt; es ist ausgewachsen!

Wie wir bereits am Beispiel des C-Loggers gesehen haben, hat nicht jede Sprache eingebaute Unterstützung für Konstruktoren.
In solchen Fällen, verwenden wir normale Funktionen um das Konstrukt "Konstruktor" ab zu bilden.
Jedoch bleibt die Idee die Gleiche:
Ein Konstruktor bekommt einen Speicherbereich übergeben, in den es ein Objekt vom entsprechnenden Typen hinein-initialisiert.

In Sprachen, die Konstruktoren als Konzept bieten, werden diese meist mit dem Typen zusammen definiert. 
Um die Initialisierung von Objekten flexibel zu gestalten, sind Konstruktoren normalerweise parametrisierbar und teilen sich ansonsten die meiste Syntax mit Funktionen.
Definieren wir keine eigenen Konstruktoren, so erstellt der Übersetzer einen Default-Konstruktor für uns.

Wie Funktionen, lassen sich Konstruktoren in C++ und Java überladen, besitzen aber keinen Rückgabewert, da das Ergebnis des Konstruktors klar ist: ein fertig initialisiertes Objekt. 
Wie bei allen Methoden, wird das zu bearbeitende Objekt als nullter Parameter (~this~-Zeiger) übergeben.
Außerdem haben Konstruktoren auch eine Sichtbarkeit. 

Gehen Sie einen Moment zurück... was soll das heißen, Konstruktoren haben eine Sichtbarkeit?! Wie sollten wir denn jemals einen Konstruktor aufrufen der ~private~ ist, wenn dies nur durch Methoden geschehen kann die innerhalb der Klasse definiert sind. Und wozu wäre dies Überhaupt gut? Die Antwort darauf sind ~statische Methoden~, die auch ohne ein existierendes Objekt aufgerufen werden können. Ein Beispiel, wo ein privater Konstruktor Sinn ist folgendes Stück Code:

#+begin_src C++
class Object() {
private:
  Object() {}

public:
  static Object * Create() { 
    return new Object();
 }
};
#+end_src

Die einzige Art diesen Typen zu instantiieren ist es die ~Create()~-Methode aufzurufen, welche immer eine Heapallokation mittels ~new~ durchführt.
Es kann niemals geschehen, dass ein Benutzer ein solches Objekt aus Versehen auf dem Stack anlegt.
Grund für eine solche Beschränkung kann sein, dass das Objekt sehr groß ist und daher leicht einen Stacküberlauf provozieren könnte. Weitere Gründe für einen privaten Konstruktor finden sich in [[https://stackoverflow.com/questions/2062560/what-is-the-use-of-making-constructor-private-in-a-class][dieser Diskussion auf Stackoverflow]].

Generell werden Konstruktoren automatisch vom Sprachprozessor bzw.
der Laufzeitumgebung aufgerufen.
Dadurch kann es niemals sein, dass es ein Objekt vom passenden Typen gibt, für das kein Konstruktor gelaufen ist.

Bei Sprachen mit Vererbung muss der Sprachprozessor allerdings eine gewisse Sorgfalt walten lassen, in welcher Reihenfolge die Konstruktoren von Eltern- bzw.
Kindsklasse aufgerufen werden.
Generell gilt:
Die Konstruktoren der Elternklasse werden von den Konstruktoren der Kindsklasse aufgerufen.
Auf diese Weise findet ein Konstruktor der Kindsklasse bereits ein vollständig konstruiertes und valides Eltern-Objekt als ~this~-Zeiger vor.

#+begin_src latex
\begin{frame}<handout:1,3>[fragile]{Konstruktoren in Aktion: Java}
    \begin{columns}
      \begin{column}{0.4\textwidth}
        \begin{code}[]
          \tikzset{every dn/.style={visible on=<2->}}
          \lstinputlisting[style=java,style=smaller]{lst/06-counter.java}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.59\textwidth}
        \bii
        \ii Java {\bi
          \ii Konstruktoren heißen wie die Klasse.
          \ii Nicht-initialisierte Attribute werden automatisch 0 oder \texttt{null}
          \ei
        }
        \medskip
        \ii<2-> Ablauf für \codeinline[style=java,style=smaller]{new Derived("123")}{
          \bi
          \ii[{\dn[font=\tiny]{1}}]\footnotesize Aufruf anderer Konstruktoren mittels \codeinline[style=java,style=smaller]{this()}
          \ii[{\dn[font=\tiny]{2}}]\footnotesize Elternkonstruktor mittels \codeinline[style=java,style=smaller]{super()}
          \ii[{\dn[font=\tiny]{3}}]\footnotesize Konstruktor setzt \codeinline[style=java,style=smaller]{final}-Attribut
          \ii[{\dn[font=\tiny]{4}}]\footnotesize Autom. Nullung durch \codeinline[style=smaller]{Object}-Konstruktor

          \ei
        }
        \medskip
        \ii<3-|handout:3-> { Wie sähe eine manuelle Konstruktion aus?
          \begin{minipage}{0.9\linewidth}
            \begin{code}[tag=Pseudo-C]
              \begin{C}[style=smaller]
                // Allokation
                Derived *this = malloc(sizeof(Derived));

                // Sprachspezifisches Init
                memset(this, 0, sizeof(Derived));
                this->vtable = Dervied_vtable;

                // Konstruktor (inlined)
                int tmp = parseInt("123")
                this->start = 3+tmp;
              \end{C}
            \end{code}
          \end{minipage}
        }
        \eii
    \end{column}
    \end{columns}
  \end{frame}
#+end_src

Wir werfen nun einen genaueren Blick auf Konstruktoren bei Java.
Zum Ersten fällt auf, dass in Java Konstruktoren so wie ihre Klasse heißen müssen und überladen sein können.
Im Fall von ~new Derived("123")~ startet die benutzerdefinierte Initialisierung beim Konstruktor ~Derived(String)~.
Hier parsen wir den String zur Ganzzahl 123 und rufen den anderen Konstruktor (~Derived(int)~) in gleichen Klasse mittels ~this()~ auf.
Die Delegation zwischen Konstruktoren erlaubt es uns weniger Code zu duplizieren.

Im ~Derived(int)~ Konstruktor rufen wir explizit einen gewissen Konstruktor (~Counter(int)~) der Elternklasse mittels ~super()~ auf.
Hätten wir keinen expliziten ~super()~-Aufruf platziert, so hätte Java automatisch den "no-arg"-Konstruktor ~Counter()~ aufgerufen.

Schließlich angekommen in ~Counter(int)~, initialisieren wir das Feld ~start~. Da diese Feld ~final~ ist, zwingt uns Java dieses Feld in einem Konstruktor zu initialisieren; sein Wert kann später nicht mehr geändert werden.
Der Sprachstandard von Java sieht weiterhin vor, dass das Feld ~next~  automatisch auf ~0~ initialisiert wird. Auf diese Weise verhindert Java, dass es uninitialisierte Felder gibt.

Auf den Folien habe ich außerdem noch ein Stück Pseudo-C Code aufgeschrieben, welches eine ähnliche Initialisierung durchführen würde, wie die Java Laufzeitumgebung.
Besonders interessant ist hier das ~memset(..., 0, ...)~ welches die automatische Nullung durchführt und das setzen des ~vtable~-Zeigers, welches für virtuelle Methodenaufrufe nötig ist.

#+begin_src latex
  \begin{frame}[fragile]{Was sollte \textbf{mein} Konstruktor leisten?}
    \begin{btBlock}{\small Sinnvolle Konvention: Konstruktoren stellen semantische Invarianten her}\small
      -- Entwickler trifft \textbf{immerwährende Annahmen} über den Zustand eines Objekts. \\
      -- \textbf{Jeder} Konstruktor hinterlässt ein Objekt, dass die Annahmen einhält.\\
      -- Jede weitere Operation auf dem Objekt muss diese Annahmen \textbf{erhalten}.
    \end{btBlock}

    \bi
    \ii<2-> Beispiel: Bounded Pointer zeigt nur auf die Elemente eines Arrays\\[0.5ex] {
      \begin{columns}
        \begin{column}{0.44\textwidth}
          \begin{code}[]
            \begin{CPP}[style=smaller]
              class bounded_ptr {
                int *data;
                unsigned length;
                int *ptr;
              
                bounded_ptr(unsigned len) {
                  data   = malloc(len);
                  length = len;
                  ptr    = &data[0];
                }

                void set(int val) {
                  ,*ptr = val;
                }
                ...
              };
            \end{CPP}
          \end{code}
        \end{column}\hfill
        \begin{column}{0.55\textwidth}
          \bi
          \ii Invarianten für bounded\_ptr {
            \btUseExtraItemSep
            \bi
            \ii \texttt{data} zeigt auf ein valides Integer-Array\\[1ex]
            \ii \texttt{length} gibt Länge dieses Arrays an\\[1ex]
            \ii \texttt{ptr} ist die Adresse eines Array-Elements
            \ei
          }
          \ii<3-> \textbf{\advantage{Bonussternchen}}, falls der Benutzer nicht in der Lage ist die Invarianten zu verletzen.
          \ei
        \end{column}
      \end{columns}


    }
    \ei
  \end{frame}
#+end_src

Ich habe bereits angeschnitten, dass eine Aufgabe von Konstruktoren ist die semantischen Invarianten des Types zu etablieren.
Da dies ein wichtiger Punkt ist, komme ich noch einmal darauf zurück.
Klar ist, dass dieser Punkt nicht mit den Sprachregeln zu tun hat, sondern eher eine sinnvolle Konvention darstellt.
Niemand hält Sie davon ab, im Konstruktor eines Objekts dumme Dinge zu tun.
Sie sollten allerdings zu Ihrem und zum Wohle der Welt davon absehen.

Invarianten sind Annahmen, die über die gesamte Lebenszeit eines Objektes, vom Konstruktor bis zum Tod des Objekts gelten.
Alle Operationen/Methodenaufrufe, die auf diesem Objekt arbeiten, können sich auf diese Invarianten verlassen.
Wenn sie allerdings verändern, müssen sie dafür Sorgen, dass die Invarianten nach Beendigung der Operation wieder gelten.
Während die Operation ausgeführt wird, dürfen die Invarianten kurzzeitig verletzt werden[fn::Denken Sie an dieser Stelle darüber nach, wie Nebenläufigkeit und semantische Invarianten zusammenspielen und alles kompliziert machen. Überlegen Sie sich auch wie ~synchronized~ das Problem auf Java-Sprachebene löst.].

Das Beispiel auf den Folien zeigt eine Art Array, für welches der Konstruktor genügend Speicher alloziert, die Länge des Arrays abspeichert und ~ptr~ auf das erste Array-Element zeigen lässt. 
Diese drei Operationen im Konstruktor etablieren die aufgelisteten Invarianten, auf diese sich dann auch die Funktion  ~void set(int)~ verlässt, wenn sie Blind den Zeigern ~ptr~ dereferenziert und den übergebenen Parameter in das entsprechende Array-Element speichert.

Wenn Sie selbst eine Klasse definieren, überlegen Sie sich, welche Invarianten gelten sollten. *All* ihre Konstruktoren sollten das Objekt so hinterlassen, dass diese Invarianten erfüllt sind. 
Jede Methode darf sich dann auf diese Invarianten verlassen, muss aber das Objekt so valide zurück lassen, wie es vorgefunden wurde.

Besonders gut ist ihre *Datenabstraktion*, wenn es dem externen Benutzer unmöglich ist, das Objekt in einen Zustand zu bringen in dem seine Invarianten verletzt sind.
Besonders öffentlich-schreibbare  Felder, bei denen nicht jede Belegung die Invarianten erfüllt, sind ein häufiges Problem, was diesem Ziel entgegen steht.

* Leben von Objekten
:PROPERTIES:
:CUSTOM_ID: 06-life
:END:
Nachdem wir wissen wie Objekte ins Leben kommen, stellt sich die Frage, was wir zu ihren Lebzeiten damit machen können.
Wir müssen diese Objekte im Programmtext, genauer gesagt mittels Variablen, ablegen, wiederfinden und weitergeben können. 
Außerdem wollen wir die Informationen des Objekts auslesen und gegebenfalls verändern können.
Dabei sollten wir stets im Hinterkopf behalten, dass eine Sprache es dem Entwickler leicht machen sollte die Objekt-Invarianten aufrecht zu erhalten.

** Werte- und Referenzmodell
:PROPERTIES:
:CUSTOM_ID: 06-value-reference-model
:END:
#+begin_src latex
  \dividerframe{Leben von Objekten}
  \begin{frame}[t]{Wie werden Objekte abgelegt und weitergereicht?}
    \textbf{Erinnerung (binding time):} Ein Objekt wird an einen Namen gebunden.

    \begin{center}
      \codebox{var\_foo = new object();}\hspace{1cm}\codebox{foo(var\_foo);}
    \end{center}

    \hspace{-1em}Mittels gebundener Namen können wir Objekte \alert{ansprechen und weitergeben}.\\[0.5ex]
    \uncover<2-|handout:2->{
      \hspace{-1em}\textbf{Aber:} Ist der Wert einer Variable das Objekt oder eine Objekt-Referenz?
    }

    \begin{columns}<3-|handout:2->
      \begin{column}{0.49\textwidth}
        \begin{center}
          \includegraphics[page=1,height=2cm]{fig/06-val-refs}
        \end{center}
        \STRUCTURE{Wertemodell für Variablen}
        \bii
        \ii Objekte \enquote{leben} in Variablen
        \ii Zuweisung erzeugt eine \textbf{Kopie}
        \ii Referenzen sind separate Objekte
        \ii[$\Rightarrow$] C, C++, Rust
        \eii
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \begin{center}
          \includegraphics[page=2,height=2cm]{fig/06-val-refs}
        \end{center}
        \STRUCTURE{Referenzmodell für Variablen}
        \bii
        \ii Variable speichert nur Referenz
        \ii Zuweisung erzeugt weitere Referenz
        \ii Keine separaten Referenzobjekte
        \ii[$\Rightarrow$] Java (mostly), Python, Ruby
        \eii
      \end{column}
    \end{columns}

  \end{frame}

  \begin{frame}[fragile]{Wertemodell: Vor- und Nachteile}
    \begin{columns}
      \begin{column}{0.45\textwidth}
        \begin{code}[tag=C++11]
          \begin{CPP}
            class foo_t { int x; };
            ...
            foo_t A { 23 };
            foo_t B = A;
            A.x = 42; // B.x == 23
          \end{CPP}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.53\textwidth}
        \bii
        \ii A und B enthalten \alert{verschiedene} Objekte
        \ii Initialisierung von B durch Kopie
        \ii Objekte-Inhalte/Speicher werden kopiert
        \eii
      \end{column}
    \end{columns}
    \medskip

    \bi
    \iiad<2-> Das Wertemodell is \advantage{flexibler} und kann \advantage{effizienter} sein. {
      \bi
      \ii Indirektion nur auf Nachfrage; kleine Objekte lassen sich effizient kopieren.
      \ii Referenzen sind explizit im Code sichtbar (als Zeiger-Typ)
      \ii Objekte in lokalen Variablen können am Stack alloziert werden.
      \ei
    }\medskip
    \iida<3-> Das Wertemodell ist \alert{komplexer} und \alert{schwieriger zu beherrschen}. {
      \bi
      \ii Referenzen machen das Programmiermodell komplexer.
      \ii Häufiges Kopieren \emph{kann} unsichtbaren Overhead erzeugen.
      \ii Initialisierung durch Kopieren (oder Verschieben) ist eigentlich ein Sonderfall\\
      $\Rightarrow$ C++ kennt 3 Sorten von Konstruktoren: Init-, Copy-, Move-Konstruktoren
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[fragile]{Referenzmodell: Vor- und Nachteile}
      \begin{columns}
      \begin{column}{0.45\textwidth}
        \begin{code}[tag=Java]
          \begin{java}
            class foo { public int x; }
            ...
            foo A = new foo();
            A.x   = 23;
            foo B = A;
            // B.x == 23
          \end{java}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.53\textwidth}
        \bii
        \ii Beide referenzieren das \alert{gleiche Objekt}
        \ii Automatisch Dereferenzierung
        \ii Objekterzeugung nur mittels \codeinline[style=java,style=smaller]{new T()}
        \eii
      \end{column}
    \end{columns}
    \medskip

    \bi
    \iiad<2-> Im Referenzmodell sind Variablen und Objekte \advantage{orthogonal}. {
      \bi
      \ii Objekte existieren \textbf{immer} unabhängig von Variablen und Funktionsaufrufen
      \ii Weitergabe quer zur Aufrufhierarchie ist trivial.
      \ii Keine Probleme mit Kind-Klassen die mehr Speicher brauchen.\\
          Problematisch in C++: \codeinline[style=CPP,style=smaller]{Base func() { Derived d; return d; }}
      \ei
    }\medskip
    \iida<3-> Im Referenzmodell tragen wir immer \alert{die Kosten} der Indirektion {
      \bi
      \ii Ohne Optimierungen müssen alle Objekte am Heap alloziert werden.
      \ii Todeszeitpunkt von Objekten ist unklar.
      \ii Primitive Typen: Jeder Integer hinter einem Pointer? \\
          Java: Wertemodell für Zahlen, außer wenn nicht (Auto(un-)boxing).
      \ei
    }
    \ei
  \end{frame}

#+end_src

Die grundlegendste Frage für die Verbindung von Programmtext und Objekten ist, wie diese abgelegt und weitergereicht werden.
Also wie die Verbindung von Namen und Objekten genau aussieht und wie ein Teil des Programms ein Objekt an einen anderen Teil des Programms weiter geben kann.

Dazu erinnern wir uns an die Vorlesung zur Namensauflösung{{{see(04-binding-time, Binding Time)}}}: Zum Bindezeitpunkt wird ein konkretes Objekt an einen Namen gebunden, sodass das Objekt über diesen Namen wieder aufgefunden werden kann.
Damals haben wir auch gesagt, dass das Ergebnis der *vollständigen Namensauflösung* die Startadresse des Objekts ist. Es schließt sich hier also der Kreis: die Startadresse, an der wir das Objekt initialisiert haben, wird zum Bindezeitpunkt an einen Namen gebunden. Ein solcher Name kann eine Variable sein, wie wir das in den Folien bei ~var_foo~ beispielhaft sehen.

Allerdings stellt sich eine wichtige, zunächst aber philosophisch anmutende, Frage:
Beinhaltet eine gebundene Variable das Objekt oder beinhaltet sie nur eine Referenz auf das Objekt.
Die Antwort auf diese Frage hat weitreichende Folgen:
Wenn eine Variable das Objekt beinhaltet, was wir das *Wertemodell für Variablen* nennen, so kann keine andere Variable das selbe Objekt beinhalten.
Dies hat zur Folge, dass jedes Objekt in maximal einer Variable gespeichert ist.
Wollen wir ein Objekt mit zwei Namen in Verbindung bringen, so müssen wir beim Wertemodell ein explizites Zwischenobjekt, eine Referenz bzw.
einen Pointer, anlegen und abspeichern.
Wertemodell bedeutet also, dass es separate Referenz-Objekte gibt.

Dass ein Objekt in maximal einer Variable abgelegt werden kann, führt auch dazu, dass Zuweisungen zwischen Variablen zwangsläufig eine *Objekt-Kopie* erfordern.
Um ein Objekt zu kopieren, allozieren wir Speicher für ein zweites Objekt und kopieren die enthaltenen Informationen in den neuen Speicher.
Das kopieren der Informationen kann entweder über bitweises Kopieren des Speichers geschehen (~memcpy()~) oder über einen nutzerdefinierten Copy-Konstruktor (C++).
In beiden Fällen läuft beim Kopieren der normale Konstruktor nicht.

Klassische Vertreter für das Wertemodell sind C, C++ oder, in modernen Zeiten, Rust.
Überlegen Sie sich für das folgende Stück C-Code, an wie viele und welche Objekte es gibt und wann es zu einer Objekt-Kopie kommt:

#+begin_src C
typedef struct { int x; } object_t;
object_t  a;
object_t  b = a;
object_t *c = &b;
object_t *d = c;
#+end_src

Der Gegenentwurf zum Wertemodell ist das *Referenzmodell für Variablen*, bei dem Variablen und Objekte unabhängig voneinander existieren und die Variable nur eine Referenz auf ein Objekt speichert.
Die Variable steht aber weiterhin für das Objekt und es bedarf keiner manuellen Dereferenzierung des Zeigers durch den Entwickler; die Sprache dereferenziert automatisch und unbedingt beim Zugriff auf das Objekt.
Da jede Variable nur Referenzen enthält, führen Zuweisungen zu keinen Objekt-Kopien, sondern es wird nur die Referenz von der einen Variable in die andere kopiert.
Am Ende stehen zwei Variablen für dasselbe Objekt.
Da Variablen alle Objekten nur referenzieren, benötigt eine Sprache, die nach dem Referenzmodell arbeitet, keine separaten Referenz-Objekte.

Die meisten Skriptsprachen verwenden das Referenzmodell.
Auch Java arbeitet hauptsächlich mit dem Referenzmodell, macht aber bei primitiven Datentypen (~int~, ~float~) eine Ausnahme und wendet für diese das Wertemodell an.
Etwas, was jedem Java-Lernendem zuerst komisch vorkommen muss.

Sowohl das Wertemodell, als auch das Referenzmodell haben ihre *Vor- und Nachteile*.
Wenn wir versuchen die Brille des effektiven Programmierers auf zu setzen, so ist ein reines Referenzmodell einfacher zu erlernen, da Objekte unabhängig von Variablen existieren und wir uns keine Gedanken darüber machen müssen ob wir eine Kopie oder eine Referenz weiter reichen wollen.
Außerdem werden Objekte beim Referenzmodell niemals implizit durch Kopieren angelegt, sonder immer explizit und mit Hilfe der Konstruktoren.
Diese Reduktion der Variablen-Objekt Abhängigkeit ist auch der Grund, wieso Java und die meisten Skriptsprachen das Referenzmodell bevorzugen; es ist einfacher zu handhaben.

Die Komplexität des Wertemodells können wir aber auch als eine Stärke auffassen:
Da alle Referenzen sichtbar und explizit sind, erlaubt uns das Wertemodell fein-granular zu steuern wann wir ein Objekt referenzieren und wann es in einer Variable lebt.
Dies erlaubt uns effizientere Programme zu schreiben:
Beim Referenzmodell tragen wir immer die Kosten für die Indirektion über die Referenz.
Beim Wertemodell müssen wir explizit danach verlangen eine Indirektion zu bekommen.
So kann es effizienter sein ein Objekt als Kopie an eine Funktion zu übergeben, als eine Referenz zu übergeben, die dann dereferenziert wird.
Dazu kommt, dass das Referenzmodell eigentlich nur mit Heap-allozierten Objekten richtig gut funktioniert, was zusätzliche Kosten erzeugt.
Beim Wertemodell können wir Objekte viel leichter auf dem Stack allozieren.
Aber Vorsicht, die starke Kopplung von Variablen und Objekten und die implizierte Kopien können beim Wertemodell zu Overheads führen, die auf den ersten Blick nicht sichtbar sind.
So alloziert das folgende Stück C-Code 8192 Bytes vom Stack und kopiert 4096 Bytes in einer unscheinbaren Zuweisung:

#+begin_src C
typedef struct { char stack[4096]; } thread_t;

void foo() {
  thread_t user_stack;
  thread_t tmp = user_stack;
}
#+end_src

Weitere Probleme des Wertemodells tritt bei Vererbung auf.
Wenn abgeleitete Klassen mehr Felder haben ihre Elternklassen, is das Kind-Objekt größer als das Elternobjekt.
Daher passt es, vom benötigten Speicherplatz her, nicht mehr in Variablen vom Elterntyp.
Dies spiegelt sich in C++ im Object Slicing{{{wikipedia_en(Object_slicing)}}} und in der Beschränkung, dass dynamische Typumwandlung nur mit Zeigern funktioniert, wieder.

Das andere Aspekt des Wertemodells, was sowohl Segen als auch Fluch ist, ist eine Folge der Starken Bindung der Lebenszeit eines Objekts an die Gültigkeit einer Variable.
Ein Objekt, welches in einer Variable residiert, muss zwangsläufig sterben, wenn die Variable ihre Gültigkeit verliert.
So sterben Objekte in lokalen Variablen, wenn die Funktion beendet wir.
Aber dazu später, bei der Deinitialisierung mehr.

Zusammenfassend ist zu sagen: Sowohl mit dem Referenzmodell, als auch mit dem Wertemodell, lässt sich gut Arbeiten und beide Modelle haben ihre Vor- und Nachteile. Ich persönlich finde das Wertemodell angenehmer, weil ich darin expliziter Ausdrücken kann, was ich haben möchte.

** Zugriff auf ein Objekt
:PROPERTIES:
:CUSTOM_ID: 06-access
:END:
#+begin_src latex
  \begin{frame}{Zugriff auf Objekte}
    \begin{center}
      \includegraphics[page=1]{fig/06-access}
    \end{center}

    \bi
    \ii Wer ist der \structure{Benutzer} eines Objekts? {
      \bi
      \ii Eigentlich: Das laufende Programm (aktiv) greift auf ein Objekt (passiv) zu.
      \ii Nützliche Präzisierungen: Zugreifende Funktion, zugreifender Thread
      \ei
    }\smallskip
    \ii Welche \structure{Berechtigungen} hat der Benutzer? {
      \bi
      \ii Referenzen sind Befähigungen (Capabilities) ein Objekt zu nutzen.
      \ii Nicht jede Referenz auf ein Objekt muss gleich mächtig sein.
      \ei
    }
    \ii Welche \structure{Arten von Zugriffen} gibt es? {
      \bi
      \ii Daten aus dem einem Objekt auslesen oder verändern.
      \ii Direkter Speicherzugriff oder gefiltert über getter/setter.
      \ii Ableitung weiterer Referenzen (z.B. Subobjekte: \codebox{\&obj.x}). \hfill \ALERT<1>{Gefährlich!}
      \ei
    }\smallskip
    \ei

    \uncover<2->{
      \begin{center}
        \vfill{}
        \OrangeBox{
          \textbf{Wer} greift \textbf{Wie} mit \textbf{welchem Recht} zu?        
        }
    \end{center}
    }
  \end{frame}
#+end_src
Nun, da wir Objekte herumreichen, und mittels Variablen in unserem Code verankern können, wollen wir natürlich auch auf diese Zugreifen, Informationen auslesen und Informationen verändern.
Dazu müssen wir zunächst die Akteure eines Zugriffs identifizieren:
Ganz klar und naheliegend ist, dass das Objekt auch das *Objekt des Zugriffs*[fn::In einem grammatikalischen Sinne von Subjekt - Verb - Objekt.] ist.

Aber welche Entitäten können Subjekt, also Handelnder, des Zugriffs sein?
Hier müssen wir uns anschauen, was die aktiven Teile unseres Programms sind, all diese können wir als *Benutzer eines Objekts* bezeichnen. Da haben wir zum einen das Stück Code von dem aus der Zugriff erfolgt; meist ist dies eine zugreifende Funktion. Aber auch der Thread von dem aus der Zugriff geschieht kann als Benutzer auftreten. Wichtig wird diese Festlegung, wie wir noch diskutieren werden, des Benutzers, wenn wir den Benutzerkreis eines Objekts einschränken wollen.

Der zweite Teil eines Zugriffs besteht aus der Frage:
Mit welchem Recht wir zugegriffen.
Dabei ist der Besitz einer Referenz auf das Objekt das Notwendige um einen Zugriff durch zu führen.
Aber nicht jede Referenz muss gleich mächtig sein, und es kann eingeschränkte Referenzen (wie read-only Referenzen) geben, über die nicht jeder Zugriff möglich ist.
Daher können wir Referenzen auch als Capabilities bzw. Befähigungen{{{wikipedia_de(Capability-based security)}}} zum Objektzugriff ansehen. 

Die letzte Frage ist welche Arten von Zugriffen es gibt. Hier fallen einem Sofort lesen und schreiben ein. Aber eigentlich ist auch das Erzeugen einer neuen Referenz ein Zugriff auf das Objekt, da wir mit einer Referenz Macht über ein Objekt weiter geben können. Wir wollen uns hier mit expliziten Setter und Getter Methoden auseinander setzen, die den Zugriff auf das Objekt filtern können.

Zusammenfassen kann man die Frage des Objekt-Zugriffs mit der Frage: *Wer greift Wie und mit welchem Recht auf ein Objekt zu?*

#+begin_src latex
  \begin{frame}{Benutzer-abhängige Zugriffseinschränkungen}
    \btAnimation{center,padding,3:<1->}{fig/06-access}
    \medskip
    \bi
    \ii \textbf{Ziel:} Benutzergruppen mit unterschiedlichen Zugriffsrechten {
      \bi
      \ii Identifikation der unterschiedlichen Gruppen \hfill(Wer greift zu?)
      \ii Einteilung anhand der zugreifenden Instruktionadresse
      \ii[$\Rightarrow$] Wir können den Code mit unbeschränktem Zugriff kontrollieren.
      \ei
    }\medskip
    \ii<2-> \textbf{Implementierung:} Einschränkung der Sichtbarkeit des Namens {
      \bi
      \ii Wenn der externe Nutzer einen Namen nicht sieht, kann er nicht zugreifen.
      \ii \textbf{Aber:} Gibt ein interner Nutzer eine Referenz auf ein privates Attribut heraus, bricht die Abstraktion. \textbf{Referenzen geben Kontrolle heraus!}
      \ei
    }
    \ei
  \end{frame}
  #+end_src

Beginnen wir also bei den Benutzern eines Objekts und beschränken uns darauf von welcher Codestelle ein Zugriff erfolgt.
Die Idee einen Zugriff anhand des Zugreifenden einzuschränken haben wir bereits, mit der Sichtbarkeit von Feldern in Klassen, kennen gelernt.
Dort unterscheiden wir zwischen Zugriffen, die von innerhalb der Klasse kommen und solchen die von außerhalb kommen.
Private Felder dürfen nur von innen, öffentliche Felder von überall her zugegriffen werden.

Generell müssen wir bei der Benutzer-abhängigen Zugriffseinschränkung die einzelnen Nutzergruppen definieren und ihnen gewisse Rechte zuschreiben. Bei der Sichtbarkeit von Felder geschiet diese Unterscheidung daran ob eine Funktion innerhalb der Klasse als Methode definiert wurde, oder außerhalb. Interne Benutzer bekommen bei dieser Einschränkung weitere Rechte.

Der große Vorteil einer solchen Einschränkung der externen Nutzer ist, dass wir sicher sein können, dass es in der gesamten Code-Basis keinen Zugriff auf die privaten Felder gibt, der nicht von einer unserer Methoden ausgeht.
*Alle Zugriffe auf private Felder laufen über Methoden.*
Auf diese Weise können wir viel leichter sicherstellen, dass die Invarianten des Objekts nicht verletzt werden. 
Außerdem können wir das Innere der Klasse beliebig verändern, da keine externer Benutzer Abhängigkeiten entwickeln konnte.
Dies ermöglicht es uns Implementierung und Daten zu *kapseln*.

Allerdings wird eine solche Kapselung löchrig, wenn wir in einer Methode eine Referenz auf ein eingebettetes Objekt an einen externen Benutzer heraus geben.
Mit solchen *flüchtenden Referenz* verlieren wir die Kontrolle über unser Objekt, unsere Invarianten und überhaupt alles an unserem Objekt.
Überlegen Sie sich demnach immer gut, ob Sie Code der Form ~inner_t* Object::method() {return &(this->inner);}~ schreiben sollten.

#+begin_src latex
  \begin{frame}{Referenzen-abhängige Zugriffseinschränkungen}
    \btAnimation{center,padding,4:<1->}{fig/06-access}
    \medskip

    \bi
    \ii \textbf{Ziel:} Einschränkbare Referenzen erlauben kontrolliertes Sharing {
      \bi
      \ii Über eingeschränkte Referenzen dürfen nicht alle Zugriffe erfolgen
      \ii Referenzen dürfen nur weiter eingeschränkt und nicht geweitet werden.
      \ii Beispiel: Ableitung einer read-only Referenz aus einer read-write Referenz
      \ei
    }\medskip
    \ii<2-> \textbf{Implementierung (const):}  Erweiterung des Typsystems{
      \bi
      \ii Weiterer Zeiger-Typkonstruktor:    \typeinline{const\_pointer(T)}\\[.5ex]
      \ii Implizite Typumwandlung zur read-only Referenz\\[.5ex]
      \ii Asymmetrische Typ-Kompatibilität:  \typeinline{const\_pointer(T)} $\ll$ \typeinline{pointer(T)}\\[.5ex]
      \ei
    }
    \ii<3-> Standardverhalten in verschiedenen Sprachen{
      \bi
      \ii \structure{C++}:  \hspace{1ex}\btSetTab Read-only ist die Ausnahme \hfill(\texttt{T*, const T\*}).
      \ii \structure{Rust}: \btUseTab Read-only ist die Regel \hfill(\texttt{\&T, \&mut T})
      \ii \structure{Java}: \btUseTab Alle Referenzen dürfen alles. 
      \ei
    }
    \ei
  \end{frame}

#+end_src

Die zweite Frage, die wir betrachten wollen ist die der *eingeschränkten Referenzen*.
Wie bereits gesagt, sind Referenz (bzw. Zeiger) Befähigungen über ein Objekt: 
Wer eine Referenz hat, hat Macht über ein Objekt.
Da nicht jede Nutzung eines Objekts volle Rechte braucht, erlauben es viele Sprachen Referenzen zu erzeugen, die *nicht* Allmächtig sind und nicht jede Art von Zugriff erlauben.
Der klassische Vertreter der *Referenz-abhängigen Zugriffseinschränkung* ist die read-only Referenz.

Sehen wir eine eingeschränkten Referenz, so können wir uns sicher sein, dass der Nutzer nur eine eingeschränkte Menge von Zugriffsarten durchführen wird.
So kann der Besitzer einer read-only Referenz das Objekt nur auslesen, nicht aber verändern.
Wichtig ist, dass Referenzen nur weiter eingeschränkt werden dürfen.
So sollte es dem Nutzer einer read-only Referenz (eigentlich) nicht möglich sein, wieder eine read-write Referenz abzuleiten.

Implementiert sind solche Referenz-abhängigen Zugriffseinschränkungen in Programmiersprachen normalerweise mittels unterschiedlicher Referenz-Typen.
Dort gibt es dann nicht nur den normalen Typkonstruktor für eine Referenz (~pointer(T)~), sondern noch weitere Referenztypen, die beispielsweise nur Lesezugriff erlauben (~const_pointer(T)~).
Die Propagierung der Zugriffseinschränkung und ihre Durchsetzung geschieht dann im Typ-spezifischen Teil der semantischen Analyse.

Bemerkenswert ist auch, wie unterschiedliche Sprachen den Read-only oder den read-write Fall zum Standardverhalten machen.
Bei C++ ist der normale Zeiger eine allmächtige Referenz auf ein Objekt und der Entwickler muss explizit mittels ~const~ angeben, wenn eine eingeschränkte Referenz vorliegt.
Bei Rust ist es genau umgekehrt.
Dort sind Referenzen per Default schreibgeschützt und wir müssen explizit veränderbare Referenzen erzeugen (~&mut~), für die dann noch weitere Einschränkungen gelten.
Java hat diese Art der eingeschränkten Referenzen nicht implementiert, da es das Erlernen der Sprache schwieriger macht.
Ein Stichwort, mit dem man C++-Entwickler an dieser Stelle gut reizen kann ist [[https://isocpp.org/wiki/faq/const-correctness][Const Correctness]].

#+begin_src latex
  \begin{frame}[fragile]{Gefilterter Zugriff über Zugriffsmethoden}
    \begin{columns}
      \begin{column}{0.44\textwidth}
        \begin{btBlock}{Direkter Speicherzugriff}
          \centering
          \texttt{obj.length = -1;}\\
          User kann Invarianten verletzen
        \end{btBlock}      
      \end{column}
      \begin{column}{0.10\textwidth}
        \centering
        \Huge$\leftrightarrow$
      \end{column}
      \begin{column}{0.44\textwidth}
        \begin{btBlock}{Zugriffsmethoden}
          \centering \texttt{obj.setLength(-1);}\\
          Boilerplate, reine Konvention
        \end{btBlock}      
      \end{column}
    \end{columns}

    \pause\bigskip

    \btAnimation{center,padding,2:<1->}{fig/06-access}
    \bi
    \ii Einige Sprachen erlauben den gefilterten Zugriff auf einzelne Attribute {
      \begin{columns}
        \begin{column}{0.55\textwidth}
          \bi
          \ii Verwendung sieht aus wie direkter Zugriff
          \ii \texttt{set()} beim Schreiben eines Attributs\\[-0.5ex]
          \ii \texttt{get()} zum Lesen eines Attributs
          \ii Kann \textbf{nachträglich} eingefügt werden, ohne die Benutzer zu ändern!
          \ei
        \end{column}\hfill
        \begin{column}{0.45\textwidth}
          \begin{code}[tag=C\#]
            \begin{sharpc}
              public class Student {
                private string name;
              
                public string Name {
                  get { return name; }
                  set { name = value; }
                }
              }
            \end{sharpc}
          \end{code}
        \end{column}
      \end{columns}

    }
    \ei
  \end{frame}
#+end_src

Der letzte Teil unserer Zugriffsbetrachtungen ist das "Wie?":
Wie greifen wir auf ein Objekt zu?
Der einfachste Fall, der am wenigsten Kosten verursacht und auf den am Ende /alle Zugriffe abgebildet werden müssen/ ist der *direkte Speicherzugriff*.
Bei diesem leiten wir aus der Objektadresse eine Zugriffsadresse ab (z.B. auf ein Feld) und lesen bzw. schreiben die Informationen des Objekts. 
Wie bereits mehrfach erwähnt, kann es problematisch sein, jedem direkten Speicherzugriff auf unser Objekt zu geben, da wir dadurch die Kontrolle über die Zugriffe verlieren und Invarianten verletzt werden könnte.

Gut wäre es, wenn wir bei Objekt-Zugriffen aktiven Code dazwischen schalten könnten.
Genau dies wird bei *Zugriffsmethoden*{{{wikipedia_en(Mutator_method)}}} gemacht.
Bei diesem Entwicklungsmuster verbietet man den Zugriff von Außen mittels Sichtbarkeit und legt Zugriffsmethoden mit kanonischen Namen an (~getLength(), ~setLength()~). 
Auf diese Weise können wir Zugriffe auf das Objekte Filtern und sicherstellen, dass der (externe) Nutzer des Objekts die Invarianten nicht verletzt.

Allerdings, Sie sehen das Problem bereits, das ganz artet, wenn man es von Anfang an, konsequent umsetzen will in eine richtige Boilerplate-Schlacht aus.
Und man muss es von Anfang an durchführen, weil ansonsten das hinzufügen eines Zugriffsfilters Änderung an allen Benutzer des Objekts nach sich ziehen würde.
Jeder direkte Zugriff müsste dann, in der gesamten Code-Basis, bei allen Kunden und deren Enkeln, zu einem Methodenaufruf umgebogen werden.

Daher bieten manche Sprache es an, Getter- und Setter-Methoden zu definieren, die beim Benutzer syntaktisch genauso aussehen, wie ein direkter Speicherzugriff. Ein Beispiel davon für C# sehen sie auf den Folien. Dort kann der Benutzer weiterhin ~obj.Name = "Max Mustermensch"~ schreiben und es wird dennoch die passende Getter-Funktion aufgerufen. Diese Syntaktische Gleichheit erlaubt es auch, solche Zugriffsmethoden im Nachhinein hinzuzufügen. In Python können Sie sich den ~@property~-Dekorator [[https://docs.python.org/3/library/functions.html#property][anschauen]].

** Fallstudie: Immutable Objects
:PROPERTIES:
:CUSTOM_ID: 06-immutable-objects
:END:
#+begin_src latex
  \begin{frame}[fragile]{Fallstudie: Unveränderliche Objekte}
    \begin{btBlock}{Unveränderliche Obejekte (immutable objects)}
      Gibt es für ein Objekt, im gesamten Programm, keine read-write Referenzen, so ist sein Inhalt unveränderlich.
    \end{btBlock}
  
    \bi
    \ii<2-> Immutability für ein Objekt bringt spannende Eigenschaften {
      \bi
      \ii Thread-Safety: Keine Probleme mit konkurrierenden Schreibzugriffen
      \ii Werte- und Referenzmodell werden equivalent.
      \ii Deduplikation von Objekten ist möglich (=interning).
      \ii \textbf{Aber:} Verändernde Operation müssen das Objekt verändert kopieren
      \ei
    }\medskip
    \ii<3-> Manche Objekte sind natürlichweise Immutable {
      \bi
      \ii \structure{Zahlen}: Die Zahl 5 kann nicht so verändert werden, dass alle Fünfen im gesamten Programm plötzlich Achten sind.
      \smallskip
      \ii \structure{String-Literale}: Der Übersetzer legt literale Zeichenketten (\codeinline[style=C,style=smaller]{"Hello"}) nur einmal in die Binärdatei.
      \ei
    }
    \ei
  \end{frame}
#+end_src

https://medium.com/@bdov_/https-medium-com-bdov-python-objects-part-iii-string-interning-625d3c7319de
** Ownership
:PROPERTIES:
:CUSTOM_ID: 06-ownership
:END:
#+begin_src latex
  \begin{frame}[fragile]{Ownership für Objekte}
    \begin{btBlock}[type=alert]{Wem gehört ein dieses Objekt?}
        Viele Bugs und Probleme  rühren daher, dass man sich keine Gedanken darüber gemacht hat, wer Verantwortung für ein Objekt hat.
    \end{btBlock}

    \bi
    \ii \textbf{Denkanweisung}: Wer ist der Besitzer und wo wird Besitz übertragen?{
      \bi
      \ii Besitzer kann ein Thread, eine Funktion oder ein anderes Objekt sein.
      \ii Der (letzte) Besitzer ist verantwortlich für die Freigabe des Objekts.
      \ii \alert{Geteilter Besitz} von Objekten erfordert immer \textbf{erhöhte Aufmerksamkeit}.
      \ei
    }
    \ei

    \begin{columns}<2->
      \begin{column}{0.49\textwidth}
        \begin{code}[]
          \begin{CPP}
            struct Cache {
              obj_t* obj;
              int set(obj_t* o) {
                this->obj = o;
              }
            };
            Cache cc; cc.set(obj);
            delete obj;
          \end{CPP}
        \end{code}
        \bii
        \ii \texttt{cc} hält Referenz auf anderes Objekt
        \ii \structure{dangling-reference problem}
        \eii
      \end{column}\hfill
      \begin{column}<3->{0.49\textwidth}
        \structure{Besitz ist Schwierig!}
        \bii
        \ii Besitz ist oft nur intentional!
        \ii Referenz impliziert keinen Besitz!\\[.5ex]
        \ii Modernste Sprachenentwicklungen:{%
          \bi
          \ii Hilfestellungen: \codeinline[style=CPP,style=smaller]{std::unique_ptr<T>}
          \ii Übersetzer prüft Besitzer statisch: Rust's Borrowchecker
          \ei
        }
        \eii
      \end{column}
    \end{columns}


  
  \end{frame}
#+end_src
* Tod von Objekten
:PROPERTIES:
:CUSTOM_ID: 06-death
:END:
#+begin_src latex
  \dividerframe{Tod von Objekten}

  \begin{frame}[fragile]{Wann endet die Lebenszeit eines Objekts?}
    \begin{btBlock}{Ende der Lebenszeit}
      Wenn ein Objekt, oder sein Seiteneffekt, nicht mehr benötigt wird, endet seine Lebenszeit und wir können es freigeben.
    \end{btBlock}

    \bi
    \ii Indikatoren für das Ende der Lebenszeit {
      \bi
      \ii Keine zukünftigen Zugriffe auf das Objekt \hfill Seiteneffekte?
      \ii Letzter Besitzanspruch erlischt         \hfill $\Rightarrow$ Notwendig
      \ii Letzte Referenz auf das Objekt wird ungültig \hfill $\Rightarrow$ Hinreichend
      \ei
    }
    \ii<2-> \structure{Explizite Freigabe} erfordert Disziplin und provoziert Speicherlecks\\[1ex]{
      \hfill \codeinline[style=C,style=smaller]{log_deinit(log);}
      \hfill \codeinline[style=CPP,style=smaller]{delete obj;} \small (C++)
      \hfill \mbox{}
    }
    \ei
    \medskip

    \begin{columns}<3->
      \begin{column}{0.49\textwidth}
        \structure{Referenzzählung}
        \bii
        \ii Kontinuierliches Zählen aller Besitzer
        \ii Exakter Todes-Zeitpunkt
        \ii Probleme mit Referenz-Zyklen
        \eii
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \structure{Garbage Collector}
        \bii
        \ii Finden der unreferenzierten Objekte
        \ii Entkopplung von Tod und Freigabe
        \ii Kosten treten in Bursts auf
        \eii
      \end{column}
    \end{columns}
  \end{frame}

  #+end_src
** Referenzzählung
:PROPERTIES:
:CUSTOM_ID: 06-refcount
:END:
#+begin_src latex
  \begin{frame}[fragile]{Referenzzählung}
  \begin{columns}
    \begin{column}{0.49\textwidth}
        \begin{code}[tag=C++]
          \begin{CPP}[style=smaller]
            class A {
              unsigned users;
              A()            { users=1; }
              void claim()   { users++; }
              void release() {
                if (--users == 0) {
                  delete this;
                }
              }
            };
          \end{CPP}
        \end{code}
    \end{column}\hfill
    \begin{column}{0.49\textwidth}
      \btAnimation[width=0.5\textwidth]{center,1:<2>,2:<3->}{fig/06-ref-cycle}
    \end{column}
  \end{columns}


    \bi
    \ii Besitzer zeigen an, wenn sie eine Referenz weiter- bzw. aufgeben {
      \bi
      \ii Reihenfolge von \texttt{claim()} und \texttt{release()} sind kritisch
      \ii Fällt der Zähler auf 0, wird das Objekt automatisch freigegeben.
      \ii<2-> Referenzieren sich Objekte zyklisch, wird \ALERT{niemals} freigegeben.
      \ei
    }\medskip
    \ii<4-> \structure{Smart Pointer} ermöglichen eine automatisierte Referenzzählung{
      \begin{columns}
        \hfill
        \begin{column}{0.6\textwidth}
        \begin{code}[]
          \begin{CPP}[style=smaller]
            { // Typausdruck: shared_ptr(int) vs ptr(int);
              std::shared_ptr<int> A(new int(23));
              (*A)++;
              {
                std::shared_ptr<int> B = A;
                std::cout << (*B); // -> 24;
              } // <- keine Freigabe
            } // <- Freigabe des ints
          \end{CPP}
        \end{code}
      \end{column}\hfill
    \end{columns}
    }
    \ei
  \end{frame}
  #+end_src

** Automatic Garbage Collection
:PROPERTIES:
:CUSTOM_ID: 06-garbage-collection
:END:
#+begin_src latex
  \begin{frame}{Garbage Collection}
    \begin{btBlock}{\textbf{Kernidee}: Nicht-referenzierte Objekte können freigegeben werden}\small
      \structure{Schritt 1}\quad\btSetTab Finde alle Objekte, die transitiv von einem \structure{root set} erreichbar sind.\\
      \structure{Schritt 2} \btUseTab Gebe alle nicht-erreichbaren Objekte frei.
    \end{btBlock}
    \medskip
    \bi
    \ii<2-> Erreichbarkeitsanalyse im Referenzgraphen {
      \bi
      \ii Jedes existierende Objekt ist ein Knoten im Referenzgraphen
      \ii Jede Referenz/Zeiger ist eine gerichtete Kante
      \ii Root Set: globale/lokale Variablen, Registerinhalte
      \ei
    }\medskip
    \ii<3-> \structure{Vorbedingungen und Probleme}  \hfill \structure{Ansatz}{
      \bi
      \ii Kenntnis alle existierender Objekte       \hfill Objektliste
      \ii Konsistente Sicht auf den Referenzgraphen \hfill stop-the-world
      \ii Erkennung aller ausgehenden Referenzen    \hfill Typsicherheit
      \ii Iteration über alle Objekte ist teuer     \hfill Partitionierte Objektmenge
      \ei
      \smallskip
        $\Rightarrow$ GC hauptsächlich in gemanagten Sprachen, wie Java oder Python. 
    }
    \ei
  \end{frame}

  \begin{frame}{Mark-and-Sweep Garbage Collector}
    \begin{btBlock}{}
    Der \structure{Mark-and-Sweep} Garbage Collector hält die Welt an, markiert alle erreichbaren Objekte, und gibt die anderen frei.
  \end{btBlock}

   \btAnimation[width=\textwidth]{center,range=1-13:<1->}{fig/06-mark-and-sweep}
  \end{frame}

  \begin{frame}[fragile]{Fallstudie: Der CPython3 Garbage Collector}
    \bi
    \ii Leistungsfähiger GC für eine Sprache bei der alles ein Objekt ist {
      \bi
      \ii Kombination aus Referenzzählung und Mark-and-Sweep GC
      \ii 3 Generationen für unterschiedlich alte Objekte
      \ii Zugriff aus der Python-VM über \texttt{gc}-Module
      \ei
    }
    \ei
    \begin{columns}[t]
      \begin{column}{0.49\textwidth}
        \begin{code}[]
          \lstinputlisting[style=py]{lst/06-garbage.py}          
        \end{code}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \begin{code}[]
          \begin{C}
            // +1 Für den Wurzelnamensraum
            // +1 für temp-argument
            Refcount: 2

            // Eingehende und Ausgehende Kanten
            x -> *: [<object at 0x1000>]
            ,* ->: x [<namespace: root>]

            // Alle Objekte
            Objects: 5823
          \end{C}
        \end{code}
      \end{column}
    \end{columns}
  
  \end{frame}
#+end_src

** Deinitialisierung
:PROPERTIES:
:CUSTOM_ID: 06-deinit
:END:
#+begin_src latex
  \begin{frame}[fragile]{Destruktoren}
    \begin{columns}
      \begin{column}{0.49\textwidth}
        \begin{code}[]
          \begin{CPP}[style=smaller]
            class A { ...
              A() {
                global.register(this);
                this->mem = malloc(3);
              }
            \end{CPP}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \begin{code}[]
          \begin{CPP}[style=smaller]
            class A { ...
              ~A() {
                free(mem);
                global->unregister(this);
              }
          \end{CPP}
        \end{code}
      \end{column}
    \end{columns}
    \medskip
    \bi
    \ii Destruktoren sollen die Konstruktor-Seiteneffekte rückgängig machen{
      \bi
      \ii Seiteneffekte: Registrierung bei anderen Objekten, Ressourcennachforderung
      \ii Löschung oder Invalidierung aller Referenzen auf das Objekt
      \ii Destruktoren habe keine Parameter
      \ei
    }\medskip
    \ii<2-> Destruktoren und Vererbung: Umgekehrte Konstruktionsreihenfolge  {
      \bi
      \ii Destruktor für Derived, muss ein gültiges Derived-Objekt vorfinden
      \ii \texttt{~Derived()} muss vor \texttt{~Base()} aufgerufen werden.
      \ei
    }\medskip
    \ii<3-> Schwierige Semantik für Sprachen mit Garbage Collection {
      \bi
      \ii GC: Todeszeitpunkt und Zeitpunkt der Freigabe sind entkoppelt
      \ii GC müsste den Destruktor aufrufen, dies geschieht aber \$IRGENDWANN\\[.5ex]
      \ii[$\Rightarrow$] Manuelle Deinitialisierung und \codeinline[style=java,style=smaller]{void finalize()}
      \ei
    }
    \ei
  \end{frame}
#+end_src

#+begin_src latex
  \begin{frame}[fragile]{Fallstudie: Resource Aquisition is Initialization (RAII)}
    \bi
    \ii C++: Kopplung von Scopes und der Lebenszeit lokaler Variablen{
      \bi
      \ii \structure{Wertemodell}: Lebenszeit von Variable und enthaltenem Objekt sind gleich
      \ii Definition einer Variable:  \hspace{3em}\btSetTab $\Rightarrow$ Konstruktor wird aufgerufen
      \ii Ende des umgebenden Scopes: \btUseTab $\Rightarrow$ Destruktor wird aufgerufen
      \ei
    }
    \ei

    \begin{columns}<2->
      \begin{column}{0.49\textwidth}
        \begin{code}[tag=C++]
          \begin{CPP}
            class log {
              level_t level;
              int fd;
              public:
                log() : level(DEBUG) {
                  fd = open("/dev/stderr");
                }
                ...
                ~log(){
                  close(fd);
                }
             };

             void foo() {
               log L; // Constructor
               L.log(...)
             } // implicit: Destructor
           \end{CPP}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \bii
        \ii Destruktor wird \advantage{immer} aufgerufen!{
          \bi
          \ii Ausführung erreicht Scope-Ende
          \ii Vorzeitiges \codeinline[style=C,style=smaller]{return}
          \ii Exceptions (direkt und indirekt)
          \ei
        }
        \ii[$\Rightarrow$] \advantage{Garantierte} Ressourcen-Freigabe\
        \bigskip
        \ii<3-> Anwendbar für alle Resourcentypen\\[1ex]{
          \begin{code}[]
            \begin{CPP}[style=smaller]
              mutex lock; // Das Lock-Objekt

              void foo() {
                lock_guard<mutex> X(lock);

                // Lock wird immer freigegeben
              }
            \end{CPP}
          \end{code}
          }
        \eii
      \end{column}
    \end{columns}

    \begin{overlaybox}[inner sep=2em,fill=badbee!30]<4->
      \textbf{Bjarne Stroustrup (Designer von C++):}\\[1ex]
      \enquote{The RAII technique [...] is a clumsy name for a \textbf{central concept} [that] happens to be \textbf{necessary} for exception handling. [...] the \textbf{main tool} for resource management is constructors and destructors.}\\[1ex]

      \hfill\scriptsize Interview mit Bill Venners, 2003
    \end{overlaybox}

  \end{frame}
#+end_src

* Zusammenfassung
#+begin_src latex
  \begin{frame}{Zusammenfassung}
    \bi
    \ii Objekte sind ein \STRUCTURE{existentieller Verbund} von Informationen {
      \bi
      \ii Objekte transportieren Informationen (typsicher) im Programmablauf
      \ii Referenz- und Wertemodell für Variablen
      \ei
    }\medskip
    \ii \STRUCTURE{Geburt}: In einem Speicherbereich entsteht ein Objekt {
      \bi
      \ii \structure{Allokation} des nötigen Speichers auf dem Stack, im Heap, oder statisch.
      \ii \structure{Konstruktoren} setzen Felder, fordern Ressourcen an und etablieren Invarianten
      \ei
    }\medskip
    \ii \STRUCTURE{Leben}: Kontrollierter und gefilter Zugriff auf die enthaltenen Daten {
      \bi
      \ii \structure{Wer} greift \structure{Wie}, mit welchem \structure{Recht}, auf das Objekt zu?
      \ii Der \structure{Besitz} von Objekten verpflichtet zu ihrer Pflege
      \ei
    }\medskip
    \ii \STRUCTURE{Tod}: Objekt verliert den letzten \structure{Besitzer} oder die letzte \structure{Referenz} {
      \bi
      \ii Manuelles Management, Referenzzähler oder automatische Garbage Collection
      \ii Destruktoren geben angeforderte Resourcen wieder frei
      \ei
    }
    \ei
  \end{frame}
#+end_src
