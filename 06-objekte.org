#+TITLE: Programmiersprachen und Übersetzer
#+SUBTITLE: 06 - Objekte
#+SETUPFILE: setup.org
#+INCLUDE: export-prologue.org
#+PROPERTY: header-args:latex :tangle yes :noweb yes :tangle-macros yes :tangle-prologue topic :tangle-epilogue endtopic :exports none

#+NAME: topic
#+BEGIN_SRC latex :tangle no
\psuSectionStart{{{{property(ITEM)}}}}{{{{n(block)}}}}
#+END_SRC

#+NAME: endtopic
#+BEGIN_SRC latex :tangle no
\psuSectionStop{{{{property(ITEM)}}}}{{{{n(block,-)}}}}
#+END_SRC

* Gedanken zu dieser Vorlesung                                     :noexport:
Stoffsammlung:
  - Lebenszyklus eines Objekts, Lebenszeit
  - Geburt und Initialisierung
    - Speicherallokation
    - Initialisierung 
    - Referenz vs. Value Model
  - Während der Lebenszeit
    - Getter und Setter
    - Problem: Paralleler Zugriff
    - Ownership of an Object
    - Read-Only Access
    - Immutable Objects
  - Garbage Collection  und Tod
    - Deinitialisierung
    - Reference Counting
    - Automatic Garbage Collection

Was soll der Studierende aus dieser Vorlesung mitnehmen?
  - Welche Besonderheiten kann eine Sprache bzgl. ihrer Objekte haben? [Effektiv]
  - Was bedeutet es ein Objekt zu kopieren?                            [Effizient]
* Was ist ein "Objekt"?
:PROPERTIES:
:CUSTOM_ID: 06-einleitung
:END:

#+begin_src latex
  \subtitle{{{{subtitle()}}}}
  \begin{frame}
    \maketitle
  \end{frame}

  \begin{frame}{Einordnung in die Vorlesung: Objekte}
    \begin{center}
      \includegraphics[page=13,width=0.6\linewidth]{fig/01-overview-small}
    \end{center}
    \bi
    \ii Objekte sind die datentragenden Elemente in einer Laufzeitumgebung {
      \bi
      \ii Die virtuelle Sprach-Maschine definiert \alert{Geburt, Leben und Tod} von Objekten.
      \ii Effiziente Programme gehen \advantage{sparsam und sorgsam} mit Objekten um.
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{Was ist ein Objekt?}
    \begin{center}
      \includegraphics[width=0.75\textwidth]{fig/06-object-types}
    \end{center}
    \bi
    \ii \textbf{Erinnerung 1. Vorlesung}: Maschinenmodell der virtuellen Maschine:{
      \bi
      \ii \structure{Speicher/Objekte}: Wie kann man Informationen ablegen und wieder abrufen?
      \ii \structure{Befehle/Operationen}: Wie kann man Informationen miteinander kombinieren?
      \ei
    }
    \ei
    \pause
    \begin{btBlock}{Definition: Objekt}
      Ein Objekt ist ein logisch-zusammengehöriger Verbund von Informationen, dessen \emph{Lebenszeit} kleiner oder gleich der Programmlaufzeit ist.
    \end{btBlock}
    \pause
    \hspace{-1em}\textbf{Wichtig:} \btSetTab (1) Variablen $\ne$ Objekte! Variablen können Objekte beinhalten.\\
    \btUseTab (2) Diese Definition umfasst auch primitive Objekte, wie Zahlen!
  \end{frame}

  \begin{frame}{Lebenszyklus eines Objekts}
    \hspace{-1em}\textbf{Vereinfachung:} Objekte residieren in zusammenhängendem Speicher
    \medskip
  
    \btAnimation[width=\textwidth]{range=1-4:<1->}{fig/06-lifecycle}

    \bi
    \ii \structure{Geburt}: Initialisierung von frisch allokiertem Speicher\\
    \small Objekt-Zustand muss so präpariert werden, dass die Typ-Invarianten gelten.
    \smallskip
    \ii<2-> \structure{Leben}: Objekte transportieren Informationen im Programmablauf\\
    \small Sprache kann es uns erleichtern die Typ-Invarianten zu erhalten, sonst: Bugs.
    \smallskip
    \ii<3-> \structure{Tod}: Kontrolliertes Aufräumen des Zustands und Freigabe der Ressourcen\\
    \small Der Zeitpunkt und der Verantwortliche für das Aufräumen ist sprachabhängig.
    \ei
  \end{frame}

#+end_src
#+begin_src latex
  \begin{frame}[fragile]{Beispiel: Leben eines Loggers}
    \begin{columns}
      \begin{column}{0.49\textwidth}
        \begin{code}[tag=C]
          \begin{C}[style=smaller]
            typedef enum {
              DEBUG, INFO, WARN, ERROR, 
            } level_t;
          
            typedef struct {
              level_t level;
              int fd;
            } log_t;

            int main() {
              // Geburt
              log_t *L = log_init();

              // Leben
              log(L, INFO, "message");
              L->level = DEBUG;
              log(L, INFO, "message");

              // Tod
              log_deinit(L);
            }
          \end{C}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \begin{code}[]
          \begin{C}[style=smaller]
            log_t * log_init() {
              // Allokation: Speicher am Heap
              log_t *l = malloc(sizeof(log_t));
              // Initialisierung des Zustands
              l->level = WARN;
              l->fd    = open("/dev/stderr", 0);
              return l;
            }
          \end{C}
        \end{code}

        \begin{code}[]
          \begin{C}[style=smaller]
            void
            log(log_t *l, level_t ll, char *m) {
              if (ll >= l->level) {
                write(l->fd, m, strlen(m));
              }
            }
          \end{C}
        \end{code}

        \begin{code}[]
          \begin{C}[style=smaller]
            void log_deinit(log_t *l) {
              close(l->fd); // Datei schließen
              free(l);      // Speicher freigeben
            }
          \end{C}
        \end{code}
      \end{column}
    \end{columns}

    \bi
    \ii<2-> Kaum Sprachunterstützung: \codeinline{struct log_t} kann man leicht falsch halten!{
      \bi
      \ii Benutzer kann Invarianten verletzen:\btSetTab\codeinline{L->fd = 23;}
      \ii Use-after-free Bugs: \btUseTab\codeinline{log_deinit(L); log(L, ERROR, "panic");}
      \ii Vergessen das Objekt frei zu geben $\rightarrow$ Memory Leak
      \ei
    }
    \ei
    
  \end{frame}
#+end_src
* Geburt von Objekten
** Speicher-Allokation
#+begin_src latex
  \dividerframe{Geburt von Objekten}

  \begin{frame}[fragile]{Allokation: Wo kommt der Speicherplatz her?}
    \hspace{-1em}\textbf{Meistens} residieren Objekte in einem zusammenhängenden Speicherbereich
    \medskip
    \begin{center}
      \texttt{allocate(bytes\_t N)} $\longrightarrow$ Startadresse des zukünfigen Objekts
    \end{center}

    \bi
    \ii<2-> \structure{Statische Allokation} durch Übersetzer: Lebenszeit = Programlaufzeit {
      \bi
      \ii Absolute Adresse des Objekts steht vor der Laufzeit fest
      \ii Bsp.: globale Variablen, konstante Literale, Maschinencode einer Funktion
      \ii 2 statische Objekte: \codeinline{char *global = "foobar";} 
      \ei
    }\medskip
    \ii<3-> \structure{Stack Allokation}: Objekte können auf den Aufrufstapel{
      \bi
      \ii Allokation als Einbettung des Call-Frames einer Funktionsinstanz.
      \ii Lebenszeit des Objekts ist $\le$ Lebenszeit des Call-Frames.
      \ii Beispiele: Argumente, lokale Variablen, \codeinline{alloca()}
      \ei
    }\medskip
    \ii<4-> \structure{Heap Allokation}: Laufzeitsystem betreibt separaten Speicherpool {
      \bi
      \ii Lebenszeit unabhängig von Aufrufhierarchie, beliebige Allokations-Zeitpunkte
      \ii Benötigt komplexeres Speichermanagement und ist daher teurer.
      \ii Speicher muss irgendwann freigeben werden (manuell oder garbage collection)
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{Allokationen im größeren Kontext}
    \begin{center}
      \includegraphics[width=0.8\textwidth]{fig/06-process-mem}
    \end{center}

    \bi
    \ii Im klassisches UNIX-Modell wachsen Stack und Heap aufeinander zu.{
      \bi
      \ii Das ELF beschreibt die statisch allokierten Objekte (.text, .data, .bss)
      \ii Realität ist komplexer: Mehrere Stacks/Heaps, Addressspace-Randomization
      \smallskip
      \ii[$\rightarrow$] Genauere Betrachtung in Grundlagen der Betriebssysteme (GBS)
      \ei
    }\medskip
    \ii Für Programmiersprachen und Übersetzer nehmen wir an, dass... {
      \bi
      \ii Wir globale Objekte im Assembler anlegen können.
      \ii Der Prozess einen Stack hat und wir den Stackpointer kontrollieren.
      \ii Das Laufzeitsystem \codebox{void *malloc(size\_t)}/\codebox{free(void*)} bereitstellt.
      \ei
    }
    \ei
  \end{frame}
#+end_src
** Initialisierung
#+begin_src latex
  \begin{frame}{Initialisierung und Konstruktoren}
    \begin{btBlock}{}
      Wie wird aus dem allokierten, noch blanken, Speicherbereich ein Objekt?    
    \end{btBlock}

    \bi
    \ii \structure{Sprachabhängige} Initialisierung etabliert Meta-Informationen\\[1ex]
        \small\emph{Was macht ein Stück Speicher für meine Sprache zu einem Objekt?}\\[1ex]
        {
          \bi
          \ii Einige Sprachfeatures  erfordern zusätzliche Informationen an jedem Objekt.
          \ii Zum Beispiel  \btSetTab -- Dynamische Typinformationen in Form eines \structure{Typ-Tags}.\\
                            \btUseTab -- Registrierung des Objekts am Garbage Collector (später mehr)
          \ei
        }\medskip
    \ii<2-> \structure{Benutzerdefinierte} Initialisierung durch \textbf{Konstruktoren}\\[1ex]{
      \small\emph{Was möchte der Benutzer bei der Geburt eines Objekts tun?}\\[1ex]
      \bi
      \ii Initiale Belegungen der Objekt-Attribute
      \ii Parametrisierte Konstruktion
      \ii Intention des Benutzers: Etablierung der \textbf{semantischen Invarianten}
      \ei>
    }
    \ei
  \end{frame}

  \begin{frame}[fragile]{Sprachregeln für Konstruktoren }
    \begin{columns}
      \begin{column}{0.49\textwidth}
        \begin{code}[tag=C++]
          \begin{CPP}
            class Base {
              public: 
                Base(int x)    { ... }
                Base(string x) { ... }
            };
          \end{CPP}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \begin{code}[tag=Java]
          \begin{java}
            class Base {
              public Base(int x)    { ... }
              public Base(String x) { ... }
            };
          
          \end{java}
        \end{code}
      \end{column}
    \end{columns}

    \bi
    \ii \structure{Definition} von eigenen Konstruktoren {
      \bi
      \ii Definieren wir keine eigenen, werden Default-Konstruktoren erzeugt
      \ii Konstruktoren haben Parameter und können Überladen werden
      \ii Sehen aus wie Funktionen, haben aber keinen Rückgabewert
      \ei
    }\medskip
  
    \ii \structure{Aufruf} von Konstruktoren {
      \bi
      \ii Konstruktoren werden bei Objekterstellung \alert{automatisch} aufgerufen.
      \ii Bei Vererbung: Eltern-Konstruktoren vor Kind-Konstruktoren\\
          $\Rightarrow$ Kind-Konstruktoren finden ein valides Eltern-Objekt vor.
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[fragile]{Konstruktoren in Aktion: Java}
    \begin{columns}
      \begin{column}{0.4\textwidth}
        \begin{code}[]
          \tikzset{every dn/.style={visible on=<2->}}
          \lstinputlisting[style=java,style=smaller]{lst/06-counter.java}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.59\textwidth}
        \bii
        \ii Java {\bi
          \ii Konstruktoren heißen wie die Klasse.
          \ii Nicht-initialisierte Attribute werden automatisch 0 oder \texttt{null}
          \ei
        }
        \medskip
        \ii<2-> Ablauf für \codeinline[style=java,style=smaller]{new Derived("123")}{
          \bi
          \ii[{\dn[font=\tiny]{1}}]\footnotesize Aufruf anderer Konstruktoren mittels \codeinline[style=java,style=smaller]{this()}
          \ii[{\dn[font=\tiny]{2}}]\footnotesize Elternkonstruktor mittels \codeinline[style=java,style=smaller]{super()}
          \ii[{\dn[font=\tiny]{3}}]\footnotesize Konstruktor setzt \codeinline[style=java,style=smaller]{final}-Attribut
          \ii[{\dn[font=\tiny]{4}}]\footnotesize Autom. Nullung durch \codeinline[style=smaller]{Object}-Konstruktor

          \ei
        }
        \medskip
        \ii<3-> { Wie sähe eine manuelle Konstruktion aus?
          \begin{minipage}{0.9\linewidth}
            \begin{code}[tag=Pseudo-C]
              \begin{C}[style=smaller]
                // Allokation
                Derived *this = malloc(sizeof(Derived));

                // Sprachspezifisches Init
                memset(this, 0, sizeof(Derived));
                this->vtable = Dervied_vtable;

                // Konstruktor (inlined)
                int tmp = parseInt("123")
                this->start = 3+tmp;
              \end{C}
            \end{code}
          \end{minipage}
        }
        \eii
    \end{column}
    \end{columns}
  \end{frame}


#+end_src

#+begin_src latex
  \begin{frame}[fragile]{Was sollte \textbf{mein} Konstruktor leisten?}
    \begin{btBlock}{\small Sinnvolle Konvention: Konstruktoren stellen semantische Invarianten her}\small
      -- Entwickler trifft \textbf{immerwährende Annahmen} über den Zustand eines Objekts. \\
      -- \textbf{Jeder} Konstruktor hinterlässt ein Objekt, dass die Annahmen einhält.\\
      -- Jede weitere Operation auf dem Objekt muss diese Annahmen \textbf{erhalten}.
    \end{btBlock}

    \bi
    \ii<2-> Beispiel: Bounded Pointer zeigt nur auf die Elemente eines Arrays\\[0.5ex] {
      \begin{columns}
        \begin{column}{0.44\textwidth}
          \begin{code}[]
            \begin{CPP}[style=smaller]
              class bounded_ptr {
                int *data;
                unsigned length;
                int *ptr;
              
                bounded_ptr(unsigned len) {
                  data   = malloc(len);
                  length = len;
                  ptr    = &data[0];
                }

                void set(int val) {
                  ,*ptr = val;
                }
                ...
              };
            \end{CPP}
          \end{code}
        \end{column}\hfill
        \begin{column}{0.55\textwidth}
          \bi
          \ii Invarianten für bounded\_ptr {
            \btUseExtraItemSep
            \bi
            \ii \texttt{data} zeigt auf ein valides Integer-Array\\[1ex]
            \ii \texttt{length} gibt Länge dieses Arrays an\\[1ex]
            \ii \texttt{ptr} ist die Adresse eines Array-Elements
            \ei
          }
          \ii<3-> \textbf{\advantage{Bonussternchen}}, falls der Benutzer nicht in der Lage ist die Invarianten zu verletzen.
          \ei
        \end{column}
      \end{columns}


    }
    \ei
  

  \end{frame}
#+end_src
* Leben von Objekten
** Referenz vs. Wertesemantik
** Unkontrollierer Objektzugriff
** Read-Only Zugriff und Immutable Data
** Lebenszeiten
* Tod von Objekten
** Deinitialisierung
** Reference Counting
** Automatic Garbage Collection
