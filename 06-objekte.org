#+TITLE: Programmiersprachen und Übersetzer
#+SUBTITLE: 06 - Objekte
#+SETUPFILE: setup.org
#+INCLUDE: export-prologue.org
#+PROPERTY: header-args:latex :tangle yes :noweb yes :tangle-macros yes :tangle-prologue topic :tangle-epilogue endtopic :exports none

#+NAME: topic
#+BEGIN_SRC latex :tangle no
\psuSectionStart{{{{property(ITEM)}}}}{{{{n(block)}}}}
#+END_SRC

#+NAME: endtopic
#+BEGIN_SRC latex :tangle no
\psuSectionStop{{{{property(ITEM)}}}}{{{{n(block,-)}}}}
#+END_SRC

* Gedanken zu dieser Vorlesung                                     :noexport:
Stoffsammlung:
  - Lebenszyklus eines Objekts, Lebenszeit
  - Geburt und Initialisierung
    - Speicherallokation
    - Initialisierung 
    - Referenz vs. Value Model
  - Während der Lebenszeit
    - Getter und Setter
    - Problem: Paralleler Zugriff
    - Ownership of an Object
    - Read-Only Access
    - Immutable Objects
  - Garbage Collection  und Tod
    - Deinitialisierung
    - Reference Counting
    - Automatic Garbage Collection

Was soll der Studierende aus dieser Vorlesung mitnehmen?
  - Welche Besonderheiten kann eine Sprache bzgl. ihrer Objekte haben? [Effektiv]
  - Was bedeutet es ein Objekt zu kopieren?                            [Effizient]
* Was ist ein "Objekt"?
:PROPERTIES:
:CUSTOM_ID: 06-einleitung
:END:

#+begin_src latex
  \subtitle{{{{subtitle()}}}}
  \begin{frame}
    \maketitle
  \end{frame}

  \begin{frame}{Einordnung in die Vorlesung: Objekte}
    \begin{center}
      \includegraphics[page=13,width=0.6\linewidth]{fig/01-overview-small}
    \end{center}
    \bi
    \ii Objekte sind die datentragenden Elemente in einer Laufzeitumgebung {
      \bi
      \ii Die virtuelle Sprach-Maschine definiert \alert{Geburt, Leben und Tod} von Objekten.
      \ii Effiziente Programme gehen \advantage{sparsam und sorgsam} mit Objekten um.
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{Was ist ein Objekt?}
    \begin{center}
      \includegraphics[width=0.75\textwidth]{fig/06-object-types}
    \end{center}
    \bi
    \ii \textbf{Erinnerung 1. Vorlesung}: Maschinenmodell der virtuellen Maschine:{
      \bi
      \ii \structure{Speicher/Objekte}: Wie kann man Informationen ablegen und wieder abrufen?
      \ii \structure{Befehle/Operationen}: Wie kann man Informationen miteinander kombinieren?
      \ei
    }
    \ei
    \pause
    \begin{btBlock}{Definition: Objekt}
      Ein Objekt ist ein logisch-zusammengehöriger Verbund von Informationen, dessen \emph{Lebenszeit} kleiner oder gleich der Programmlaufzeit ist.
    \end{btBlock}
    \pause
    \hspace{-1em}\textbf{Wichtig:} \btSetTab (1) Variablen $\ne$ Objekte! Variablen können Objekte beinhalten.\\
    \btUseTab (2) Diese Definition umfasst auch primitive Objekte, wie Zahlen!
  \end{frame}

  \begin{frame}{Lebenszyklus eines Objekts}
    \hspace{-1em}\textbf{Vereinfachung:} Objekte residieren in zusammenhängendem Speicher
    \medskip
  
    \btAnimation[width=\textwidth]{range=1-4:<1->}{fig/06-lifecycle}

    \bi
    \ii \structure{Geburt}: Initialisierung von frisch allokiertem Speicher\\
    \small Objekt-Zustand muss so präpariert werden, dass die Typ-Invarianten gelten.
    \smallskip
    \ii<2-> \structure{Leben}: Objekte transportieren Informationen im Programmablauf\\
    \small Sprache kann es uns erleichtern die Typ-Invarianten zu erhalten, sonst: Bugs.
    \smallskip
    \ii<3-> \structure{Tod}: Kontrolliertes Aufräumen des Zustands und Freigabe der Ressourcen\\
    \small Der Zeitpunkt und der Verantwortliche für das Aufräumen ist sprachabhängig.
    \ei
  \end{frame}

#+end_src

#+begin_src latex
  %%ONLY%%
  \begin{frame}[fragile]{Beispiel: Leben eines Loggers}
    \begin{columns}
      \begin{column}{0.49\textwidth}
        \begin{code}[tag=C]
          \begin{C}[style=smaller]
            typedef enum {
              DEBUG, INFO, WARN, ERROR, 
            } level_t;
          
            typedef struct {
              level_t level;
              int fd;
            } log_t;

            int main() {
              // Geburt
              log_t *L = log_init();

              // Leben
              log(L, INFO, "message");
              L->level = DEBUG;
              log(L, INFO, "message");

              // Tod
              log_deinit(L);
            }
          \end{C}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \begin{code}[]
          \begin{C}[style=smaller]
            log_t * log_init() {
              // Allokation: Speicher am Heap
              log_t *l = malloc(sizeof(log_t));
              // Initialisierung des Zustands
              l->level = WARN;
              l->fd    = open("/dev/stderr", 0);
              return l;
            }
          \end{C}
        \end{code}

        \begin{code}[]
          \begin{C}[style=smaller]
            void
            log(log_t *l, level_t ll, char *m) {
              if (ll >= l->level) {
                write(l->fd, m, strlen(m));
              }
            }
          \end{C}
        \end{code}

        \begin{code}[]
          \begin{C}[style=smaller]
            void log_deinit(log_t *l) {
              close(l->fd); // Datei schließen
              free(l);      // Speicher freigeben
            }
          \end{C}
        \end{code}
      \end{column}
    \end{columns}

    \bi
    \ii<2-> Kaum Sprachunterstützung: \codeinline{struct log_t} kann man leicht falsch halten!{
      \bi
      \ii Benutzer kann Invarianten verletzen:\btSetTab\codeinline{L->fd = 23;}
      \ii Use-after-free Bugs: \btUseTab\codeinline{log_deinit(L); log(L, ERROR, "panic");}
      \ii Vergessen das Objekt frei zu geben $\rightarrow$ Memory Leak
      \ei
    }
    \ei
    
  \end{frame}
#+end_src
* Geburt von Objekten
** Speicher-Allokation
** Initialisierung
** Referenz vs. Wertesemantik
* Leben von Objekten
** Unkontrollierer Objektzugriff
** Read-Only Zugriff und Immutable Data
** Lebenszeiten
* Tod von Objekten
** Deinitialisierung
** Reference Counting
** Automatic Garbage Collection
