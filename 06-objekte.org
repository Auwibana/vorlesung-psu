#+TITLE: Programmiersprachen und Übersetzer
#+SUBTITLE: 06 - Objekte
#+SETUPFILE: setup.org
#+INCLUDE: export-prologue.org
#+PROPERTY: header-args:latex :tangle yes :noweb yes :tangle-macros yes :tangle-prologue topic :tangle-epilogue endtopic :exports none

#+NAME: topic
#+BEGIN_SRC latex :tangle no
\psuSectionStart{{{{property(ITEM)}}}}{{{{n(block)}}}}
#+END_SRC

#+NAME: endtopic
#+BEGIN_SRC latex :tangle no
\psuSectionStop{{{{property(ITEM)}}}}{{{{n(block,-)}}}}
#+END_SRC

* Gedanken zu dieser Vorlesung                                     :noexport:
Stoffsammlung:
  - Lebenszyklus eines Objekts, Lebenszeit
  - Geburt und Initialisierung
    - Speicherallokation
    - Initialisierung 
    - Referenz vs. Value Model
  - Während der Lebenszeit
    - Getter und Setter
    - Problem: Paralleler Zugriff
    - Ownership of an Object
    - Read-Only Access
    - Immutable Objects
  - Garbage Collection  und Tod
    - Deinitialisierung
    - Reference Counting
    - Automatic Garbage Collection

Was soll der Studierende aus dieser Vorlesung mitnehmen?
  - Welche Besonderheiten kann eine Sprache bzgl. ihrer Objekte haben? [Effektiv]
  - Was bedeutet es ein Objekt zu kopieren?                            [Effizient]
* Was ist ein "Objekt"?
:PROPERTIES:
:CUSTOM_ID: 06-einleitung
:END:

#+begin_src latex
  \subtitle{{{{subtitle()}}}}
  \begin{frame}
    \maketitle
  \end{frame}

  \begin{frame}{Einordnung in die Vorlesung: Objekte}
    \begin{center}
      \includegraphics[page=13,width=0.6\linewidth]{fig/01-overview-small}
    \end{center}
    \bi
    \ii Objekte sind die datentragenden Elemente in einer Laufzeitumgebung {
      \bi
      \ii Die virtuelle Sprach-Maschine definiert \alert{Geburt, Leben und Tod} von Objekten.
      \ii Effiziente Programme gehen \advantage{sparsam und sorgsam} mit Objekten um.
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{Was ist ein Objekt?}
    \begin{center}
      \includegraphics[width=0.75\textwidth]{fig/06-object-types}
    \end{center}
    \bi
    \ii \textbf{Erinnerung 1. Vorlesung}: Maschinenmodell der virtuellen Maschine:{
      \bi
      \ii \structure{Speicher/Objekte}: Wie kann man Informationen ablegen und wieder abrufen?
      \ii \structure{Befehle/Operationen}: Wie kann man Informationen miteinander kombinieren?
      \ei
    }
    \ei
    \pause
    \begin{btBlock}{Definition: Objekt}
      Ein Objekt ist ein existentiell-abhängiger Verbund von Informationen.
    \end{btBlock}
    \pause
    \hspace{-1em}\textbf{Wichtig:} \btSetTab (1) Variablen $\subset$ Objekte! Variablen können Objekte beinhalten.\\
    \btUseTab (2) Diese Definition umfasst auch primitive Objekte, wie Zahlen!
  \end{frame}
#+end_src

Nachdem wir uns im Kapitel zur semantischen Analyse stark mit Techniken beschäftigt haben, welche in einem Übersetzer zum Einsatz kommen, wollen wir uns in diesem Kapitel wieder den *Konzepten von Programmiersprachen* widmen.
Genauer gesagt, wollen wir betrachten, was eigentlich ein *Objekt* ausmacht und welchen Wandel ein einzelnes Objekt im Verlauf eines Programms durchmacht.
Dabei werde ich ein viel breiteres und gleichzeitig viel engeres Verständnis von "Objekt" annehmen, als man dies in den sogenannten Objekt-Orientierten Programmiersprachen verwendet.
Breiter deshalb, weil ich jedes Datum und jede Ansammlung von Daten als Objekt betrachte, und enger, weil ich dabei nur auf die passiven Informationen und nicht auf die damit verbundenen (aktiven) Operationen eingehe.
Diese werde ich erst im nächsten Kapitel genauer diskutieren.

Es lohnt sich jedoch Objekt einmal in Isolation, losgelößt von ihren Operationen, zu betrachten.
Objekte sind jene Entitäten mit deren Hilfe wir Informationen im Programmverlauf hin und her werfen.
Daher ist es für den /effektiven Programmierer/ essentiell zu verstehen wie Objekte entstehen, wie wir sie verwenden und wie sie zerstört werden.
Um diesen Wandel einzelner Objekte zu verdeutlichen, werde ich für diese Vorlesung die Metapher vom Lebenszyklus eines Objekts verwenden, welche sich in vielen etablierten programmiersprachlichen Begriffen, wie der Lebenszeit eines Objekts, wiederfindet.
Der /effiziente Programmierer/ lernt in dieser Vorlesung, welche Kosten bei unterschiedlichen Typen von Objekten und Zugriffen entstehen und was es bedeutet wenn eine Sprache automatisches Speichermanagement (Garbage Collection) durchführt.

Zunächst müssen wir aber definieren, was wir, für diese Vorlesung, unter einem "Objekt" überhaupt verstehen.
Dazu möchte ich noch einmal das Maschinenmodell aus der ersten Vorlesung in Erinnerung rufen:
Die virtuelle Maschine der Sprache definiert wie wir Informationen ablegen (Objekte im Speicher) und wie wir diese Daten verarbeiten können (Operationen).
Schauen wir mit dieser Brille auf einen real-existierenden Prozessor, so kennt dessen Maschinenmodell nur Zahlen als Objekte, welche in Registern bzw. dem Hauptspeicher abgelegt werden können.
Weiterhin ist jede Zahl ein Verbund von 8, 16, 32 oder 64 einzelnen Bits, welche die grundlegendste informations-tragende Entität ist.

Verallgemeinern wir dies, so könnten wir sagen, dass ein Objekt ein Verbund von Informationen ist, der existentiell voneinander abhängig ist und logisch zusammengehört.
Logisch-zusammengehörig deswegen, weil die Definition unabhängig davon ist, an welchen Orten die Informationen gespeichert sind.
So sind die einzelnen Bits eines Maschinenworts in unterschiedlichen Flip-Flops bzw.
DRAM-Zellen[fn::Im Fall von DRAM können die einzelnen Bits einer Speicherzelle sogar auf mehrere Chips verteilt sein.]
verteilt.
Dies hält uns aber nicht davon ab, die logisch-zusammengehörigen Bits als eine Zahl zu sehen. Löschen wir die Zahl, zum Beispiel durch überschreiben der Speicherzelle, so gehen auch die Wahrheitswerte der einzelnen Bits verloren. Die Bits sind also in ihrer Existenz abhängig von der Zahl.

Betten wir ein Objekt ein, so entsteht ein neues, größeres Objekt und die Einbettung wird existentiell abhängig:
Das Array von Zahlen ist ein Verbund einzelner Zahlen, löschen wir das Array von Zahlen, so löschen wir auch die enthaltenen Zahlen.
Dabei ist egal, dass die Zahlen weiterhin im Speicher an der Stelle stehen, wo früher das Objekt stand. Für die Programmiersprache sind die Zahl-Objekte verloren.

Auf Ebene der Programmiersprache haben wir eine deutlich größere Auswahl an verschiedenartigen und strukturierten Objekten als einfach nur Zahlen.
Einen Einblick in solch strukturierte Daten haben wir bereits in der Typen-Vorlesung kennen gelernt[fn::Damals haben wir Typen, unter anderem, *denotationell* definiert: Typen sind die Menge von Objekten die sie beschreiben.
Die Objekte dieser Typen sind es, mit denen wir uns nun beschäftigen werden.]:
Zahlen, Arrays, Records, Referenzen, etc.
Diese Objekte können alleine stehen (die Zahl) oder als Einbettung eines größeren Objekts auftreten (Array von Zahlen).
Auf den Folien ist jeder umrandete Kasten ein einzelnes Objekt.

Anders ist es, wenn wir eine Referenz auf ein anderes Objekt einbetten.
In diesem Fall haben wir zwei unterschiedliche Objekte, da das referenzierte Objekt *unabhängig* von referenzierenden Objekt existieren könnte.
Das Löschen des einen Objekts führt nicht zwingend zur Löschung des anderen Objekts.

#+begin_src latex
  \begin{frame}<handout:4>{Lebenszyklus eines Objekts}
    \hspace{-1em}\textbf{Vereinfachung:} Objekte residieren in zusammenhängendem Speicher
    \medskip
  
    \btAnimation[width=\textwidth]{range=1-4:<1->}{fig/06-lifecycle}

    \bi
    \ii \structure{Geburt}: Initialisierung von frisch allokiertem Speicher\\
    \small Objekt-Zustand muss so präpariert werden, dass die Typ-Invarianten gelten.
    \smallskip
    \ii<2-> \structure{Leben}: Objekte transportieren Informationen im Programmablauf\\
    \small Sprache kann es uns erleichtern die Typ-Invarianten zu erhalten, sonst: Bugs.
    \smallskip
    \ii<3-> \structure{Tod}: Kontrolliertes Aufräumen des Zustands und Freigabe der Ressourcen\\
    \small Der Zeitpunkt und der Verantwortliche für das Aufräumen ist sprachabhängig.
    \ei
  \end{frame}
#+end_src

Deutlich spannender als die Frage, welche Art von Objekten es gibt, ist der *Lebenszyklus* von Objekten, denn viele Sprachkonstrukte drehen sich um das Management dieses Lebenszyklus:
Durch Allokation und Initialisierung wird ein Objekt geboren.
Während des Lebens, hat es einen, oder mehrere, Besitzer, die es ausgelesen, verändern und an Dritte weitergegeben.
Und mit der Deinitialisierung und der Freigabe des Speichers, verlässt es uns wieder.

Während der gesamten Lebenszeit ist ein Objekt nur deswegen Objekt, weil es die Regeln seines Typen, die *Typ-Invarianten*, einhält.
Diese Invarianten werden bei der Objekt-Geburt, durch die passende Belegung des Speichers, etabliert und müssen während der gesamten Lebenszeit aufrecht erhalten werden.
Verletzen wir diese Invarianten, zum Beispiel indem wir das 0-Byte am Ende eines C-Strings überschreiben, so verletzen wir das Typsystem und es kommt zu einem Bug.
Erst beim Tod des Objekts dürfen die Typinvarianten wieder verletzt werden.
Die Dauer dieses Lebenszyklus ist die *Lebenszeit* eines Objekts.

Mit diesen drei Phasen des Lebenszyklus (Geburt, Leben und Tod) werden wir uns in dieser Vorlesung beschäftigen.

#+begin_src latex
  \begin{frame}[fragile]{Beispiel: Leben eines Loggers}
    \begin{columns}
      \begin{column}{0.49\textwidth}
        \begin{code}[tag=C]
          \begin{C}[style=smaller]
            typedef enum {
              DEBUG, INFO, WARN, ERROR, 
            } level_t;
          
            typedef struct {
              level_t level;
              int fd;
            } log_t;

            int main() {
              // Geburt
              log_t *L = log_init();

              // Leben
              log(L, INFO, "message");
              L->level = DEBUG;
              log(L, INFO, "message");

              // Tod
              log_deinit(L);
            }
          \end{C}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \begin{code}[]
          \begin{C}[style=smaller]
            log_t * log_init() {
              // Allokation: Speicher am Heap
              log_t *l = malloc(sizeof(log_t));
              // Initialisierung des Zustands
              l->level = WARN;
              l->fd    = open("/dev/stderr", 0);
              return l;
            }
          \end{C}
        \end{code}

        \begin{code}[]
          \begin{C}[style=smaller]
            void
            log(log_t *l, level_t ll, char *m) {
              if (ll >= l->level) {
                write(l->fd, m, strlen(m));
              }
            }
          \end{C}
        \end{code}

        \begin{code}[]
          \begin{C}[style=smaller]
            void log_deinit(log_t *l) {
              close(l->fd); // Datei schließen
              free(l);      // Speicher freigeben
            }
          \end{C}
        \end{code}
      \end{column}
    \end{columns}

    \bi
    \ii<2-> Kaum Sprachunterstützung: \codeinline{struct log_t} kann man leicht falsch halten!{
      \bi
      \ii Benutzer kann Invarianten verletzen:\btSetTab\codeinline{L->fd = 23;}
      \ii Use-after-free Bugs: \btUseTab\codeinline{log_deinit(L); log(L, ERROR, "panic");}
      \ii Vergessen das Objekt frei zu geben $\rightarrow$ Memory Leak
      \ei
    }
    \ei
    
  \end{frame}
#+end_src

Um den Lebenszyklus eines Objekts zu verdeutlichen schauen wir uns ein Logger in C an.
Hier werden die drei Phasen besonders deutlich, da nichts vom Lebenszyklus durch Sprachkonstrukte vor unserem Auge versteckt bzw.
abstrahiert wird.

Die ~log_t~-Objekte sind durch eine C-struct Deklaration beschrieben, und sie bestehen aus einem Log-Level (~level_t~) und einem Unix-Dateideskriptor. Beide Unterobjekte sind als Einbettung in der Struktur existentiell abhängig von den ~log_t~-Objekten[fn::Allerdings ist der Dateideskriptor, ohne dass wir das auf Sprachebene sehen, eine Referenz auf ein Objekt im Betriebssystem. Aber das ist Thema von Grundlagen der Betriebssysteme.].

Die Geburt eines ~log_t~-Objekts findet in der ~log_init()~-Funktion statt.
Dort wird der nötige Speicher alloziert und die beiden Felder so initialisiert, dass sie die Invarianten des Objekts erfüllen.
Leider sind diese Invarianten an dieser Stelle nicht gut sichtbar, weswegen ich sie ihnen verrate:
(1) ~level~ is ein valides Loglevel.
(2) ~fd~ is ein offener Dateideskriptor.
Die anderen Funktionen (~log()~, ~log_deinit()~) verlassen sich auf diese Invarianten um nicht jedesmal prüfen zu müssen ob das übergebene Argument wirklich ein valides ~log_t~-Objekt ist.

Die ~log_init()~-Funktion gibt eine Referenz auf das Objekt zurück, womit die ~main()~-Funktion der Besitzer des Objekts wird.
Als Besitzer kann ~main()~ das Objekt verändern, indem es zum Beispiel das Loglevel neu setzt oder das Objekt per Parameterübergabe weitergibt.

Das Ende unseres Objekts findet in ~log_deinit()~ statt:
Dort wird der, bei der Konstruktion, angeforderte Dateideskriptor geschlossen und der angeforderte Speicher zurück gegeben.
Nach diesem Zeitpunkt existiert das Objekt nicht mehr.

Auch sichtbar an diesem Beispiel wird, dass uns C nicht sehr dabei hilft sorgsam mit Objekten umzugehen:
So erlaubt es uns C nicht die Typ-Invarianten zu beschreiben und kann uns daher nicht daran hindern diese zu verletzen.
Auch wäre es möglich den Speicher an dem einst das Objekt gelebt hat, weiter zu verwenden und einen use-after-free Bug zu provozieren, da die Referenz in ~L~ nicht invalidiert wird.
Außerdem wäre es ein leichtes gewesen die Freigabe des Objekts zu vergessen, womit ein Speicherleck (Memory Leak) entstanden wäre.
In anderen Sprachen, Konstrukte und Regeln die es uns schwer oder vollständig unmöglich machen solche Probleme und Bugs zu provozieren.
Alle hängen damit zusammen, wie uns die Sprache erlaubt Objekte zu erzeugen und mit ihnen um zu gehen.


* Geburt von Objekten
:PROPERTIES:
:CUSTOM_ID: 06-birth
:END:
** Speicher-Allokation
:PROPERTIES:
:CUSTOM_ID: 06-allocation
:END:
#+begin_src latex
  \dividerframe{Geburt von Objekten}

  \begin{frame}[fragile]{Allokation: Wo kommt der Speicherplatz her?}
    \hspace{-1em}\textbf{Meistens} residieren Objekte in einem zusammenhängenden Speicherbereich
    \medskip
    \begin{center}
      \texttt{allocate(bytes\_t N)} $\longrightarrow$ Startadresse des zukünfigen Objekts
    \end{center}

    \bi
    \ii<2-> \structure{Statische Allokation} durch Übersetzer: Lebenszeit = Programlaufzeit {
      \bi
      \ii Absolute Adresse des Objekts steht vor der Laufzeit fest
      \ii Bsp.: globale Variablen, konstante Literale, Maschinencode einer Funktion
      \ii 2 statische Objekte: \codeinline{char *global = "foobar";} 
      \ei
    }\medskip
    \ii<3-> \structure{Stack Allokation}: Objekte können auf den Aufrufstapel{
      \bi
      \ii Allokation als Einbettung des Call-Frames einer Funktionsinstanz.
      \ii Lebenszeit des Objekts ist $\le$ Lebenszeit des Call-Frames.
      \ii Beispiele: Argumente, lokale Variablen, \codeinline{alloca()}
      \ei
    }\medskip
    \ii<4-> \structure{Heap Allokation}: Laufzeitsystem betreibt separaten Speicherpool {
      \bi
      \ii Lebenszeit unabhängig von Aufrufhierarchie, beliebige Allokations-Zeitpunkte
      \ii Benötigt komplexeres Speichermanagement und ist daher teurer.
      \ii Speicher muss irgendwann freigeben werden (manuell oder garbage collection)
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{Allokationen im größeren Kontext}
    \begin{center}
      \includegraphics[width=0.8\textwidth]{fig/06-process-mem}
    \end{center}

    \bi
    \ii Im klassisches UNIX-Modell wachsen Stack und Heap aufeinander zu.{
      \bi
      \ii Das ELF beschreibt die statisch allokierten Objekte (.text, .data, .bss)
      \ii Realität ist komplexer: Mehrere Stacks/Heaps, Addressspace-Randomization
      \smallskip
      \ii[$\rightarrow$] Genauere Betrachtung in Grundlagen der Betriebssysteme (GBS)
      \ei
    }\medskip
    \ii Für Programmiersprachen und Übersetzer nehmen wir an, dass... {
      \bi
      \ii Wir globale Objekte im Assembler anlegen können.
      \ii Der Prozess einen Stack hat und wir den Stackpointer kontrollieren.
      \ii Das Laufzeitsystem \codebox{void *malloc(size\_t)}/\codebox{free(void*)} bereitstellt.
      \ei
    }
    \ei
  \end{frame}
#+end_src
** Initialisierung
:PROPERTIES:
:CUSTOM_ID: 06-init
:END:
#+begin_src latex
  \begin{frame}{Initialisierung und Konstruktoren}
    \begin{btBlock}{}
      Wie wird aus dem allokierten, noch blanken, Speicherbereich ein Objekt?    
    \end{btBlock}

    \bi
    \ii \structure{Sprachabhängige} Initialisierung etabliert Meta-Informationen\\[1ex]
        \small\emph{Was macht ein Stück Speicher für meine Sprache zu einem Objekt?}\\[1ex]
        {
          \bi
          \ii Einige Sprachfeatures  erfordern zusätzliche Informationen an jedem Objekt.
          \ii Zum Beispiel  \btSetTab -- Dynamische Typinformationen in Form eines \structure{Typ-Tags}.\\
                            \btUseTab -- Registrierung des Objekts am Garbage Collector (später mehr)
          \ei
        }\medskip
    \ii<2-> \structure{Benutzerdefinierte} Initialisierung durch \textbf{Konstruktoren}\\[1ex]{
      \small\emph{Was möchte der Benutzer bei der Geburt eines Objekts tun?}\\[1ex]
      \bi
      \ii Initiale Belegungen der Objekt-Attribute
      \ii Parametrisierte Konstruktion
      \ii Intention des Benutzers: Etablierung der \textbf{semantischen Invarianten}
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[fragile]{Sprachregeln für Konstruktoren }
    \begin{columns}
      \begin{column}{0.49\textwidth}
        \begin{code}[tag=C++]
          \begin{CPP}
            class Base {
              public: 
                Base(int x)    { ... }
                Base(string x) { ... }
            };
          \end{CPP}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \begin{code}[tag=Java]
          \begin{java}
            class Base {
              public Base(int x)    { ... }
              public Base(String x) { ... }
            };
          
          \end{java}
        \end{code}
      \end{column}
    \end{columns}

    \bi
    \ii \structure{Definition} von eigenen Konstruktoren {
      \bi
      \ii Definieren wir keine eigenen, werden Default-Konstruktoren erzeugt
      \ii Konstruktoren haben Parameter und können Überladen werden
      \ii Sehen aus wie Funktionen, haben aber keinen Rückgabewert
      \ei
    }\medskip
  
    \ii \structure{Aufruf} von Konstruktoren {
      \bi
      \ii Konstruktoren werden bei Objekterstellung \alert{automatisch} aufgerufen.
      \ii Bei Vererbung: Eltern-Konstruktoren vor Kind-Konstruktoren\\
          $\Rightarrow$ Kind-Konstruktoren finden ein valides Eltern-Objekt vor.
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[fragile]{Konstruktoren in Aktion: Java}
    \begin{columns}
      \begin{column}{0.4\textwidth}
        \begin{code}[]
          \tikzset{every dn/.style={visible on=<2->}}
          \lstinputlisting[style=java,style=smaller]{lst/06-counter.java}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.59\textwidth}
        \bii
        \ii Java {\bi
          \ii Konstruktoren heißen wie die Klasse.
          \ii Nicht-initialisierte Attribute werden automatisch 0 oder \texttt{null}
          \ei
        }
        \medskip
        \ii<2-> Ablauf für \codeinline[style=java,style=smaller]{new Derived("123")}{
          \bi
          \ii[{\dn[font=\tiny]{1}}]\footnotesize Aufruf anderer Konstruktoren mittels \codeinline[style=java,style=smaller]{this()}
          \ii[{\dn[font=\tiny]{2}}]\footnotesize Elternkonstruktor mittels \codeinline[style=java,style=smaller]{super()}
          \ii[{\dn[font=\tiny]{3}}]\footnotesize Konstruktor setzt \codeinline[style=java,style=smaller]{final}-Attribut
          \ii[{\dn[font=\tiny]{4}}]\footnotesize Autom. Nullung durch \codeinline[style=smaller]{Object}-Konstruktor

          \ei
        }
        \medskip
        \ii<3-> { Wie sähe eine manuelle Konstruktion aus?
          \begin{minipage}{0.9\linewidth}
            \begin{code}[tag=Pseudo-C]
              \begin{C}[style=smaller]
                // Allokation
                Derived *this = malloc(sizeof(Derived));

                // Sprachspezifisches Init
                memset(this, 0, sizeof(Derived));
                this->vtable = Dervied_vtable;

                // Konstruktor (inlined)
                int tmp = parseInt("123")
                this->start = 3+tmp;
              \end{C}
            \end{code}
          \end{minipage}
        }
        \eii
    \end{column}
    \end{columns}
  \end{frame}


#+end_src
#+begin_src latex
  \begin{frame}[fragile]{Was sollte \textbf{mein} Konstruktor leisten?}
    \begin{btBlock}{\small Sinnvolle Konvention: Konstruktoren stellen semantische Invarianten her}\small
      -- Entwickler trifft \textbf{immerwährende Annahmen} über den Zustand eines Objekts. \\
      -- \textbf{Jeder} Konstruktor hinterlässt ein Objekt, dass die Annahmen einhält.\\
      -- Jede weitere Operation auf dem Objekt muss diese Annahmen \textbf{erhalten}.
    \end{btBlock}

    \bi
    \ii<2-> Beispiel: Bounded Pointer zeigt nur auf die Elemente eines Arrays\\[0.5ex] {
      \begin{columns}
        \begin{column}{0.44\textwidth}
          \begin{code}[]
            \begin{CPP}[style=smaller]
              class bounded_ptr {
                int *data;
                unsigned length;
                int *ptr;
              
                bounded_ptr(unsigned len) {
                  data   = malloc(len);
                  length = len;
                  ptr    = &data[0];
                }

                void set(int val) {
                  ,*ptr = val;
                }
                ...
              };
            \end{CPP}
          \end{code}
        \end{column}\hfill
        \begin{column}{0.55\textwidth}
          \bi
          \ii Invarianten für bounded\_ptr {
            \btUseExtraItemSep
            \bi
            \ii \texttt{data} zeigt auf ein valides Integer-Array\\[1ex]
            \ii \texttt{length} gibt Länge dieses Arrays an\\[1ex]
            \ii \texttt{ptr} ist die Adresse eines Array-Elements
            \ei
          }
          \ii<3-> \textbf{\advantage{Bonussternchen}}, falls der Benutzer nicht in der Lage ist die Invarianten zu verletzen.
          \ei
        \end{column}
      \end{columns}


    }
    \ei
  \end{frame}
#+end_src
* Leben von Objekten
:PROPERTIES:
:CUSTOM_ID: 06-life
:END:
** Werte- und Referenzmodell
:PROPERTIES:
:CUSTOM_ID: 06-value-reference-model
:END:
#+begin_src latex
  \dividerframe{Leben von Objekten}
  \begin{frame}[t]{Wie werden Objekte abgelegt und weitergereicht?}
    \textbf{Erinnerung (binding time):} Ein Objekt wird an einen Namen gebunden.

    \begin{center}
      \codebox{var\_foo = new object();}\hspace{1cm}\codebox{foo(var\_foo);}
    \end{center}

    \hspace{-1em}Mittels gebundener Namen können wir Objekte \alert{ansprechen und weitergeben}.\\[0.5ex]
    \uncover<2->{
      \hspace{-1em}\textbf{Aber:} Ist der Wert einer Variable das Objekt oder eine Objekt-Referenz?
    }

    \begin{columns}<3->
      \begin{column}{0.49\textwidth}
        \begin{center}
          \includegraphics[page=1,height=2cm]{fig/06-val-refs}
        \end{center}
        \STRUCTURE{Wertemodell für Variablen}
        \bii
        \ii Objekte \enquote{leben} in Variablen
        \ii Zuweisung erzeugt eine \textbf{Kopie}
        \ii Referenzen sind separate Objekte
        \ii[$\Rightarrow$] C, C++, Rust
        \eii
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \begin{center}
          \includegraphics[page=2,height=2cm]{fig/06-val-refs}
        \end{center}
        \STRUCTURE{Referenzmodell für Variablen}
        \bii
        \ii Variable speichert nur Referenz
        \ii Zuweisung erzeugt weitere Referenz
        \ii Keine separaten Referenzobjekte
        \ii[$\Rightarrow$] Java (mostly), Python, Ruby
        \eii
      \end{column}
    \end{columns}

  \end{frame}

  \begin{frame}[fragile]{Wertemodell: Vor- und Nachteile}
    \begin{columns}
      \begin{column}{0.45\textwidth}
        \begin{code}[tag=C++11]
          \begin{CPP}
            class foo_t { int x; };
            ...
            foo_t A { 23 };
            foo_t B = A;
            A.x = 42; // B.x == 23
          \end{CPP}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.53\textwidth}
        \bii
        \ii A und B enthalten \alert{verschiedene} Objekte
        \ii Initialisierung von B durch Kopie
        \ii Objekte-Inhalte/Speicher werden kopiert
        \eii
      \end{column}
    \end{columns}
    \medskip

    \bi
    \iiad<2-> Das Wertemodell is \advantage{flexibler} und kann \advantage{effizienter} sein. {
      \bi
      \ii Indirektion nur auf Nachfrage; kleine Objekte lassen sich effizient kopieren.
      \ii Referenzen sind explizit im Code sichtbar (als Zeiger-Typ)
      \ii Objekte in lokalen Variablen können am Stack alloziert werden.
      \ei
    }\medskip
    \iida<3-> Das Wertemodell ist \alert{komplexer} und \alert{schwieriger zu beherrschen}. {
      \bi
      \ii Referenzen machen das Programmiermodell komplexer.
      \ii Häufiges Kopieren \emph{kann} unsichtbaren Overhead erzeugen.
      \ii Initialisierung durch Kopieren (oder Verschieben) ist eigentlich ein Sonderfall\\
      $\Rightarrow$ C++ kennt 3 Sorten von Konstruktoren: Init-, Copy-, Move-Konstruktoren
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[fragile]{Referenzmodell: Vor- und Nachteile}
      \begin{columns}
      \begin{column}{0.45\textwidth}
        \begin{code}[tag=Java]
          \begin{java}
            class foo { public int x; }
            ...
            foo A = new foo();
            A.x   = 23;
            foo B = A;
            // B.x == 23
          \end{java}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.53\textwidth}
        \bii
        \ii Beide referenzieren das \alert{gleiche Objekt}
        \ii Automatisch Dereferenzierung
        \ii Objekterzeugung nur mittels \codeinline[style=java,style=smaller]{new T()}
        \eii
      \end{column}
    \end{columns}
    \medskip

    \bi
    \iiad<2-> Im Referenzmodell sind Variablen und Objekte \advantage{orthogonal}. {
      \bi
      \ii Objekte existieren \textbf{immer} unabhängig von Variablen und Funktionsaufrufen
      \ii Weitergabe quer zur Aufrufhierarchie ist trivial.
      \ii Keine Probleme mit Kind-Klassen die mehr Speicher brauchen.\\
          Problematisch in C++: \codeinline[style=CPP,style=smaller]{Base func() { Derived d; return d; }}
      \ei
    }\medskip
    \iida<3-> Im Referenzmodell tragen wir immer \alert{die Kosten} der Indirektion {
      \bi
      \ii Ohne Optimierungen müssen alle Objekte am Heap alloziert werden.
      \ii Todeszeitpunkt von Objekten ist unklar.
      \ii Primitive Typen: Jeder Integer hinter einem Pointer? \\
          Java: Wertemodell für Zahlen, außer wenn nicht (Auto(un-)boxing).
      \ei
    }
    \ei
  \end{frame}

#+end_src
** Objektzugriff auf Objektdaten
:PROPERTIES:
:CUSTOM_ID: 06-access
:END:
#+begin_src latex
  \begin{frame}{Zugriff auf Objekte}
    \begin{center}
      \includegraphics[page=1]{fig/06-access}
    \end{center}

    \bi
    \ii Welche \structure{Arten von Zugriffen} gibt es? {
      \bi
      \ii Daten aus dem einem Objekt auslesen oder verändern.
      \ii Direkter Speicherzugriff oder gefiltert über getter/setter.
      \ii Ableitung weiterer Referenzen (z.B. Subobjekte: \codebox{\&obj.x}). \hfill \ALERT<1>{Gefährlich!}
      \ei
    }\smallskip
    \ii Wer ist der \structure{Benutzer} eines Objekts? {
      \bi
      \ii Eigentlich: Das laufende Programm (aktiv) greift auf ein Objekt (passiv) zu.
      \ii Nützliche Präzisierungen: Zugreifende Funktion, zugreifender Thread
      \ei
    }\smallskip
    \ii Welche \structure{Berechtigungen} hat der Benutzer? {
      \bi
      \ii Referenzen sind Befähigungen (Capabilities) ein Objekt zu nutzen.
      \ii Nicht jede Referenz auf ein Objekt muss gleich mächtig sein.
      \ei
    }
    \ei

    \uncover<2->{
      \begin{center}
        \vfill{}
        \OrangeBox{
          \textbf{Wer} greift \textbf{Wie} mit \textbf{welchem Recht} zu?        
        }
    \end{center}
    }

  \end{frame}

  \begin{frame}[fragile]{Gefilterter Zugriff über Getter und Setter}
    \begin{columns}
      \begin{column}{0.44\textwidth}
        \begin{btBlock}{Direkter Speicherzugriff}
          \centering
          \texttt{obj.length = -1;}\\
          User kann Invarianten verletzen
        \end{btBlock}      
      \end{column}
      \begin{column}{0.10\textwidth}
        \centering
        \Huge$\leftrightarrow$
      \end{column}
      \begin{column}{0.44\textwidth}
        \begin{btBlock}{Nur Methodenzugriff}
          \centering \texttt{obj.setLength(-1);}\\
          Boilerplate, reine Konvention
        \end{btBlock}      
      \end{column}
    \end{columns}

    \pause\bigskip

    \btAnimation{center,padding,2:<1->}{fig/06-access}
    \bi
    \ii Einige Sprachen erlauben den gefilterten Zugriff auf einzelne Attribute {
      \begin{columns}
        \begin{column}{0.55\textwidth}
          \bi
          \ii Verwendung sieht aus wie direkter Zugriff
          \ii \texttt{set()} beim Schreiben eines Attributs\\[-0.5ex]
          \ii \texttt{get()} zum Lesen eines Attributs
          \ii Kann \textbf{nachträglich} eingefügt werden, ohne die Benutzer zu ändern!
          \ei
        \end{column}\hfill
        \begin{column}{0.45\textwidth}
          \begin{code}[tag=C\#]
            \begin{sharpc}
              public class Student {
                private string name;
              
                public string Name {
                  get { return name; }
                  set { name = value; }
                }
              }
            \end{sharpc}
          \end{code}
        \end{column}
      \end{columns}

    }
    \ei
  \end{frame}

  \begin{frame}{Benutzer-abhängige Zugriffseinschränkungen}
    \btAnimation{center,padding,3:<1->}{fig/06-access}
    \medskip
    \bi
    \ii \textbf{Ziel:} Benutzergruppen mit unterschiedlichen Zugriffsrechten {
      \bi
      \ii Identifikation der unterschiedlichen Gruppen \hfill(Wer greift zu?)
      \ii Einteilung anhand der zugreifenden Instruktionadresse
      \ii[$\Rightarrow$] Wir können den Code mit unbeschränktem Zugriff kontrollieren.
      \ei
    }\medskip
    \ii<2-> \textbf{Implementierung:} Einschränkung der Sichtbarkeit des Namens {
      \bi
      \ii Wenn der externe Nutzer einen Namen nicht sieht, kann er nicht zugreifen.
      \ii \textbf{Aber:} Gibt ein interner Nutzer eine Referenz auf ein privates Attribut heraus, bricht die Abstraktion. \textbf{Referenzen geben Kontrolle heraus!}
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{Referenzen-abhängige Zugriffseinschränkungen}
    \btAnimation{center,padding,4:<1->}{fig/06-access}
    \medskip

    \bi
    \ii \textbf{Ziel:} Einschränkbare Referenzen erlauben kontrolliertes Sharing {
      \bi
      \ii Über eingeschränkte Referenzen dürfen nicht alle Zugriffe erfolgen
      \ii Referenzen dürfen nur weiter eingeschränkt und nicht geweitet werden.
      \ii Beispiel: Ableitung einer read-only Referenz aus einer read-write Referenz
      \ei
    }\medskip
    \ii<2-> \textbf{Implementierung (const):}  Erweiterung des Typsystems{
      \bi
      \ii Weiterer Zeiger-Typkonstruktor:    \typeinline{const\_pointer(T)}\\[.5ex]
      \ii Implizite Typumwandlung zur read-only Referenz\\[.5ex]
      \ii Asymmetrische Typ-Kompatibilität:  \typeinline{const\_pointer(T)} $\ll$ \typeinline{pointer(T)}\\[.5ex]
      \ei
    }
    \ii<3-> Standardverhalten in verschiedenen Sprachen{
      \bi
      \ii \structure{C++}:  \hspace{1ex}\btSetTab Read-only ist die Ausnahme \hfill(\texttt{T*, const T\*}).
      \ii \structure{Rust}: \btUseTab Read-only ist die Regel \hfill(\texttt{\&T, \&mut T})
      \ii \structure{Java}: \btUseTab Alle Referenzen dürfen alles. 
      \ei
    }
    \ei
  \end{frame}

#+end_src
** Fallstudie: Immutable Objects
:PROPERTIES:
:CUSTOM_ID: 06-immutable-objects
:END:
#+begin_src latex
  \begin{frame}[fragile]{Fallstudie: Unveränderliche Objekte}
    \begin{btBlock}{Unveränderliche Obejekte (immutable objects)}
      Gibt es für ein Objekt, im gesamten Programm, keine read-write Referenzen, so ist sein Inhalt unveränderlich.
    \end{btBlock}
  
    \bi
    \ii<2-> Immutability für ein Objekt bringt spannende Eigenschaften {
      \bi
      \ii Thread-Safety: Keine Probleme mit konkurrierenden Schreibzugriffen
      \ii Werte- und Referenzmodell werden equivalent.
      \ii Deduplikation von Objekten ist möglich (=interning).
      \ii \textbf{Aber:} Verändernde Operation müssen das Objekt verändert kopieren
      \ei
    }\medskip
    \ii<3-> Manche Objekte sind natürlichweise Immutable {
      \bi
      \ii \structure{Zahlen}: Die Zahl 5 kann nicht so verändert werden, dass alle Fünfen im gesamten Programm plötzlich Achten sind.
      \smallskip
      \ii \structure{String-Literale}: Der Übersetzer legt literale Zeichenketten (\codeinline[style=C,style=smaller]{"Hello"}) nur einmal in die Binärdatei.
      \ei
    }
    \ei
  \end{frame}
#+end_src

https://medium.com/@bdov_/https-medium-com-bdov-python-objects-part-iii-string-interning-625d3c7319de
** Ownership
:PROPERTIES:
:CUSTOM_ID: 06-ownership
:END:
#+begin_src latex
  \begin{frame}[fragile]{Ownership für Objekte}
    \begin{btBlock}[type=alert]{Wem gehört ein dieses Objekt?}
        Viele Bugs und Probleme  rühren daher, dass man sich keine Gedanken darüber gemacht hat, wer Verantwortung für ein Objekt hat.
    \end{btBlock}

    \bi
    \ii \textbf{Denkanweisung}: Wer ist der Besitzer und wo wird Besitz übertragen?{
      \bi
      \ii Besitzer kann ein Thread, eine Funktion oder ein anderes Objekt sein.
      \ii Der (letzte) Besitzer ist verantwortlich für die Freigabe des Objekts.
      \ii \alert{Geteilter Besitz} von Objekten erfordert immer \textbf{erhöhte Aufmerksamkeit}.
      \ei
    }
    \ei

    \begin{columns}<2->
      \begin{column}{0.49\textwidth}
        \begin{code}[]
          \begin{CPP}
            struct Cache {
              obj_t* obj;
              int set(obj_t* o) {
                this->obj = o;
              }
            };
            Cache cc; cc.set(obj);
            delete obj;
          \end{CPP}
        \end{code}
        \bii
        \ii \texttt{cc} hält Referenz auf anderes Objekt
        \ii \structure{dangling-reference problem}
        \eii
      \end{column}\hfill
      \begin{column}<3->{0.49\textwidth}
        \structure{Besitz ist Schwierig!}
        \bii
        \ii Besitz ist oft nur intentional!
        \ii Referenz impliziert keinen Besitz!\\[.5ex]
        \ii Modernste Sprachenentwicklungen:{%
          \bi
          \ii Hilfestellungen: \codeinline[style=CPP,style=smaller]{std::unique_ptr<T>}
          \ii Übersetzer prüft Besitzer statisch: Rust's Borrowchecker
          \ei
        }
        \eii
      \end{column}
    \end{columns}


  
  \end{frame}
#+end_src
* Tod von Objekten
:PROPERTIES:
:CUSTOM_ID: 06-death
:END:
#+begin_src latex
  \dividerframe{Tod von Objekten}

  \begin{frame}[fragile]{Wann endet die Lebenszeit eines Objekts?}
    \begin{btBlock}{Ende der Lebenszeit}
      Wenn ein Objekt, oder sein Seiteneffekt, nicht mehr benötigt wird, endet seine Lebenszeit und wir können es freigeben.
    \end{btBlock}

    \bi
    \ii Indikatoren für das Ende der Lebenszeit {
      \bi
      \ii Keine zukünftigen Zugriffe auf das Objekt \hfill Seiteneffekte?
      \ii Letzter Besitzanspruch erlischt         \hfill $\Rightarrow$ Notwendig
      \ii Letzte Referenz auf das Objekt wird ungültig \hfill $\Rightarrow$ Hinreichend
      \ei
    }
    \ii<2-> \structure{Explizite Freigabe} erfordert Disziplin und provoziert Speicherlecks\\[1ex]{
      \hfill \codeinline[style=C,style=smaller]{log_deinit(log);}
      \hfill \codeinline[style=CPP,style=smaller]{delete obj;} \small (C++)
      \hfill \mbox{}
    }
    \ei
    \medskip

    \begin{columns}<3->
      \begin{column}{0.49\textwidth}
        \structure{Referenzzählung}
        \bii
        \ii Kontinuierliches Zählen aller Besitzer
        \ii Exakter Todes-Zeitpunkt
        \ii Probleme mit Referenz-Zyklen
        \eii
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \structure{Garbage Collector}
        \bii
        \ii Finden der unreferenzierten Objekte
        \ii Entkopplung von Tod und Freigabe
        \ii Kosten treten in Bursts auf
        \eii
      \end{column}
    \end{columns}
  \end{frame}

  #+end_src
** Referenzzählung
:PROPERTIES:
:CUSTOM_ID: 06-refcount
:END:
#+begin_src latex
  \begin{frame}[fragile]{Referenzzählung}
  \begin{columns}
    \begin{column}{0.49\textwidth}
        \begin{code}[tag=C++]
          \begin{CPP}[style=smaller]
            class A {
              unsigned users;
              A()            { users=1; }
              void claim()   { users++; }
              void release() {
                if (--users == 0) {
                  delete this;
                }
              }
            };
          \end{CPP}
        \end{code}
    \end{column}\hfill
    \begin{column}{0.49\textwidth}
      \btAnimation[width=0.5\textwidth]{center,1:<2>,2:<3->}{fig/06-ref-cycle}
    \end{column}
  \end{columns}


    \bi
    \ii Besitzer zeigen an, wenn sie eine Referenz weiter- bzw. aufgeben {
      \bi
      \ii Reihenfolge von \texttt{claim()} und \texttt{release()} sind kritisch
      \ii Fällt der Zähler auf 0, wird das Objekt automatisch freigegeben.
      \ii<2-> Referenzieren sich Objekte zyklisch, wird \ALERT{niemals} freigegeben.
      \ei
    }\medskip
    \ii<4-> \structure{Smart Pointer} ermöglichen eine automatisierte Referenzzählung{
      \begin{columns}
        \hfill
        \begin{column}{0.6\textwidth}
        \begin{code}[]
          \begin{CPP}[style=smaller]
            { // Typausdruck: shared_ptr(int) vs ptr(int);
              std::shared_ptr<int> A(new int(23));
              (*A)++;
              {
                std::shared_ptr<int> B = A;
                std::cout << (*B); // -> 24;
              } // <- keine Freigabe
            } // <- Freigabe des ints
          \end{CPP}
        \end{code}
      \end{column}\hfill
    \end{columns}
    }
    \ei
  \end{frame}
  #+end_src

** Automatic Garbage Collection
:PROPERTIES:
:CUSTOM_ID: 06-garbage-collection
:END:
#+begin_src latex
  \begin{frame}{Garbage Collection}
    \begin{btBlock}{\textbf{Kernidee}: Nicht-referenzierte Objekte können freigegeben werden}\small
      \structure{Schritt 1}\quad\btSetTab Finde alle Objekte, die transitiv von einem \structure{root set} erreichbar sind.\\
      \structure{Schritt 2} \btUseTab Gebe alle nicht-erreichbaren Objekte frei.
    \end{btBlock}
    \medskip
    \bi
    \ii<2-> Erreichbarkeitsanalyse im Referenzgraphen {
      \bi
      \ii Jedes existierende Objekt ist ein Knoten im Referenzgraphen
      \ii Jede Referenz/Zeiger ist eine gerichtete Kante
      \ii Root Set: globale/lokale Variablen, Registerinhalte
      \ei
    }\medskip
    \ii<3-> \structure{Vorbedingungen und Probleme}  \hfill \structure{Ansatz}{
      \bi
      \ii Kenntnis alle existierender Objekte       \hfill Objektliste
      \ii Konsistente Sicht auf den Referenzgraphen \hfill stop-the-world
      \ii Erkennung aller ausgehenden Referenzen    \hfill Typsicherheit
      \ii Iteration über alle Objekte ist teuer     \hfill Partitionierte Objektmenge
      \ei
      \smallskip
        $\Rightarrow$ GC hauptsächlich in gemanagten Sprachen, wie Java oder Python. 
    }
    \ei
  \end{frame}

  \begin{frame}{Mark-and-Sweep Garbage Collector}
    \begin{btBlock}{}
    Der \structure{Mark-and-Sweep} Garbage Collector hält die Welt an, markiert alle erreichbaren Objekte, und gibt die anderen frei.
  \end{btBlock}

   \btAnimation[width=\textwidth]{center,range=1-13:<1->}{fig/06-mark-and-sweep}
  \end{frame}

  \begin{frame}[fragile]{Fallstudie: Der CPython3 Garbage Collector}
    \bi
    \ii Leistungsfähiger GC für eine Sprache bei der alles ein Objekt ist {
      \bi
      \ii Kombination aus Referenzzählung und Mark-and-Sweep GC
      \ii 3 Generationen für unterschiedlich alte Objekte
      \ii Zugriff aus der Python-VM über \texttt{gc}-Module
      \ei
    }
    \ei
    \begin{columns}[t]
      \begin{column}{0.49\textwidth}
        \begin{code}[]
          \lstinputlisting[style=py]{lst/06-garbage.py}          
        \end{code}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \begin{code}[]
          \begin{C}
            // +1 Für den Wurzelnamensraum
            // +1 für temp-argument
            Refcount: 2

            // Eingehende und Ausgehende Kanten
            x -> *: [<object at 0x1000>]
            ,* ->: x [<namespace: root>]

            // Alle Objekte
            Objects: 5823
          \end{C}
        \end{code}
      \end{column}
    \end{columns}
  
  \end{frame}
#+end_src

** Deinitialisierung
:PROPERTIES:
:CUSTOM_ID: 06-deinit
:END:
#+begin_src latex
  \begin{frame}[fragile]{Destruktoren}
    \begin{columns}
      \begin{column}{0.49\textwidth}
        \begin{code}[]
          \begin{CPP}[style=smaller]
            class A { ...
              A() {
                global.register(this);
                this->mem = malloc(3);
              }
            \end{CPP}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \begin{code}[]
          \begin{CPP}[style=smaller]
            class A { ...
              ~A() {
                free(mem);
                global->unregister(this);
              }
          \end{CPP}
        \end{code}
      \end{column}
    \end{columns}
    \medskip
    \bi
    \ii Destruktoren sollen die Konstruktor-Seiteneffekte rückgängig machen{
      \bi
      \ii Seiteneffekte: Registrierung bei anderen Objekten, Ressourcennachforderung
      \ii Löschung oder Invalidierung aller Referenzen auf das Objekt
      \ii Destruktoren habe keine Parameter
      \ei
    }\medskip
    \ii<2-> Destruktoren und Vererbung: Umgekehrte Konstruktionsreihenfolge  {
      \bi
      \ii Destruktor für Derived, muss ein gültiges Derived-Objekt vorfinden
      \ii \texttt{~Derived()} muss vor \texttt{~Base()} aufgerufen werden.
      \ei
    }\medskip
    \ii<3-> Schwierige Semantik für Sprachen mit Garbage Collection {
      \bi
      \ii GC: Todeszeitpunkt und Zeitpunkt der Freigabe sind entkoppelt
      \ii GC müsste den Destruktor aufrufen, dies geschieht aber \$IRGENDWANN\\[.5ex]
      \ii[$\Rightarrow$] Manuelle Deinitialisierung und \codeinline[style=java,style=smaller]{void finalize()}
      \ei
    }
    \ei
  \end{frame}
#+end_src

#+begin_src latex
  \begin{frame}[fragile]{Fallstudie: Resource Aquisition is Initialization (RAII)}
    \bi
    \ii C++: Kopplung von Scopes und der Lebenszeit lokaler Variablen{
      \bi
      \ii \structure{Wertemodell}: Lebenszeit von Variable und enthaltenem Objekt sind gleich
      \ii Definition einer Variable:  \hspace{3em}\btSetTab $\Rightarrow$ Konstruktor wird aufgerufen
      \ii Ende des umgebenden Scopes: \btUseTab $\Rightarrow$ Destruktor wird aufgerufen
      \ei
    }
    \ei

    \begin{columns}<2->
      \begin{column}{0.49\textwidth}
        \begin{code}[tag=C++]
          \begin{CPP}
            class log {
              level_t level;
              int fd;
              public:
                log() : level(DEBUG) {
                  fd = open("/dev/stderr");
                }
                ...
                ~log(){
                  close(fd);
                }
             };

             void foo() {
               log L; // Constructor
               L.log(...)
             } // implicit: Destructor
           \end{CPP}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \bii
        \ii Destruktor wird \advantage{immer} aufgerufen!{
          \bi
          \ii Ausführung erreicht Scope-Ende
          \ii Vorzeitiges \codeinline[style=C,style=smaller]{return}
          \ii Exceptions (direkt und indirekt)
          \ei
        }
        \ii[$\Rightarrow$] \advantage{Garantierte} Ressourcen-Freigabe\
        \bigskip
        \ii<3-> Anwendbar für alle Resourcentypen\\[1ex]{
          \begin{code}[]
            \begin{CPP}[style=smaller]
              mutex lock; // Das Lock-Objekt

              void foo() {
                lock_guard<mutex> X(lock);

                // Lock wird immer freigegeben
              }
            \end{CPP}
          \end{code}
          }
        \eii
      \end{column}
    \end{columns}

    \begin{overlaybox}[inner sep=2em,fill=badbee!30]<4->
      \textbf{Bjarne Stroustrup (Designer von C++):}\\[1ex]
      \enquote{The RAII technique [...] is a clumsy name for a \textbf{central concept} [that] happens to be \textbf{necessary} for exception handling. [...] the \textbf{main tool} for resource management is constructors and destructors.}\\[1ex]

      \hfill\scriptsize Interview mit Bill Venners, 2003
    \end{overlaybox}

  \end{frame}
#+end_src

* Zusammenfassung
#+begin_src latex
  \begin{frame}{Zusammenfassung}
    \bi
    \ii Objekte sind ein \STRUCTURE{existentieller Verbund} von Informationen {
      \bi
      \ii Objekte transportieren Informationen (typsicher) im Programmablauf
      \ii Referenz- und Wertemodell für Variablen
      \ei
    }\medskip
    \ii \STRUCTURE{Geburt}: In einem Speicherbereich entsteht ein Objekt {
      \bi
      \ii \structure{Allokation} des nötigen Speichers auf dem Stack, im Heap, oder statisch.
      \ii \structure{Konstruktoren} setzen Felder, fordern Ressourcen an und etablieren Invarianten
      \ei
    }\medskip
    \ii \STRUCTURE{Leben}: Kontrollierter und gefilter Zugriff auf die enthaltenen Daten {
      \bi
      \ii \structure{Wer} greift \structure{Wie}, mit welchem \structure{Recht}, auf das Objekt zu?
      \ii Der \structure{Besitz} von Objekten verpflichtet zu ihrer Pflege
      \ei
    }\medskip
    \ii \STRUCTURE{Tod}: Objekt verliert den letzten \structure{Besitzer} oder die letzte \structure{Referenz} {
      \bi
      \ii Manuelles Management, Referenzzähler oder automatische Garbage Collection
      \ii Destruktoren geben angeforderte Resourcen wieder frei
      \ei
    }
    \ei
  \end{frame}
#+end_src
