#+TITLE: Programmiersprachen und Übersetzer
#+SUBTITLE: 06 - Objekte
#+SETUPFILE: setup.org
#+INCLUDE: export-prologue.org
#+PROPERTY: header-args:latex :tangle yes :noweb yes :tangle-macros yes :tangle-prologue topic :tangle-epilogue endtopic :exports none

#+NAME: topic
#+BEGIN_SRC latex :tangle no
\psuSectionStart{{{{property(ITEM)}}}}{{{{n(block)}}}}
#+END_SRC

#+NAME: endtopic
#+BEGIN_SRC latex :tangle no
\psuSectionStop{{{{property(ITEM)}}}}{{{{n(block,-)}}}}
#+END_SRC

* Gedanken zu dieser Vorlesung                                     :noexport:
Stoffsammlung:
  - Lebenszyklus eines Objekts, Lebenszeit
  - Geburt und Initialisierung
    - Speicherallokation
    - Initialisierung 
    - Referenz vs. Value Model
  - Während der Lebenszeit
    - Getter und Setter
    - Problem: Paralleler Zugriff
    - Ownership of an Object
    - Read-Only Access
    - Immutable Objects
  - Garbage Collection  und Tod
    - Deinitialisierung
    - Reference Counting
    - Automatic Garbage Collection

Was soll der Studierende aus dieser Vorlesung mitnehmen?
  - Welche Besonderheiten kann eine Sprache bzgl. ihrer Objekte haben? [Effektiv]
  - Was bedeutet es ein Objekt zu kopieren?                            [Effizient]
* Was ist ein "Objekt"?
:PROPERTIES:
:CUSTOM_ID: 06-einleitung
:END:

#+begin_src latex
  \subtitle{{{{subtitle()}}}}
  \begin{frame}
    \maketitle
  \end{frame}

  \begin{frame}{Einordnung in die Vorlesung: Objekte}
    \begin{center}
      \includegraphics[page=13,width=0.6\linewidth]{fig/01-overview-small}
    \end{center}
    \bi
    \ii Objekte sind die datentragenden Elemente in einer Laufzeitumgebung {
      \bi
      \ii Die virtuelle Sprach-Maschine definiert \alert{Geburt, Leben und Tod} von Objekten.
      \ii Effiziente Programme gehen \advantage{sparsam und sorgsam} mit Objekten um.
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{Was ist ein Objekt?}
    \begin{center}
      \includegraphics[width=0.75\textwidth]{fig/06-object-types}
    \end{center}
    \bi
    \ii \textbf{Erinnerung 1. Vorlesung}: Maschinenmodell der virtuellen Maschine:{
      \bi
      \ii \structure{Speicher/Objekte}: Wie kann man Informationen ablegen und wieder abrufen?
      \ii \structure{Befehle/Operationen}: Wie kann man Informationen miteinander kombinieren?
      \ei
    }
    \ei
    \pause
    \begin{btBlock}{Definition: Objekt}
      Ein Objekt ist ein logisch-zusammengehöriger Verbund von Informationen, dessen \emph{Lebenszeit} kleiner oder gleich der Programmlaufzeit ist.
    \end{btBlock}
    \pause
    \hspace{-1em}\textbf{Wichtig:} \btSetTab (1) Variablen $\ne$ Objekte! Variablen können Objekte beinhalten.\\
    \btUseTab (2) Diese Definition umfasst auch primitive Objekte, wie Zahlen!
  \end{frame}

  \begin{frame}{Lebenszyklus eines Objekts}
    \hspace{-1em}\textbf{Vereinfachung:} Objekte residieren in zusammenhängendem Speicher
    \medskip
  
    \btAnimation[width=\textwidth]{range=1-4:<1->}{fig/06-lifecycle}

    \bi
    \ii \structure{Geburt}: Initialisierung von frisch allokiertem Speicher\\
    \small Objekt-Zustand muss so präpariert werden, dass die Typ-Invarianten gelten.
    \smallskip
    \ii<2-> \structure{Leben}: Objekte transportieren Informationen im Programmablauf\\
    \small Sprache kann es uns erleichtern die Typ-Invarianten zu erhalten, sonst: Bugs.
    \smallskip
    \ii<3-> \structure{Tod}: Kontrolliertes Aufräumen des Zustands und Freigabe der Ressourcen\\
    \small Der Zeitpunkt und der Verantwortliche für das Aufräumen ist sprachabhängig.
    \ei
  \end{frame}

#+end_src
#+begin_src latex
  \begin{frame}[fragile]{Beispiel: Leben eines Loggers}
    \begin{columns}
      \begin{column}{0.49\textwidth}
        \begin{code}[tag=C]
          \begin{C}[style=smaller]
            typedef enum {
              DEBUG, INFO, WARN, ERROR, 
            } level_t;
          
            typedef struct {
              level_t level;
              int fd;
            } log_t;

            int main() {
              // Geburt
              log_t *L = log_init();

              // Leben
              log(L, INFO, "message");
              L->level = DEBUG;
              log(L, INFO, "message");

              // Tod
              log_deinit(L);
            }
          \end{C}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \begin{code}[]
          \begin{C}[style=smaller]
            log_t * log_init() {
              // Allokation: Speicher am Heap
              log_t *l = malloc(sizeof(log_t));
              // Initialisierung des Zustands
              l->level = WARN;
              l->fd    = open("/dev/stderr", 0);
              return l;
            }
          \end{C}
        \end{code}

        \begin{code}[]
          \begin{C}[style=smaller]
            void
            log(log_t *l, level_t ll, char *m) {
              if (ll >= l->level) {
                write(l->fd, m, strlen(m));
              }
            }
          \end{C}
        \end{code}

        \begin{code}[]
          \begin{C}[style=smaller]
            void log_deinit(log_t *l) {
              close(l->fd); // Datei schließen
              free(l);      // Speicher freigeben
            }
          \end{C}
        \end{code}
      \end{column}
    \end{columns}

    \bi
    \ii<2-> Kaum Sprachunterstützung: \codeinline{struct log_t} kann man leicht falsch halten!{
      \bi
      \ii Benutzer kann Invarianten verletzen:\btSetTab\codeinline{L->fd = 23;}
      \ii Use-after-free Bugs: \btUseTab\codeinline{log_deinit(L); log(L, ERROR, "panic");}
      \ii Vergessen das Objekt frei zu geben $\rightarrow$ Memory Leak
      \ei
    }
    \ei
    
  \end{frame}
#+end_src
* Geburt von Objekten
** Speicher-Allokation
#+begin_src latex
  \dividerframe{Geburt von Objekten}

  \begin{frame}[fragile]{Allokation: Wo kommt der Speicherplatz her?}
    \hspace{-1em}\textbf{Meistens} residieren Objekte in einem zusammenhängenden Speicherbereich
    \medskip
    \begin{center}
      \texttt{allocate(bytes\_t N)} $\longrightarrow$ Startadresse des zukünfigen Objekts
    \end{center}

    \bi
    \ii<2-> \structure{Statische Allokation} durch Übersetzer: Lebenszeit = Programlaufzeit {
      \bi
      \ii Absolute Adresse des Objekts steht vor der Laufzeit fest
      \ii Bsp.: globale Variablen, konstante Literale, Maschinencode einer Funktion
      \ii 2 statische Objekte: \codeinline{char *global = "foobar";} 
      \ei
    }\medskip
    \ii<3-> \structure{Stack Allokation}: Objekte können auf den Aufrufstapel{
      \bi
      \ii Allokation als Einbettung des Call-Frames einer Funktionsinstanz.
      \ii Lebenszeit des Objekts ist $\le$ Lebenszeit des Call-Frames.
      \ii Beispiele: Argumente, lokale Variablen, \codeinline{alloca()}
      \ei
    }\medskip
    \ii<4-> \structure{Heap Allokation}: Laufzeitsystem betreibt separaten Speicherpool {
      \bi
      \ii Lebenszeit unabhängig von Aufrufhierarchie, beliebige Allokations-Zeitpunkte
      \ii Benötigt komplexeres Speichermanagement und ist daher teurer.
      \ii Speicher muss irgendwann freigeben werden (manuell oder garbage collection)
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{Allokationen im größeren Kontext}
    \begin{center}
      \includegraphics[width=0.8\textwidth]{fig/06-process-mem}
    \end{center}

    \bi
    \ii Im klassisches UNIX-Modell wachsen Stack und Heap aufeinander zu.{
      \bi
      \ii Das ELF beschreibt die statisch allokierten Objekte (.text, .data, .bss)
      \ii Realität ist komplexer: Mehrere Stacks/Heaps, Addressspace-Randomization
      \smallskip
      \ii[$\rightarrow$] Genauere Betrachtung in Grundlagen der Betriebssysteme (GBS)
      \ei
    }\medskip
    \ii Für Programmiersprachen und Übersetzer nehmen wir an, dass... {
      \bi
      \ii Wir globale Objekte im Assembler anlegen können.
      \ii Der Prozess einen Stack hat und wir den Stackpointer kontrollieren.
      \ii Das Laufzeitsystem \codebox{void *malloc(size\_t)}/\codebox{free(void*)} bereitstellt.
      \ei
    }
    \ei
  \end{frame}
#+end_src
** Initialisierung
#+begin_src latex
  %%ONLY%%
  \begin{frame}{Initialisierung und Konstruktoren}
    \begin{btBlock}{}
      Wie wird aus dem allokierten, noch blanken, Speicherbereich ein Objekt?    
    \end{btBlock}

    \bi
    \ii \structure{Sprachabhängige} Initialisierung etabliert Meta-Informationen\\[1ex]
        \small\emph{Was macht ein Stück Speicher für meine Sprache zu einem Objekt?}\\[1ex]
        {
          \bi
          \ii Einige Sprachfeatures  erfordern zusätzliche Informationen an jedem Objekt.
          \ii Zum Beispiel  \btSetTab -- Dynamische Typinformationen in Form eines Typ Tags.\\
                            \btUseTab -- Registrierung des Objekts am Garbage Collector
          \ei
        }\medskip
    \ii<2-> \structure{Benutzerdefinierte} Initialisierung durch \textbf{Konstruktoren}\\[1ex]{
      \small\emph{Was möchte der Benutzer bei der Geburt eines Objekts tun?}\\[1ex]
      \bi
      \ii Auswahl der passenden Konstruktor-Methode, oft mittels Überladung
      \ii Konstruktor nimmt initiale Belegungen der Objekt-Attribute vor.
      \ii Bei Vererbung: Konstruktoren der Eltern-Klassen sollten zuerst aufgerufen.
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[fragile]{Konstruktoren in Aktion: Java}
    \begin{columns}
      \begin{column}{0.4\textwidth}
        \begin{code}[]
          \lstinputlisting[style=java,style=smaller]{lst/06-counter.java}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.59\textwidth}
        \bii
        \ii \structure{Automatischer} Aufruf von Konstruktoren {
          \bi
          \ii Konstruktoren heißen wie die Klasse.
          \ii Haben keinen Rückgabewert.
          \ii Nicht-initialisierte Attribute werden automatisch 0 oder \texttt{null}
          \ei
        }
        \medskip
        \ii[{\dn[font=\scriptsize]{1}}]\footnotesize Konstruktor muss \codeinline[style=java]{final}-Attribute setzen
        \ii[{\dn[font=\scriptsize]{2}}]\footnotesize Aufruf anderer Konstruktoren mittels \codebox{this()}
        \ii[{\dn[font=\scriptsize]{3}}]\footnotesize Autom. Aufruf des No-Arg Elternkonstruktors
        \ii[{\dn[font=\scriptsize]{4}}]\footnotesize Elternkonstruktor mittels \codebox{super()}
        \eii

        \begin{uncoverenv}<2->
        \begin{code}[tag=Pseudo-C]
          \begin{C}[style=smaller]
            //// Counter b = new Derived("123");
            // Allokation
            size_t size = sizeof(Derived);
            Derived *b = malloc(S);

            // Sprachspezifisches Init
            memset(b, 0, size);   // implizites nullen
            b->vtable = Dervied_vtable; // type-tag

            // Benutzerdefiniertes Init
            int tmp = parseInt("123")
            b->start = 3+tmp;
          \end{C}
        \end{code}
      \end{uncoverenv}
    \end{column}
    \end{columns}

  
  \end{frame}


#+end_src
** Referenz vs. Wertesemantik
* Leben von Objekten
** Unkontrollierer Objektzugriff
** Read-Only Zugriff und Immutable Data
** Lebenszeiten
* Tod von Objekten
** Deinitialisierung
** Reference Counting
** Automatic Garbage Collection
