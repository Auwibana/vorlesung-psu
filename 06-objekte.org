#+TITLE: Programmiersprachen und Übersetzer
#+SUBTITLE: 06 - Objekte
#+SETUPFILE: setup.org
#+INCLUDE: export-prologue.org
#+PROPERTY: header-args:latex :tangle yes :noweb yes :tangle-macros yes :tangle-prologue topic :tangle-epilogue endtopic :exports none

#+NAME: topic
#+BEGIN_SRC latex :tangle no
\psuSectionStart{{{{property(ITEM)}}}}{{{{n(block)}}}}
#+END_SRC

#+NAME: endtopic
#+BEGIN_SRC latex :tangle no
\psuSectionStop{{{{property(ITEM)}}}}{{{{n(block,-)}}}}
#+END_SRC

* Gedanken zu dieser Vorlesung                                     :noexport:
Stoffsammlung:
  - Lebenszyklus eines Objekts, Lebenszeit
  - Geburt und Initialisierung
    - Speicherallokation
    - Initialisierung 
    - Referenz vs. Value Model
  - Während der Lebenszeit
    - Getter und Setter
    - Problem: Paralleler Zugriff
    - Ownership of an Object
    - Read-Only Access
    - Immutable Objects
  - Garbage Collection  und Tod
    - Deinitialisierung
    - Reference Counting
    - Automatic Garbage Collection

Was soll der Studierende aus dieser Vorlesung mitnehmen?
  - Welche Besonderheiten kann eine Sprache bzgl. ihrer Objekte haben? [Effektiv]
  - Was bedeutet es ein Objekt zu kopieren?                            [Effizient]
* Was ist ein "Objekt"?
:PROPERTIES:
:CUSTOM_ID: 06-einleitung
:END:

#+begin_src latex
  \subtitle{{{{subtitle()}}}}
  \begin{frame}
    \maketitle
  \end{frame}

  \begin{frame}{Einordnung in die Vorlesung: Objekte}
    \begin{center}
      \includegraphics[page=13,width=0.6\linewidth]{fig/01-overview-small}
    \end{center}
    \bi
    \ii Objekte sind die datentragenden Elemente in einer Laufzeitumgebung {
      \bi
      \ii Die virtuelle Sprach-Maschine definiert \alert{Geburt, Leben und Tod} von Objekten.
      \ii Effiziente Programme gehen \advantage{sparsam und sorgsam} mit Objekten um.
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{Was ist ein Objekt?}
    \begin{center}
      \includegraphics[width=0.75\textwidth]{fig/06-object-types}
    \end{center}
    \bi
    \ii \textbf{Erinnerung 1. Vorlesung}: Maschinenmodell der virtuellen Maschine:{
      \bi
      \ii \structure{Speicher/Objekte}: Wie kann man Informationen ablegen und wieder abrufen?
      \ii \structure{Befehle/Operationen}: Wie kann man Informationen miteinander kombinieren?
      \ei
    }
    \ei
    \pause
    \begin{btBlock}{Definition: Objekt}
      Ein Objekt ist ein logisch-zusammengehöriger Verbund von Informationen, dessen \emph{Lebenszeit} kleiner oder gleich der Programmlaufzeit ist.
    \end{btBlock}
    \pause
    \hspace{-1em}\textbf{Wichtig:} \btSetTab (1) Variablen $\ne$ Objekte! Variablen können Objekte beinhalten.\\
    \btUseTab (2) Diese Definition umfasst auch primitive Objekte, wie Zahlen!
  \end{frame}

  \begin{frame}{Lebenszyklus eines Objekts}
    \hspace{-1em}\textbf{Vereinfachung:} Objekte residieren in zusammenhängendem Speicher
    \medskip
  
    \btAnimation[width=\textwidth]{range=1-4:<1->}{fig/06-lifecycle}

    \bi
    \ii \structure{Geburt}: Initialisierung von frisch allokiertem Speicher\\
    \small Objekt-Zustand muss so präpariert werden, dass die Typ-Invarianten gelten.
    \smallskip
    \ii<2-> \structure{Leben}: Objekte transportieren Informationen im Programmablauf\\
    \small Sprache kann es uns erleichtern die Typ-Invarianten zu erhalten, sonst: Bugs.
    \smallskip
    \ii<3-> \structure{Tod}: Kontrolliertes Aufräumen des Zustands und Freigabe der Ressourcen\\
    \small Der Zeitpunkt und der Verantwortliche für das Aufräumen ist sprachabhängig.
    \ei
  \end{frame}

#+end_src
#+begin_src latex
  \begin{frame}[fragile]{Beispiel: Leben eines Loggers}
    \begin{columns}
      \begin{column}{0.49\textwidth}
        \begin{code}[tag=C]
          \begin{C}[style=smaller]
            typedef enum {
              DEBUG, INFO, WARN, ERROR, 
            } level_t;
          
            typedef struct {
              level_t level;
              int fd;
            } log_t;

            int main() {
              // Geburt
              log_t *L = log_init();

              // Leben
              log(L, INFO, "message");
              L->level = DEBUG;
              log(L, INFO, "message");

              // Tod
              log_deinit(L);
            }
          \end{C}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \begin{code}[]
          \begin{C}[style=smaller]
            log_t * log_init() {
              // Allokation: Speicher am Heap
              log_t *l = malloc(sizeof(log_t));
              // Initialisierung des Zustands
              l->level = WARN;
              l->fd    = open("/dev/stderr", 0);
              return l;
            }
          \end{C}
        \end{code}

        \begin{code}[]
          \begin{C}[style=smaller]
            void
            log(log_t *l, level_t ll, char *m) {
              if (ll >= l->level) {
                write(l->fd, m, strlen(m));
              }
            }
          \end{C}
        \end{code}

        \begin{code}[]
          \begin{C}[style=smaller]
            void log_deinit(log_t *l) {
              close(l->fd); // Datei schließen
              free(l);      // Speicher freigeben
            }
          \end{C}
        \end{code}
      \end{column}
    \end{columns}

    \bi
    \ii<2-> Kaum Sprachunterstützung: \codeinline{struct log_t} kann man leicht falsch halten!{
      \bi
      \ii Benutzer kann Invarianten verletzen:\btSetTab\codeinline{L->fd = 23;}
      \ii Use-after-free Bugs: \btUseTab\codeinline{log_deinit(L); log(L, ERROR, "panic");}
      \ii Vergessen das Objekt frei zu geben $\rightarrow$ Memory Leak
      \ei
    }
    \ei
    
  \end{frame}
#+end_src
* Geburt von Objekten
** Speicher-Allokation
#+begin_src latex
  \dividerframe{Geburt von Objekten}

  \begin{frame}[fragile]{Allokation: Wo kommt der Speicherplatz her?}
    \hspace{-1em}\textbf{Meistens} residieren Objekte in einem zusammenhängenden Speicherbereich
    \medskip
    \begin{center}
      \texttt{allocate(bytes\_t N)} $\longrightarrow$ Startadresse des zukünfigen Objekts
    \end{center}

    \bi
    \ii<2-> \structure{Statische Allokation} durch Übersetzer: Lebenszeit = Programlaufzeit {
      \bi
      \ii Absolute Adresse des Objekts steht vor der Laufzeit fest
      \ii Bsp.: globale Variablen, konstante Literale, Maschinencode einer Funktion
      \ii 2 statische Objekte: \codeinline{char *global = "foobar";} 
      \ei
    }\medskip
    \ii<3-> \structure{Stack Allokation}: Objekte können auf den Aufrufstapel{
      \bi
      \ii Allokation als Einbettung des Call-Frames einer Funktionsinstanz.
      \ii Lebenszeit des Objekts ist $\le$ Lebenszeit des Call-Frames.
      \ii Beispiele: Argumente, lokale Variablen, \codeinline{alloca()}
      \ei
    }\medskip
    \ii<4-> \structure{Heap Allokation}: Laufzeitsystem betreibt separaten Speicherpool {
      \bi
      \ii Lebenszeit unabhängig von Aufrufhierarchie, beliebige Allokations-Zeitpunkte
      \ii Benötigt komplexeres Speichermanagement und ist daher teurer.
      \ii Speicher muss irgendwann freigeben werden (manuell oder garbage collection)
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{Allokationen im größeren Kontext}
    \begin{center}
      \includegraphics[width=0.8\textwidth]{fig/06-process-mem}
    \end{center}

    \bi
    \ii Im klassisches UNIX-Modell wachsen Stack und Heap aufeinander zu.{
      \bi
      \ii Das ELF beschreibt die statisch allokierten Objekte (.text, .data, .bss)
      \ii Realität ist komplexer: Mehrere Stacks/Heaps, Addressspace-Randomization
      \smallskip
      \ii[$\rightarrow$] Genauere Betrachtung in Grundlagen der Betriebssysteme (GBS)
      \ei
    }\medskip
    \ii Für Programmiersprachen und Übersetzer nehmen wir an, dass... {
      \bi
      \ii Wir globale Objekte im Assembler anlegen können.
      \ii Der Prozess einen Stack hat und wir den Stackpointer kontrollieren.
      \ii Das Laufzeitsystem \codebox{void *malloc(size\_t)}/\codebox{free(void*)} bereitstellt.
      \ei
    }
    \ei
  \end{frame}
#+end_src
** Initialisierung
#+begin_src latex
  \begin{frame}{Initialisierung und Konstruktoren}
    \begin{btBlock}{}
      Wie wird aus dem allokierten, noch blanken, Speicherbereich ein Objekt?    
    \end{btBlock}

    \bi
    \ii \structure{Sprachabhängige} Initialisierung etabliert Meta-Informationen\\[1ex]
        \small\emph{Was macht ein Stück Speicher für meine Sprache zu einem Objekt?}\\[1ex]
        {
          \bi
          \ii Einige Sprachfeatures  erfordern zusätzliche Informationen an jedem Objekt.
          \ii Zum Beispiel  \btSetTab -- Dynamische Typinformationen in Form eines \structure{Typ-Tags}.\\
                            \btUseTab -- Registrierung des Objekts am Garbage Collector (später mehr)
          \ei
        }\medskip
    \ii<2-> \structure{Benutzerdefinierte} Initialisierung durch \textbf{Konstruktoren}\\[1ex]{
      \small\emph{Was möchte der Benutzer bei der Geburt eines Objekts tun?}\\[1ex]
      \bi
      \ii Initiale Belegungen der Objekt-Attribute
      \ii Parametrisierte Konstruktion
      \ii Intention des Benutzers: Etablierung der \textbf{semantischen Invarianten}
      \ei>
    }
    \ei
  \end{frame}

  \begin{frame}[fragile]{Sprachregeln für Konstruktoren }
    \begin{columns}
      \begin{column}{0.49\textwidth}
        \begin{code}[tag=C++]
          \begin{CPP}
            class Base {
              public: 
                Base(int x)    { ... }
                Base(string x) { ... }
            };
          \end{CPP}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \begin{code}[tag=Java]
          \begin{java}
            class Base {
              public Base(int x)    { ... }
              public Base(String x) { ... }
            };
          
          \end{java}
        \end{code}
      \end{column}
    \end{columns}

    \bi
    \ii \structure{Definition} von eigenen Konstruktoren {
      \bi
      \ii Definieren wir keine eigenen, werden Default-Konstruktoren erzeugt
      \ii Konstruktoren haben Parameter und können Überladen werden
      \ii Sehen aus wie Funktionen, haben aber keinen Rückgabewert
      \ei
    }\medskip
  
    \ii \structure{Aufruf} von Konstruktoren {
      \bi
      \ii Konstruktoren werden bei Objekterstellung \alert{automatisch} aufgerufen.
      \ii Bei Vererbung: Eltern-Konstruktoren vor Kind-Konstruktoren\\
          $\Rightarrow$ Kind-Konstruktoren finden ein valides Eltern-Objekt vor.
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[fragile]{Konstruktoren in Aktion: Java}
    \begin{columns}
      \begin{column}{0.4\textwidth}
        \begin{code}[]
          \tikzset{every dn/.style={visible on=<2->}}
          \lstinputlisting[style=java,style=smaller]{lst/06-counter.java}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.59\textwidth}
        \bii
        \ii Java {\bi
          \ii Konstruktoren heißen wie die Klasse.
          \ii Nicht-initialisierte Attribute werden automatisch 0 oder \texttt{null}
          \ei
        }
        \medskip
        \ii<2-> Ablauf für \codeinline[style=java,style=smaller]{new Derived("123")}{
          \bi
          \ii[{\dn[font=\tiny]{1}}]\footnotesize Aufruf anderer Konstruktoren mittels \codeinline[style=java,style=smaller]{this()}
          \ii[{\dn[font=\tiny]{2}}]\footnotesize Elternkonstruktor mittels \codeinline[style=java,style=smaller]{super()}
          \ii[{\dn[font=\tiny]{3}}]\footnotesize Konstruktor setzt \codeinline[style=java,style=smaller]{final}-Attribut
          \ii[{\dn[font=\tiny]{4}}]\footnotesize Autom. Nullung durch \codeinline[style=smaller]{Object}-Konstruktor

          \ei
        }
        \medskip
        \ii<3-> { Wie sähe eine manuelle Konstruktion aus?
          \begin{minipage}{0.9\linewidth}
            \begin{code}[tag=Pseudo-C]
              \begin{C}[style=smaller]
                // Allokation
                Derived *this = malloc(sizeof(Derived));

                // Sprachspezifisches Init
                memset(this, 0, sizeof(Derived));
                this->vtable = Dervied_vtable;

                // Konstruktor (inlined)
                int tmp = parseInt("123")
                this->start = 3+tmp;
              \end{C}
            \end{code}
          \end{minipage}
        }
        \eii
    \end{column}
    \end{columns}
  \end{frame}


#+end_src
#+begin_src latex
  \begin{frame}[fragile]{Was sollte \textbf{mein} Konstruktor leisten?}
    \begin{btBlock}{\small Sinnvolle Konvention: Konstruktoren stellen semantische Invarianten her}\small
      -- Entwickler trifft \textbf{immerwährende Annahmen} über den Zustand eines Objekts. \\
      -- \textbf{Jeder} Konstruktor hinterlässt ein Objekt, dass die Annahmen einhält.\\
      -- Jede weitere Operation auf dem Objekt muss diese Annahmen \textbf{erhalten}.
    \end{btBlock}

    \bi
    \ii<2-> Beispiel: Bounded Pointer zeigt nur auf die Elemente eines Arrays\\[0.5ex] {
      \begin{columns}
        \begin{column}{0.44\textwidth}
          \begin{code}[]
            \begin{CPP}[style=smaller]
              class bounded_ptr {
                int *data;
                unsigned length;
                int *ptr;
              
                bounded_ptr(unsigned len) {
                  data   = malloc(len);
                  length = len;
                  ptr    = &data[0];
                }

                void set(int val) {
                  ,*ptr = val;
                }
                ...
              };
            \end{CPP}
          \end{code}
        \end{column}\hfill
        \begin{column}{0.55\textwidth}
          \bi
          \ii Invarianten für bounded\_ptr {
            \btUseExtraItemSep
            \bi
            \ii \texttt{data} zeigt auf ein valides Integer-Array\\[1ex]
            \ii \texttt{length} gibt Länge dieses Arrays an\\[1ex]
            \ii \texttt{ptr} ist die Adresse eines Array-Elements
            \ei
          }
          \ii<3-> \textbf{\advantage{Bonussternchen}}, falls der Benutzer nicht in der Lage ist die Invarianten zu verletzen.
          \ei
        \end{column}
      \end{columns}


    }
    \ei
  \end{frame}
#+end_src
* Leben von Objekten
** Werte- und Referenzmodell
#+begin_src latex
  \dividerframe{Leben von Objekten}
  \begin{frame}[t]{Wie werden Objekte abgelegt und weitergereicht?}
    \textbf{Erinnerung (binding time):} Ein Objekt wird an einen Namen gebunden.

    \begin{center}
      \codebox{var\_foo = new object();}\hspace{1cm}\codebox{foo(var\_foo);}
    \end{center}

    \hspace{-1em}Mittels gebundener Namen können wir Objekte \alert{ansprechen und weitergeben}.\\[0.5ex]
    \uncover<2->{
      \hspace{-1em}\textbf{Aber:} Ist der Wert einer Variable das Objekt oder eine Objekt-Referenz?
    }

    \begin{columns}<3->
      \begin{column}{0.49\textwidth}
        \begin{center}
          \includegraphics[page=1,height=2cm]{fig/06-val-refs}
        \end{center}
        \STRUCTURE{Wertemodell für Variablen}
        \bii
        \ii Objekte \enquote{leben} in Variablen
        \ii Zuweisung erzeugt eine \textbf{Kopie}
        \ii Referenzen sind separate Objekte
        \ii[$\Rightarrow$] C, C++, Rust
        \eii
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \begin{center}
          \includegraphics[page=2,height=2cm]{fig/06-val-refs}
        \end{center}
        \STRUCTURE{Referenzmodell für Variablen}
        \bii
        \ii Variable speichert nur Referenz
        \ii Zuweisung erzeugt weitere Referenz
        \ii Keine separaten Referenzobjekte
        \ii[$\Rightarrow$] Java (mostly), Python, Ruby
        \eii
      \end{column}
    \end{columns}

  \end{frame}

  \begin{frame}[fragile]{Wertemodell: Vor- und Nachteile}
    \begin{columns}
      \begin{column}{0.45\textwidth}
        \begin{code}[tag=C++11]
          \begin{CPP}
            class foo_t { int x; };
            ...
            foo_t A { 23 };
            foo_t B = A;
            A.x = 42; // B.x == 23
          \end{CPP}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.53\textwidth}
        \bii
        \ii A und B enthalten \alert{verschiedene} Objekte
        \ii Initialisierung von B durch Kopie
        \ii Objekte-Inhalte/Speicher werden kopiert
        \eii
      \end{column}
    \end{columns}
    \medskip

    \bi
    \iiad<2-> Das Wertemodell is \advantage{flexibler} und kann \advantage{effizienter} sein. {
      \bi
      \ii Indirektion nur auf Nachfrage; kleine Objekte lassen sich effizient kopieren.
      \ii Referenzen sind explizit im Code sichtbar (als Zeiger-Typ)
      \ii Objekte in lokalen Variablen können am Stack alloziert werden.
      \ei
    }\medskip
    \iida<3-> Das Wertemodell ist \alert{komplexer} und \alert{schwieriger zu beherrschen}. {
      \bi
      \ii Referenzen machen das Programmiermodell komplexer.
      \ii Häufiges Kopieren \emph{kann} unsichtbaren Overhead erzeugen.
      \ii Initialisierung durch Kopieren (oder Verschieben) ist eigentlich ein Sonderfall\\
      $\Rightarrow$ C++ kennt 3 Sorten von Konstruktoren: Init-, Copy-, Move-Konstruktoren
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[fragile]{Referenzmodell: Vor- und Nachteile}
      \begin{columns}
      \begin{column}{0.45\textwidth}
        \begin{code}[tag=Java]
          \begin{java}
            class foo { public int x; }
            ...
            foo A = new foo();
            A.x   = 23;
            foo B = A;
            // B.x == 23
          \end{java}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.53\textwidth}
        \bii
        \ii Beide referenzieren das \alert{gleiche Objekt}
        \ii Automatisch Dereferenzierung
        \ii Objekterzeugung nur mittels \codeinline[style=java,style=smaller]{new T()}
        \eii
      \end{column}
    \end{columns}
    \medskip

    \bi
    \iiad<2-> Im Referenzmodell sind Variablen und Objekte \advantage{orthogonal}. {
      \bi
      \ii Objekte existieren \textbf{immer} unabhängig von Variablen und Funktionsaufrufen
      \ii Weitergabe quer zur Aufrufhierarchie ist trivial.
      \ii Keine Probleme mit Kind-Klassen die mehr Speicher brauchen.\\
          Problematisch in C++: \codeinline[style=CPP,style=smaller]{Base func() { Derived d; return d; }}
      \ei
    }\medskip
    \iida<3-> Im Referenzmodell tragen wir immer \alert{die Kosten} der Indirektion {
      \bi
      \ii Ohne Optimierungen müssen alle Objekte am Heap alloziert werden.
      \ii Todeszeitpunkt von Objekten ist unklar.
      \ii Primitive Typen: Jeder Integer hinter einem Pointer? \\
          Java: Wertemodell für Zahlen, außer wenn nicht (Auto(un-)boxing).
      \ei
    }
    \ei
  \end{frame}

#+end_src
** Objektzugriff auf Objektdaten
#+begin_src latex
  \begin{frame}{Zugriff auf Objekte}
    \begin{center}
      \includegraphics[page=1]{fig/06-access}
    \end{center}

    \bi
    \ii Welche \structure{Arten von Zugriffen} gibt es? {
      \bi
      \ii Daten aus dem einem Objekt auslesen oder verändern.
      \ii Direkter Speicherzugriff oder gefiltert über getter/setter.
      \ii Ableitung weiterer Referenzen (z.B. Subobjekte: \codebox{\&obj.x}). \hfill \ALERT<1>{Gefährlich!}
      \ei
    }\smallskip
    \ii Wer ist der \structure{Benutzer} eines Objekts? {
      \bi
      \ii Eigentlich: Das laufende Programm (aktiv) greift auf ein Objekt (passiv) zu.
      \ii Nützliche Präzisierungen: Zugreifende Funktion, zugreifender Thread
      \ei
    }\smallskip
    \ii Welche \structure{Berechtigungen} hat der Benutzer? {
      \bi
      \ii Referenzen sind Befähigungen (Capabilities) ein Objekt zu nutzen.
      \ii Nicht jede Referenz auf ein Objekt muss gleich mächtig sein.
      \ei
    }
    \ei

    \uncover<2->{
      \begin{center}
        \vfill{}
        \OrangeBox{
          \textbf{Wer} greift \textbf{Wie} mit \textbf{welchem Recht} zu?        
        }
    \end{center}
    }

  \end{frame}

  \begin{frame}[fragile]{Gefilterter Zugriff über Getter und Setter}
    \begin{columns}
      \begin{column}{0.44\textwidth}
        \begin{btBlock}{Direkter Speicherzugriff}
          \centering
          \texttt{obj.length = -1;}\\
          User kann Invarianten verletzen
        \end{btBlock}      
      \end{column}
      \begin{column}{0.10\textwidth}
        \centering
        \Huge$\leftrightarrow$
      \end{column}
      \begin{column}{0.44\textwidth}
        \begin{btBlock}{Nur Methodenzugriff}
          \centering \texttt{obj.setLength(-1);}\\
          Boilerplate, reine Konvention
        \end{btBlock}      
      \end{column}
    \end{columns}

    \pause\bigskip

    \btAnimation{center,padding,2:<1->}{fig/06-access}
    \bi
    \ii Einige Sprachen erlauben den gefilterten Zugriff auf einzelne Attribute {
      \begin{columns}
        \begin{column}{0.55\textwidth}
          \bi
          \ii Verwendung sieht aus wie direkter Zugriff
          \ii \texttt{set()} beim Schreiben eines Attributs\\[-0.5ex]
          \ii \texttt{get()} zum Lesen eines Attributs
          \ii Kann \textbf{nachträglich} eingefügt werden, ohne die Benutzer zu ändern!
          \ei
        \end{column}\hfill
        \begin{column}{0.45\textwidth}
          \begin{code}[tag=C\#]
            \begin{sharpc}
              public class Student {
                private string name;
              
                public string Name {
                  get { return name; }
                  set { name = value; }
                }
              }
            \end{sharpc}
          \end{code}
        \end{column}
      \end{columns}

    }
    \ei
  \end{frame}

  \begin{frame}{Benutzer-abhängige Zugriffseinschränkungen}
    \btAnimation{center,padding,3:<1->}{fig/06-access}
    \medskip
    \bi
    \ii \textbf{Ziel:} Benutzergruppen mit unterschiedlichen Zugriffsrechten {
      \bi
      \ii Identifikation der unterschiedlichen Gruppen \hfill(Wer greift zu?)
      \ii Einteilung anhand der zugreifenden Instruktionadresse
      \ii[$\Rightarrow$] Wir können den Code mit unbeschränktem Zugriff kontrollieren.
      \ei
    }\medskip
    \ii<2-> \textbf{Implementierung:} Einschränkung der Sichtbarkeit des Namens {
      \bi
      \ii Wenn der externe Nutzer einen Namen nicht sieht, kann er nicht zugreifen.
      \ii \textbf{Aber:} Gibt ein interner Nutzer eine Referenz auf ein privates Attribut heraus, bricht die Abstraktion. \textbf{Referenzen geben Kontrolle heraus!}
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{Referenzen-abhängige Zugriffseinschränkungen}
    \btAnimation{center,padding,4:<1->}{fig/06-access}
    \medskip

    \bi
    \ii \textbf{Ziel:} Einschränkbare Referenzen erlauben kontrolliertes Sharing {
      \bi
      \ii Über eingeschränkte Referenzen dürfen nicht alle Zugriffe erfolgen
      \ii Referenzen dürfen nur weiter eingeschränkt und nicht geweitet werden.
      \ii Beispiel: Ableitung einer read-only Referenz aus einer read-write Referenz
      \ei
    }\medskip
    \ii<2-> \textbf{Implementierung (const):}  Erweiterung des Typsystems{
      \bi
      \ii Weiterer Zeiger-Typkonstruktor:    \typeinline{const\_pointer(T)}\\[.5ex]
      \ii Implizite Typumwandlung zur read-only Referenz\\[.5ex]
      \ii Asymmetrische Typ-Kompatibilität:  \typeinline{const\_pointer(T)} $\ll$ \typeinline{pointer(T)}\\[.5ex]
      \ei
    }
    \ii<3-> Standardverhalten in verschiedenen Sprachen{
      \bi
      \ii \structure{C++}:  \hspace{1ex}\btSetTab Read-only ist die Ausnahme \hfill(\texttt{T*, const T\*}).
      \ii \structure{Rust}: \btUseTab Read-only ist die Regel \hfill(\texttt{\&T, \&mut T})
      \ii \structure{Java}: \btUseTab Alle Referenzen dürfen alles. 
      \ei
    }
    \ei
  \end{frame}

#+end_src
** Fallstudie: Immutable Objects
#+begin_src latex
  \begin{frame}[fragile]{Fallstudie: Unveränderliche Objekte}
    \begin{btBlock}{Unveränderliche Obejekte (immutable objects)}
      Gibt es für ein Objekt, im gesamten Programm, keine read-write Referenzen, so ist sein Inhalt unveränderlich.
    \end{btBlock}
  
    \bi
    \ii<2-> Immutability für ein Objekt bringt spannende Eigenschaften {
      \bi
      \ii Thread-Safety: Keine Probleme mit konkurrierenden Schreibzugriffen
      \ii Werte- und Referenzmodell werden equivalent.
      \ii Deduplikation von Objekten ist möglich (=interning).
      \ii \textbf{Aber:} Verändernde Operation müssen das Objekt verändert kopieren
      \ei
    }\medskip
    \ii<3-> Manche Objekte sind natürlichweise Immutable {
      \bi
      \ii \structure{Zahlen}: Die Zahl 5 kann nicht so verändert werden, dass alle Fünfen im gesamten Programm plötzlich Achten sind.
      \smallskip
      \ii \structure{String-Literale}: Der Übersetzer legt literale Zeichenketten (\codeinline[style=C,style=smaller]{"Hello"}) nur einmal in die Binärdatei.
      \ei
    }
    \ei
  \end{frame}
#+end_src

https://medium.com/@bdov_/https-medium-com-bdov-python-objects-part-iii-string-interning-625d3c7319de

** Lebenszeiten
* Tod von Objekten
** Deinitialisierung
** Reference Counting
** Automatic Garbage Collection
