#+TITLE: Programmiersprachen und Übersetzer
#+SUBTITLE: 07 - Operationen
#+SETUPFILE: setup.org
#+INCLUDE: export-prologue.org
#+PROPERTY: header-args:latex :tangle yes :noweb yes :tangle-macros yes :tangle-prologue topic :tangle-epilogue endtopic :exports none

#+NAME: topic
#+BEGIN_SRC latex :tangle no
\psuSectionStart{{{{property(ITEM)}}}}{{{{n(block)}}}}
#+END_SRC

#+NAME: endtopic
#+BEGIN_SRC latex :tangle no
\psuSectionStop{{{{property(ITEM)}}}}{{{{n(block,-)}}}}
#+END_SRC

* Gedanken zu dieser Vorlesung                                     :noexport:
- Expressions
  - Arithmetric
  - Relational
  - Zuweisung, L-Values, R-Values
- Kontrollfluss
  - Die sequentielle Maschine
  - Seiteneffekte & Ausführungsreihenfolge
  - Sequencing: Statements ung Goto
  - Invocation: call, return; Call-by-value, Call-by-ref
  - Selection (if, cond, case, Short-Circuit Semantic?)
  - Iteration (Logical-Controlled Loops, Enumeration-Controlled Loops, Iteratoren)
- Vom Instruktionsstrom zum Kontrollflussgraphen
  - Kontrollflussgraphen
  - Basisblöcke
  - Kontrollflussgraphen auf mehreren Ebenen

Effektiv:  Welche Werkzeuge habe ich den potentiellen Instruktionsstrom zu Formen?
Effizienz: Seiteneffekte 

* Was ist eine "Operation"?
:PROPERTIES:
:CUSTOM_ID: 07-einleitung
:END:

#+begin_src latex
  \subtitle{{{{subtitle()}}}}
  \begin{frame}
    \maketitle
  \end{frame}

  \begin{frame}{Einordnung in die Vorlesung: Operationen}
    \begin{center}
      \includegraphics[page=12,width=0.6\linewidth]{fig/01-overview-small}
    \end{center}
    \bi
    \ii Operation \alert{kombinieren Daten} und \alert{manipulieren Objekte} {
      \bi
      \ii Operationen hängen implizit und/oder explizit voneinander ab
      \ii Abbildung des virtuellen Operationsstrom auf die reale, sequentielle Maschine
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[t,fragile]{Was ist eine "Operation"?}
    \btAnimation{center,padding,1:<1->}{fig/07-operations}
    \bi
    \ii \textbf{Erinnerung 1. Vorlesung}: Maschinenmodell der virtuellen Maschine:{
      \bi
      \ii \structure{Speicher/Objekte}: Wie kann man Informationen ablegen und wieder abrufen?
      \ii \structure{Befehle/Operationen}: Wie kann man Informationen miteinander kombinieren?
      \ei
    }\medskip
    \ii Operationen sind Aktiv $\leftrightarrow$ Objekte sind Passiv {
      \bi
      \ii \structure{Quelloperanden}: Eingabeobjekte, die von der Operation gelesen werden.
      \ii \structure{Abbildungsvorschrift}: Kombinationsregel für die gelesenen Daten.
      \ii \structure{Zieloperanden}: Ausgabeobjekt nimmt das Rechenergebnis auf
      \ei
    }
    \ii[]<2->{
    \begin{code}
      \begin{codetext}[style=smaller]
        Operation: "+"
          Quelloperand: LHS (Typ: 32-Bit Integer), RHS (Typ: 32-Bit Integer)
          Zieloperand:  ret (Typ: 32-Bit Integer)
          Abbildungsvorschrift: 
             L   = eval(LHS) // Linke Seite auswerten
             R   = eval(RHS) // Rechte Seite auswerten
             ret = modulo(add(L, R), 32)
       \end{codetext}
     \end{code}
   }\ei
  \end{frame}

#+end_src

* Einfache Operationen

#+begin_src latex
  \dividerframe{Einfache\\Operationen}
  \begin{frame}[fragile]{Arithmetische, Bit-weise und logische Operationen}
    \begin{center}
      {\Large \verb!+ - * / %     ~ & | ^ << >>  < <= == => >!}
      \OrangeBox<2->{Notation, Vorrang und Assoziativität wird vom Parser aufgelöst.}
    \end{center}
    \def\op{\textit{op}}
    \def\codebox#1{\Colorbox{codecolor}{\scriptsize\texttt #1}}
    \setbeamercovered{still covered={\opaqueness<1->{0}},again covered={\opaqueness<1->{30}}}
    \bi
    \ii<-2> \structure{Notationen} in unterschiedlichen Sprachen {
      \bi
      \ii Prefix: \codebox{\op{} A B} oder \codebox{\op(A,B)} oder \codebox{(\op{} A B)} \hfill Lisp, Scheme
      \ii Infix:  \codebox{A \op{} B}  \hfill C, C++, Java, \ldots
      \ii Postfix: \codebox{A B \op}   \hfill Forth, PostFix
      \ei
    }\medskip
    \ii<-2> \structure{Vorrang} (Precedence): Bindet Multiplikation stärker als Addition?\\{
      \codebox{1*2+3*4} $\rightarrow$ \btSetNamedTab{\first}\codebox{(1*2)+(3*4)} (14) \hspace{1em} \btSetNamedTab{\second} $\vee$ \hspace{1em}  \codebox{1*(2+3)*4} (20)
    }\medskip
    \ii<-2> \structure{Assoziativität}: Wird links oder rechts geklammert? \\{
       \codebox{1-2-3-4} $\rightarrow$ \first\codebox{(((1-2)-3)-4)} (-8)  \second $\vee$\hspace{1em} \codebox{1-(2-(3-4))} (-2)
     }
    \ei
    \bi
    \ii<3-> \ALERT{Wichtige} Eigenschaften dieser Operationen {
      \bi
      \ii Quelloperanden werden \alert{alle ausgewertet, bevor} die Operation ausgeführt wird
      \ii Keine \structure{Seiteneffekte} und genau ein \structure{temporäres Objekt} als Zieloperand
      \ei
    }
    \ei
  \end{frame}


  \begin{frame}{Auswertungsreihenfolge von einfachen Operationen}
    \bi
    \ii Semantische Lücke zwischen virtueller und realer Maschine {
      \bi
      \ii Operationen auf Sprachebene sind als (expliziter oder impliziter) Baum notiert
      \ii Alle realen Maschinen sind \structure{Sequentielle Maschinen}\smallskip
      \ei
    }
    \ei
    \begin{btBlock}{Auswertungsreihenfolge}
      Abbildung der Operationen des ASTs auf eine lineare Befehlssequenz.
    \end{btBlock}

    \begin{columns}<2->
      \begin{column}{0.3\textwidth}
        \includegraphics[width=\textwidth,page=1]{fig/07-simple-expr}
      \end{column}\hfill
      \begin{column}{0.69\textwidth}
        \bii
        \ii \enquote{Links nach Rechts}      \hfill\btImage[baseline,anchor=west,text width=3.5cm,opts={page=3}]{fig/07-simple-expr}
        \ii \enquote{Rechts nach Links}      \hfill\btImage[baseline,anchor=west,text width=3.5cm,opts={page=4}]{fig/07-simple-expr}
        \ii \enquote{Beliebiges Kind zuerst}:\hfill\btImage[baseline,anchor=west,text width=3.5cm,opts={page=5}]{fig/07-simple-expr}
        \eii
      \end{column}
    \end{columns}
  \end{frame}

  \begin{frame}{Abhängigkeiten zwischen Operationen}
    \begin{columns}
      \begin{column}{0.49\textwidth}
        \centering
        \includegraphics[height=2cm,page=2]{fig/07-simple-expr}
        \par
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \btAnimation[width=\textwidth,page=6]{range=6-7:<1->,8:<3->}{fig/07-simple-expr}
      \end{column}
    \end{columns}
    \medskip

    \bi
    \ii \structure{Abhängigkeit}: Eine Operationen hängt vom Ergebnis einer anderen ab{
      \bi
      \ii Abhängige Operationen müssen zuerst ausgewertet werden
      \ii Bei der Auswertungsreihenfolge: Keine Abhängigkeiten in die Zukunft
      \ii AST definiert hierarchische Abhängigkeiten zwischen Eltern und Kind
      \ei
    }\medskip
    \ii<3-> \advantage{\textbf{Freiheiten}} in der Auswertungsreihenfolge {
      \bi
      \ii Haben Operationen keine Abhängigkeit ist ihre Reihenfolge \textbf{\advantage{beliebig}}
      \ii[$\Rightarrow$] Übersetzer kann Reihenfolge frei wählen um Ausführung zu optimieren\\
         z.B: Weniger Speicherlatenz durch Einschieben von unabhängigen Operationen
      \ei
    }
    \ei

    \begin{btBlock}<4->{}\small
      Viele Sprachkonstrukte und -regeln erlauben es uns die \textbf{Auswertungsreihenfolge zu formen}, um die Abhängigkeiten explizit zu machen.
    \end{btBlock}

  \end{frame}
#+end_src

#+begin_src latex
  \begin{frame}{Die Zuweisungs-Operation (\texttt{:=})}
    \bi
    \ii Auswertung der rechten Seite $\rightarrow$ Ergebnis in der linken Seite speichern{
      \bi
      \ii Linke und rechte Seite werden \alert{nicht} symmetrisch übersetzt!
      \ii \structure{R-Wert}: Auf der rechten Seite berechnen wir das Ergebnis eines Ausdrucks
      \ii \structure{L-Wert}: Auf der linken Seite muss berechnet werden wohin das Ergebnis soll
      \ei
      \btAnimation[height=1.5cm]{center,padding,1:<1->}{fig/07-lvalue}
    }
    \ii<2-> Nicht jede Operation hat einen L-Wert \hfill (\codebox{char *c}){
      \bi
      \ii Konstanten (\codebox{1}, \codebox{"abc"}) haben keinen L-Wert\hfill\codebox{1 := 2}
      \ii Temporäre Zwischenergebnisse haben keinen L-Wert             \hfill\codebox{c + 10 := 2}
      \ei
    }
    \ii<3-> Unterschied bei L-Werten zwischen Werte- und Referenzmodell{
      \bi
      \ii \structure{Referenzmodell}: Alles was eine Referenz speichern kann ist ein L-Wert\\
          Variablen, Array-Elemente und Felder.\\[0.5ex]
      \ii \structure{Wertemodell}: Alles was ein Objekt speichern kann ist ein L-Wert\\
          zusätzlich: Dereferenzierung: \codebox{*(ptr)}, Referenzen: \codebox{char\& operator[](...)}
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{Seiteneffekte und Idempotenz}
    \begin{btBlock}{}
      Die Zuweisungs-Operation hat den gewollten \structure{Seiteneffekt} den Zustand der virtuellen Maschine zu verändern.
    \end{btBlock}

    \bi
    \ii \structure{Idempotenz}: Wiederholte Auswertung liefert immer dasselbe Ergebnis {
      \bi
      \ii Operationen mit Seiteneffekten sind nicht \structure{idempodent}\hfill \codebox{i = i + 1}
      \ii Rechnen und lesen (meistens) haben keine Seiteneffekte.
      \ii Nur beobachtbare Seiteneffekte sind ein Problem (seiteneffektfreie Funktion)
      \ii Strikt-Funktionale Sprachen (Haskell): Verbot jeglicher Seiteneffekte 
      \ei
    }\medskip
    \ii<2-> Wer sich auf Seiteneffekte verlässt erzeugt eine implizite Abhängigkeit.\\[0.5ex]{
     \begin{columns}
       \begin{column}{0.27\textwidth}
         \btAnimation[width=\textwidth] {padding,center,1:<-2>,2:<3->}{fig/07-side-effect}
       \end{column}\hfill
       \begin{column}{0.7\textwidth}
         \bi
         \ii Das Ergebnis von \codebox{(a := 2) + (b := a)} hängt von der Auswertungsreihenfolge ab
         \ii Ohne strikt-definierte Auswertungsreihenfolge ist das Ergebnis \ALERT{undefiniert}!
         \ii Sprachregeln und -konstrukte \textbf{vermeiden} implizite Abhängigkeiten oder \textbf{machen sie explizit}.
         \ei
       \end{column}
     \end{columns}
   }
   \ei
  \end{frame}
#+end_src

* Sprachkonstrukte zur Kontrolle der Auswertungsreihenfolge

#+begin_src latex
\dividerframe{Kontrolle über die Auswertungsreihenfolge}
  \begin{frame}{Umgang mit impliziten Abhängigkeiten}
    \begin{center}
      \btAnimation[height=2.5cm]{padding,range=1-3:<1->,4:<4->}{fig/07-dependency-model}
    \end{center}
    \medskip
  
    \bi
    \ii \textbf{Ausgangspunkt} und geistiges Modell für die folgenden Folien {
      \bi
      \ii<2-> \textbf{Gegeben}: Menge von Operationen mit Seiteneffekten \hfill($\alpha, \beta,\gamma, \ldots$)
      \ii<3-> Die Operationen hängen implizit voneinander ab             \hfill (gestrichelt)
      \ii<4-> Sprachmittel geben Reihenfolge und Vorrang explizit vor    \hfill(durchgezogen)
      \ii<5->  \textbf{Ziel}: \btSetTab Eine wohldefinierte Auswertungsreihenfolge, welche die\\
                              \btUseTab Abhängigkeiten erfüllt\\[2ex]
      \begin{center}
        \includegraphics[height=2cm,page=5]{fig/07-dependency-model}
      \end{center}
      \ei
    }
    \ei
  
  \end{frame}
#+end_src
** Sequenzierung: Statements und Goto
#+begin_src latex
  \begin{frame}[fragile]{Sequenzierung: Statements}
    \bi
    \ii \structure{Sequenzierung}: Vorgabe einer linearen, strikten Reihenfolge {
      \bi
      \ii Der Sequenzoperator (\codebox{;}) führt seine Kinder hintereinander aus
      \ii Die Operanden des Sequenzoperators heißen \structure{Statements}
      \ii Ergebnisse werden verworfen oder das erste/letzte wird zurückgegeben
      \ei
    }
    \ii<2-> Statements sind das grundlegende Sprachmittel in imperativen Sprachen\\[1ex] {
      \btAnimation{center,padding,1:<1->}{fig/07-statements}
    }
    \ei

    \begin{columns}<3->
      \begin{column}{0.49\textwidth}
        \begin{code}[tag=C]
          \begin{C}
            int a, b;
            void foo() {
              a = 1; a++; b = (a+=4, a * 3);
            } // b == 18
          \end{C}
        \end{code}
        \structure{C/C++}
        \bii
        \ii Sequenzierung: Komma, Semikolon
        \ii \texttt{$\alpha$;$\beta$} hat kein Ergebnis
        \ii \texttt{$\alpha$,$\beta$} liefert letztes Teilergebnis ($\beta$)
        \eii
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \begin{code}[tag=Ruby]
          \begin{ruby}
            a = (1+2 ; begin
                  x = 1 + 2
                  x * 3
                end + 1) # a == 10
          \end{ruby}
        \end{code}
        \structure{Ruby}
        \bii
        \ii Sequenzierung: \texttt{'\textbackslash n'}, Semikolon
        \ii Letztes Statement liefert  den Rückggabewert
        \eii
      \end{column}
    \end{columns}
  \end{frame}

  \begin{frame}[fragile]{Unterscheidung zwischen Expressions und Statements}
    \OrangeBox{Die meisten Sprachen treffen diese Unterscheidung}\medskip

    \bi
    \ii \structure{Ausdrücke/Expressions} {
      \bi
      \ii Haben einen Rückgabewert
      \ii Haben einen Rückggabetypen (bei statischer Typisierung)
      \ii Können Operanden anderer Expressions sein
      \ei
    }\medskip
    \ii \structure{Statements} {
      \bi
      \ii Haben keinen Rückggabewert und daher auch keinen Typen
      \ii Dienen als Elemente der Sequenzierung und anderer Programmstrukturen
      \ii Entsprechen (in etwa) einer Zeile Code
      \ii Werden in Code-Blöcken bzw. Compound-Statements zusammengefasst.
      \ei
    }\medskip
    \ii<2-> Manche Operationen haben eine Expression- und eine Statement-Form\\
    C: \codeinline{if (cond) { then_block } else { else_block}}\hfill%
    \codeinline{ cond ? then_expr : else_expr}

    
    \ei
  \end{frame}
#+end_src

#+begin_src latex
  \begin{frame}{Sequenzierung: Goto}
    \bi
    \ii Ein \structure{unbedingter Sprung} verbindet syntaktisch entfernte Statements {
      \bi
      \ii \structure{Sprungmarke}: Gibt einer Operation einen Namen
      \ii \structure{Sprung}: \btSetTab Auswertung wird an dieser Stelle \alert{abgebrochen} und an der\\
                              \btUseTab genannten Sprungmarke fortgesetzt.
      \ei
    }
    \ei
    \medskip
    \begin{columns}
      \begin{column}{0.40\textwidth}
        \centering\includegraphics[width=0.8\textwidth,page=1]{fig/07-goto}\par
      \end{column}\hfill
      \begin{column}{0.59\textwidth}
        \btAnimation[width=\textwidth]{range=2-4:<1->,5:<3->}{fig/07-goto}
      \end{column}
    \end{columns}
    \medskip

    \bi
    \ii<5-> Nachfolge-Operation einer Operation wird explizit und statisch benannt {
      \bi
      \ii Sprünge erlauben es Sequenzen zusammen zu stückeln
      \ii (Endlos laufende) Schleifen sind nun möglich \hfill \textit{Rückwärtssprünge}
      \ei
    }
    \ei

    \begin{btBlock}<6->{Definition: Kontrollfluss \hfill \textit{(vgl. mit Kontrollwerk der CPU)}}
      Ein Kontrollfluss ist eine \textbf{konkrete} Sequenz von Operationen, die hintereinander ausgeführt werden.
    \end{btBlock}

  \end{frame}
#+end_src
** Invokation: Funktionsaufrufe
#+begin_src latex
  \begin{frame}{Invokation: Funktionsaufrufe}
    \bi
    \ii Kontrollfluss-Brille: Sprung und Funktionsaufruf sind sehr ähnlich.{
      \bi
      \ii Der Kontrollfluss verlässt die aktuelle Operations-Sequenz
      \ii Die Auswertung wird an einer entfernten, benannten Operation fortgesetzt
      \ei
    }\smallskip
    \ii<2-> \textbf{Aber}: Funktionsaufrufe haben zwei \structure{grundlegende Erweiterungen} {
      \bi
      \ii \structure{Rücksprung}: \btSetTab Wir können von verschiedenen Stellen angesprungen werden und \\
                                  \btUseTab zur jeweiligen verlassenen Operations-Sequenz zurückkehren.
      \ii \structure{Argumente}: Wir können Daten an den Kontrollfluss heften
      \ei
    }
    \ei
    \bigskip
    \begin{columns}<3->
      \begin{column}{0.40\textwidth}
        \centering\includegraphics[width=0.8\textwidth,page=1]{fig/07-call}\par
      \end{column}\hfill
      \begin{column}{0.59\textwidth}
        \btAnimation[width=\textwidth]{2:<-3>, 3:<4>, 4:<5>,5:<6->}{fig/07-call}
      \end{column}
    \end{columns}
  \end{frame}


  \begin{frame}[fragile]{Teilfazit: Sequenzierung und Invokation}
    \begin{columns} 
      \begin{column}{0.3\textwidth}
        \begin{code}\ttfamily\small
        F1:\,\btSetNamedTab{\X}$\alpha$;\\
            \X \textbf{goto} L1;\\
        L2: \X $\gamma$;\\
            \X \textbf{call} F2;\\
            \X $\omega$;\\
            \X \textbf{goto} F1;\\
        L1: \X $\beta$;\\
            \X \textbf{goto} L2;\\
        F2: \X $\delta$;\\
            \X \textbf{return};\\[1ex]
        \end{code}\\
        \medskip
        \includegraphics[page=6,width=\textwidth]{fig/07-call}
      \end{column}\hfill
      \begin{column}<2->{0.65\textwidth}
        \btUseExtraItemSep[2ex]
        \bi
        \ii Übersichtlichkeit von Code{
          \bi
        \ii Sprungmarken, Sprünge und der Aufruf von Labels werden schnell unübersichtlich.
        \ii Dijkstra, 1968: \enquote{GOTO considered harmful}
        \ii Manche argumentieren, dass goto einen Anwendungsfall bei der Fehlerbehandlung hat (z.B. Linus Torvalds)
        \ii<3->[$\Rightarrow$] \structure{Funktionen mit Blockstruktur}, Sprünge nur selten:
        % 
        \begin{columns}
          \begin{column}{0.45\textwidth}
            \begin{code}[]
              \begin{C}[escapechar=!]
                void F1() {
                  !$\alpha$!; !$\beta$! ; F2() ; $\omega$
                }
              \end{C}
            \end{code}
          \end{column}\hfill
          \begin{column}{0.45\textwidth}
            \begin{code}
              \begin{C}[escapechar=!]
                void F2() {
                  !$\gamma$!; 
                }
              \end{C}
            \end{code}
          \end{column}
        \end{columns}
         \ei} \ei
      \end{column}
    \end{columns}
  
  \end{frame}
#+end_src
** Selektion: Bedingte Ausführung

#+begin_src latex
  \begin{frame}{Selektion: Bedingte Ausführung}
    \begin{btBlock}{Sequenzoperator, Sprüngen und Funktionsaufrufe}
      Wir können nur einen \textbf{linearen} Kontrollfluss vorschreiben; nur endlose Schleifen/Rekursionen sind möglich.
    \end{btBlock}
    \bigskip
    \bi
    \ii<2-> \ALERT{Wichtiger} als Operationen zu reihen, ist es Operationen auszulassen {%
      \bi
      \ii if-then-else--Operation (\texttt{ite}) wählt eine der Nachfolge-Operationen aus
      \ii Auswahl der nächsten Operation erfolgt anhand des \textbf{Programmzustandes}
      \ei
    }
    \ei
    \smallskip
    \begin{columns}
      \begin{column}<2-> {0.49\textwidth}\centering
        \includegraphics[width=0.7\textwidth,page=1]{fig/07-ite}
      \end{column}\hfill
      \begin{column}<3->{0.49\textwidth}\centering
        \includegraphics[width=0.7\textwidth,page=2]{fig/07-ite}
      \end{column}
    \end{columns}
    \smallskip
    \bii
    \ii<3-> Mit Bedingungen gibt es plötzlich \structure{mehrere Kontrolflüsse} durch das Programm
    \ii<4-> Variationen von Bedingungen: Wie viele Nachfolger? Wie wird ausgewählt?
    \eii

  \end{frame}

  \begin{frame}[t]{Die Selektion-Operation ist eine seltsame Operation}
    \vspace{-1.5em}
    \begin{columns}
      \begin{column}{0.49\textwidth}
        \centering
        \structure{Normale Operationen}
      \end{column}\hfill
      \begin{column}<5->{0.49\textwidth}
        \centering
        \structure{Selektion }
      \end{column}
    \end{columns}
    \begin{columns}
      \begin{column}{0.49\textwidth}
        \btAnimation[width=0.45\textwidth]{raisebox,center,padding,range=1-3:<1->,4:<4->}{fig/07-ite-ast}
      \end{column}\hfill
      \begin{column}<5->{0.49\textwidth}
        \btAnimation[width=0.7\textwidth]{raisebox,center,padding,range=5-6:<5->,7:<7->}{fig/07-ite-ast}
      \end{column}
    \end{columns}

    \begin{columns}[t]
      \begin{column}{0.49\textwidth}
        \bii
        \ii Operation hängt von \textbf{allen} Kinder ab
        \ii Kinder werden zuerst ausgeführt
        \ii Reihenfolge der Kinder nicht zwingend
        \eii
      \end{column}\hfill
      \begin{column}<5->{0.49\textwidth}
        \bii
        \ii Hängt \textbf{immer} von der Bedingung ab
        \ii Nur ein anderes Kind wird ausgeführt
        \ii Auswertung wird Daten-sensitiv
        \ii[$\Rightarrow$] \structure{hat programmierbare Abhängigkeit}\\[2ex]
        \eii
      \end{column}
    \end{columns}

    \begin{btBlock}<8>{}
      McCarthy (Erfinder von Lisp), 1960: \enquote{[...] but the notion of conditional expression is believed to be new, and the use of conditional expressions permits functions to be defined recursively in a new and convenient way.}
    \end{btBlock}
  \end{frame}
#+end_src

#+begin_src latex
  \begin{frame}{Rekursion: Invokation und Selektion}
    \begin{columns}[b]
      \begin{column}{0.49\textwidth}
        \includegraphics[width=\textwidth]{fig/07-rekursion}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \btAnimation[width=\textwidth]{2:<-2>,3:<3->}{fig/07-rekursion}
      \end{column}
    \end{columns}
    \medskip
    \bi
    \ii Rekursion ist das Zusammenspiel von Invokation und Selektion{
      \bi
      \ii \texttt{call} erlaubt uns Operationen mehrfach auszuführen
      \ii \texttt{ite} erlaubt uns die Invokation irgendwann auszulassen
      \ii Selbe Operation mit unterschiedlichen Daten auswerten ($\alpha_1, \alpha_2$,\ldots)
      \ei
    }\medskip
    \ii<2-> Warum macht das überhaupt Sinn? {
      \bi
      \ii \texttt{call} hat formt nicht nur den Kontrollfluss, sondern auch den Datenfluss!
      \ii Argumente \enquote{fließen} in die Call-Operation, Rückgabewerte hinaus\\[1ex]
      \ii Datenfluss trotz seiteneffekt-freier Operationen
      \ii[$\Rightarrow$] \texttt{call F1} ist eine \structure{Komplexoperation} (= zusammengesetzte Operation)
      \ei
    }
    \ei
  \end{frame}
#+end_src
** Iteration: Wiederholte Ausführung

#+begin_src latex
  \begin{frame}{Iteration: Dasselbe, immer wieder tun}
    \bi
    \ii Operationen in \structure{Schleifen} werden wiederholt ausgeführt {
      \bi
      \ii Nur Kontrollfluss-, \alert{keine Datenflusseigenschaften} ($\Leftrightarrow$ Invokation)
      \ii Selbe Operation, selbe Operanden, immer wieder auswerten.
      \ii Das macht \textbf{nur Sinn}, wenn die Operationen \textbf{Seiteneffekte} haben
      \ei
    }
    \ei

    \medskip
    \begin{columns}<2->
      \begin{column}{0.49\textwidth}\centering
        \includegraphics[page=1,height=0.33\textheight]{fig/07-loops}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \btAnimation[height=0.27\textheight]{2:<-2>,3:<3->}{fig/07-loops}
      \end{column}
    \end{columns}

    \medskip
    \bi
    \ii<4-> Wie oft wird der \structure{Schleifenkörper} (loop body) ausgewertet? {
      \bi
      \ii \structure{Logically-Controlled}: Wiederholung bis die Abbruchbedingung fehl schlägt
      \ii \structure{Enumeration-Controlled}: Wiederholung für jedes jedes Element einer Aufzählung
      \ei
    }
    \ei
  \end{frame}


  \begin{frame}[fragile]{Logically-Controlled Loops}
    \hspace{-1em}\vspace{-1.5em}\begin{columns}[t]
      \begin{column}{0.5\textwidth}
        \centering\structure{Test am Anfang}\\[1ex]
        \begin{code}[tag=C]
          \begin{C}
            while (cond) {
              stmt1;
              stmt2
            }
          \end{C}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \centering\structure{Test am Ende}\\[1ex]
        \begin{code}[tag=C]
          \begin{C}
            do {
              stmt1;
              stmt2
            } while (cond)
          \end{C}
        \end{code}
      \end{column}
    \end{columns}

    \medskip

    \bi
    \ii Logisch-kontrollierte Schleifen unterscheiden sich kaum {
      \bi
      \ii Liefert der Test ein \alert{negatives} Ergebnis, wird die Schleife \alert{abgebrochen}
      \ii Zeitpunkt des Tests: \textbf{Vor oder nach} jedem Durchlauf?
      \ei
    }\medskip
    \ii<2-> Komplexere Schleifentypen können in einfachere umgewandelt werden {
      \begin{columns}
        \begin{column}{0.4\textwidth}
          \begin{code}[tag=C]
            \begin{C}
              for (init; cond; next) {
                stmt1;
                stmt2;
              }
            \end{C}
          \end{code}
        \end{column}\hfill{\Large $\Rightarrow$}\hfill
        \begin{column}{0.4\textwidth}
          \begin{code}[tag=C]
            \begin{C}
              init;
              while(cond) {
                stmt1; stmt2;
                next;
              }
            \end{C}
          \end{code}
        \end{column}
      \end{columns}
    }\medskip
    \ii<3-> Spezialisierte \texttt{goto}-Befehle für Schleifen {
      \bi
      \ii \structure{\texttt{break}}: Sprung hinter die Schleife
      \ii \structure{\texttt{continue}}: Sprung ans Endes des Schleifenkörpers
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[fragile]{Enumeration-Controlled Loops}
    \begin{columns}
      \begin{column}{0.33\textwidth}
        \begin{code}[tag=C++]
          \begin{CPP}[style=smaller]
            std::vector<int> numbers;
          
            for (int elem : numbers) {
              stmt1; stmt2;
            }
          \end{CPP}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.33\textwidth}
        \begin{code}[tag=Python]
          \begin{py}[style=smaller]
            numbers = [23, 42, 65]
          
            for elem in numbers:
               stmt1
               stmt2
          \end{py}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.33\textwidth}
        \begin{code}[tag=Fortran]
          \begin{fortran}[style=smaller]
            ! [1, 3, 5, 7, 9]
            do i = 1, 10, 2
              stmt1;
              stmt2;
            end
          \end{fortran}
        \end{code}
      \end{column}
    \end{columns}

    \medskip
    \bi
    \ii \structure{Aufzählungsschleifen} iterieren über eine Aufzählung {
      \bi
      \ii Aufzählung liefert eine \structure{Sequenz von Objekten}
      \ii Für jedes Sequenz-Element wird der Schleifenkörper einmal ausgeführt
      \ii Aktuelles Element wird an eine lokale Variable \textbf{gebunden}
      \ei
    }
    \ei
    \pause
    \begin{center}\ttfamily
      enumerate(tree) $\rightarrow$ node, node, node, node,\ldots
    \end{center}
    \bi
    \ii Bei der Aufzählung muss man sich für eine Ordnung entscheiden{
      \bi
      \ii Vorgegeben bei Sequenzen/Listen und Arrays
      \ii Belibig bei ungeordneten Mengen (häufig: internen Datenstruktur)
      \ii Pre-, Post-, oder In-Order bei Bäumen
      \ei
    }
    \ei
  \end{frame}


  \begin{frame}[fragile]{Iteratoren und Generatoren}
    \bi
    \ii Aufzählungen können als eigenständige Objekte existieren{
      \bi
      \ii \structure{Iterator}: Ein Objekt auf dem man \texttt{next(obj)} ausführen kann
      \ii \structure{Generator}: Eine \structure{pausierte Funktionsinstanz} (Continuation)
      \ei
    }
    \ei

    \begin{columns}[t]
      \begin{column}<2->{0.49\textwidth}
        {\centering \structure{Iterator}\par}\smallskip
        \begin{code}[tag=Python]
          \lstinputlisting[style=py,linerange=s0-e0]{lst/07-iterator.py}
        \end{code}
      
      \end{column}\hfill
      \begin{column}<3->{0.49\textwidth}
        {\centering \structure{Generatoren}\par}\smallskip
        \begin{code}[tag=Python]
          \lstinputlisting[style=py,linerange=s1-e1]{lst/07-iterator.py}
        \end{code}

        \bii
        \ii \texttt{fib()} erzeugt Funktionsinstanz\\[0.5ex]
        \ii Bei jedem \texttt{next(it)}:{
          \bi
          \ii \textbf{Fortsetzung} bis \codeinline[style=py]{yield}
          \ii Generator liefert einen Wert
          \ii Funktion wird wieder pausiert 
          \ei
        }
        \eii
      \end{column}
    \end{columns}
  \end{frame}
#+end_src

* Vom Instruktionsstrom zum Kontrollflussgraphen

