#+TITLE: Programmiersprachen und Übersetzer
#+SUBTITLE: 07 - Operationen
#+SETUPFILE: setup.org
#+INCLUDE: export-prologue.org
#+PROPERTY: header-args:latex :tangle yes :noweb yes :tangle-macros yes :tangle-prologue topic :tangle-epilogue endtopic :exports none

#+NAME: topic
#+BEGIN_SRC latex :tangle no
\psuSectionStart{{{{property(ITEM)}}}}{{{{n(block)}}}}
#+END_SRC

#+NAME: endtopic
#+BEGIN_SRC latex :tangle no
\psuSectionStop{{{{property(ITEM)}}}}{{{{n(block,-)}}}}
#+END_SRC

* Gedanken zu dieser Vorlesung                                     :noexport:
- Expressions
  - Arithmetric
  - Relational
  - Zuweisung, L-Values, R-Values
- Kontrollfluss
  - Die sequentielle Maschine
  - Seiteneffekte & Ausführungsreihenfolge
  - Sequencing: Statements ung Goto
  - Invocation: call, return; Call-by-value, Call-by-ref
  - Selection (if, cond, case, Short-Circuit Semantic?)
  - Iteration (Logical-Controlled Loops, Enumeration-Controlled Loops, Iteratoren)
- Vom Instruktionsstrom zum Kontrollflussgraphen
  - Kontrollflussgraphen
  - Basisblöcke
  - Kontrollflussgraphen auf mehreren Ebenen

Effektiv:  Welche Werkzeuge habe ich den potentiellen Instruktionsstrom zu Formen?
Effizienz: Seiteneffekte 

* Was ist eine "Operation"?
:PROPERTIES:
:CUSTOM_ID: 07-einleitung
:END:

#+begin_src latex
  \subtitle{{{{subtitle()}}}}
  \begin{frame}
    \maketitle
  \end{frame}

  \begin{frame}{Einordnung in die Vorlesung: Operationen}
    \begin{center}
      \includegraphics[page=12,width=0.6\linewidth]{fig/01-overview-small}
    \end{center}
    \bi
    \ii Operation \alert{kombinieren Daten} und \alert{manipulieren Objekte} {
      \bi
      \ii Operationen hängen implizit und/oder explizit voneinander ab
      \ii Abbildung des virtuellen Operationsstrom auf die reale, sequentielle Maschine
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[t,fragile]{Was ist eine "Operation"?}
    \btAnimation{center,padding,1:<1->}{fig/07-operations}
    \bi
    \ii \textbf{Erinnerung 1. Vorlesung}: Maschinenmodell der virtuellen Maschine:{
      \bi
      \ii \structure{Speicher/Objekte}: Wie kann man Informationen ablegen und wieder abrufen?
      \ii \structure{Befehle/Operationen}: Wie kann man Informationen miteinander kombinieren?
      \ei
    }\medskip
    \ii Operationen sind Aktiv $\leftrightarrow$ Objekte sind Passiv {
      \bi
      \ii \structure{Quelloperanden}: Eingabeobjekte, die von der Operation gelesen werden.
      \ii \structure{Abbildungsvorschrift}: Kombinationsregel für die gelesenen Daten.
      \ii \structure{Zieloperanden}: Ausgabeobjekt nimmt das Rechenergebnis auf
      \ei
    }
    \ii[]<2->{
    \begin{code}
      \begin{codetext}[style=smaller]
        Operation: "+"
          Quelloperand: LHS (Typ: 32-Bit Integer), RHS (Typ: 32-Bit Integer)
          Zieloperand:  ret (Typ: 32-Bit Integer)
          Abbildungsvorschrift: 
             L   = eval(LHS) // Linke Seite auswerten
             R   = eval(RHS) // Rechte Seite auswerten
             ret = modulo(add(L, R), 32)
       \end{codetext}
     \end{code}
   }\ei
  \end{frame}

#+end_src

In dieser Vorlesung widmen wir uns wieder einem der essentiellen Konzepten von Programmiersprachen:
*Operationen*.
Im Rahmen unserer Betrachtungen, sind die Operationen der letzte Baustein um verschiedenste Programmiersprachen und Programmierparadigmen einheitlich fassen zu können.
Für ihr geistiges Modell: Denken sie sich zunächst bei "Operation" einfach "Addition". Wir werden später auf komplexere Operationen kommen.

So wie Typen und Namen ein zusammengehöriges Konzeptpaar sind (beide werden in der semantischen Analyse verbunden), so gehören auch Objekte und Operationen zusammen; sie sind zwei Seiten der Medaille "Laufzeitverhalten" des Programms.
Wo Objekte die passiven Träger der Information sind, sind die Operationen die aktiven Verarbeiter dieser Informationen.
Um bei der Addition zu bleiben: Die Objekte ~2~ und die ~3~ werden von der Operation "Addition" auf das Objekt ~5~ abgebildet.

Für die Einordnung in die Vorlesung müssen Sie sich vor Augen führen, wie eng "Operationen" mit Übersetzern zusammenhängen:
In der ersten Vorlesung habe ich ihnen das geschichtete Maschinenmodell näher gebracht.
Dort haben wir gesagt, dass es für jede Ebene ein virtuelles Maschinenmodell, als eine Kombination aus Objekten und Operationen, gibt.
Ein Programm für dieses Maschinenmodell, ist eine, von uns mühsam erarbeitete, Ansammlung von Operationen, welche auf den Objekten ausgeführt werden soll.
Der Übersetzer, als ein Prozessor dieser Programme, nimmt diese virtuellen Operationen und bildet sie auf Operationen der darunter-liegende Schicht ab.
Da unsere real-existierenden Maschinen sequentiell sind, bedeutet das für Programmiersprachen-Übersetzer, dass wir die im AST angeordneten Operationen in einen (hauptsächlich linearen) Strom von realen Operationen abbilden müssen.

Aber zurück zu den Operationen selbst.
Diese können wir über ihre Schnittstelle und ihre Verhalten beschreiben.
An der Schnittstelle hat jede Operation *Quelloperanden* und *Zieloperanden*, aus denen bzw.
in welche die verarbeiteten Daten fließen.
Da in unserem Modell alle Informationen in Objekt gespeichert werden, sind die Operanden Objekte, welche Daten liefern bzw.
aufnehmen.
Wenn es so aussieht, als würden Daten direkt zwischen zwei Operationen fließen, wie dies auf den Folien zwischen Addition und Zuweisung der Fall ist, so ist eigentlich ein implizites *temporäres Objekt* zwischengeschaltet, welches wir nur (normalerweise) der Übersichtlichkeit halber weg lassen. 

Das Verhalten einer Operation zu fassen ist deutlich schwieriger als ihre Schnittstelle zu beschreiben.
Eine Möglichkeit ist es eine Abbildungsvorschrift anzugeben, welche die Eingabedaten auf die gewünschte Ausgabe abbildet.
Im Beispiel beschreiben wir die 32-Bit Addition so:
Die Addition wertet zuerst ihre beiden Quelloperanden (LHS, RHS) aus, um an die darin enthaltenen Informationen (L, R) zu kommen.
Diese beiden Zahlen addieren wir mit der Ganzzahl-Addition und beschneiden das Ergebnis auf 32-Bit mit der Modulo Operation. Das Ergebnis wird dem Zieloperanden zugewiesen.

Im Folgenden werden wir uns nicht weiter mit Abbildungsvorschriften beschäftigen und uns auf eine informale, eher gefühlte, Verhaltensbeschreibung verlassen.
Allerdings möchte ich noch erwähnen, dass formale Beschreibungen von Operationen eine wichtige Rolle bei der Verifikation von Hard- und Software sind, da wir dort ganz genau erfassen müssen, was eigentlich das Verhalten einer Operation ist.
Nur so kann man bei der formalen Verifikation eines Programms zeigen, dass die Komposition mehrerer Operationen das gewünschte Verhalten zeigt.
Sollten Sie etwas neugierig auf diesen Aspekt sein, kann ich ihnen das Papier zu Beschreibungssprache [[https://www.cl.cam.ac.uk/~pes20/sail/][SAIL]] auf der POPL 2019 [[http://dx.doi.org/10.1145/3290384]["ISA Semantics for ARMv8-A, RISC-V and CHERI-MIPS"]] von Armstrong et. al. empfehlen.


* Operationen und Seiteneffekte
:PROPERTIES:
:CUSTOM_ID: 07-operation-dependencies
:END:

  #+begin_src latex
  \dividerframe{Einfache\\Operationen}
  \begin{frame}[fragile]{Arithmetische, Bit-weise und logische Operationen}
    \begin{center}
      {\Large \verb!+ - * / %     ~ & | ^ << >>  < <= == => >!}
      \OrangeBox<2-|handout:2>{Notation, Vorrang und Assoziativität wird vom Parser aufgelöst.}
    \end{center}
    \def\op{\textit{op}}
    \def\codebox#1{\Colorbox{codecolor}{\scriptsize\texttt #1}}
    \setbeamercovered{still covered={\opaqueness<1->{0}},again covered={\opaqueness<1->{30}}}
    \bi
    \ii<-2|handout:1> \structure{Notationen} in unterschiedlichen Sprachen {
      \bi
      \ii Prefix: \codebox{\op{} A B} oder \codebox{\op(A,B)} oder \codebox{(\op{} A B)} \hfill Lisp, Scheme
      \ii Infix:  \codebox{A \op{} B}  \hfill C, C++, Java, \ldots
      \ii Postfix: \codebox{A B \op}   \hfill Forth, PostFix
      \ei
    }\medskip
    \ii<-2|handout:1> \structure{Vorrang} (Precedence): Bindet Multiplikation stärker als Addition?\\{
      \codebox{1*2+3*4} $\rightarrow$ \btSetNamedTab{\first}\codebox{(1*2)+(3*4)} (14) \hspace{1em} \btSetNamedTab{\second} $\vee$ \hspace{1em}  \codebox{1*(2+3)*4} (20)
    }\medskip
    \ii<-2|handout:1> \structure{Assoziativität}: Wird links oder rechts geklammert? \\{
       \codebox{1-2-3-4} $\rightarrow$ \first\codebox{(((1-2)-3)-4)} (-8)  \second $\vee$\hspace{1em} \codebox{1-(2-(3-4))} (-2)
     }
    \ei
    \bi
    \ii<3-|handout:2> \ALERT{Wichtige} Eigenschaften dieser Operationen {
      \bi
      \ii Quelloperanden werden \alert{alle ausgewertet, bevor} die Operation ausgeführt wird
      \ii Keine \structure{Seiteneffekte} und genau ein \structure{temporäres Objekt} als Zieloperand
      \ei
    }
    \ei
  \end{frame}
#+end_src


Zunächst beschäftigen wir uns mit *arithmetische, bit-weise und logische Operationen*, die in allen Programmiersprachen auftauchen, da wir ansonsten nichts ausrechnen können.
Sie sind gewissermaßen die Brot- und Butteroperationen bei denen man nichts aufregendes erwarten darf.
Sie haben einen (*unäre Operationen*) oder zwei (*binäre Operationen*) Quelloperanden und ein *tempräres Objekt* als Zieloperand.
Für Ihre Schnittstelle und ihr Verhalten sind, nebst einiger kleiner Abweichungen, in allen Sprachen gleich und es gibt nur bei der Notation Unterschiede.


Bei der Notation dieser "einfachen" Operationen gibt es drei Aspekte die wichtig sind: Wo steht die Operation in Verhältnis zu ihren Operanden? Welchen *Vorrang* hat diese Operation über andere Operationen beim Parsen? Und wird eine ungeklammerte Aneinanderreihung dieser Operationen Links- oder Rechts-Assoziativ geparst?
All diese Fragen sind wichtig für die Syntax, werden aber vollständig von der Grammatik und vom Parser behandelt. Im AST sind all diese Fragen der Notation bereits geklärt und wir müssen uns nicht näher damit beschäftigen.

Ich möchte nur noch kurz auf das "Wo steht die Operation" eingehen.
Die meisten Programmiersprachen verwenden für die binären Operationen die Infix-Notation (~2+3~), da diese für Menschen natürlicher und leichter lesbar ist.
Bei den unären Operationen verwendet man meist die Prefix-Notation (~!cond~, ~(-x)~).

Da die notationellen Besonderheiten vom Parser aufgelöst werden, sind diese "einfachen" Operationen im Grunde langweilig.
Aber es gibt zwei Aspekte, die dann wichtig werden, wenn wir Operationen behandeln, die sich anders verhalten.
Zum einen werten die einfachen Operationen all ihre Operanden aus, bevor sie selbst zur Tat schreiten.
Zum anderen haben die einfachen Operationen *keine Seiteneffekte* über ihr temporäres Zielobjekt hinaus.
Verwerfen wir dieses temporäre Objekt, so hat eine Seiteneffekt-freie Operation keinen dauerhaften Einfluss auf den Zustand der Maschine.

#+begin_src latex
\begin{frame}{Auswertungsreihenfolge von einfachen Operationen}
    \bi
    \ii Semantische Lücke zwischen virtueller und realer Maschine {
      \bi
      \ii Operationen auf Sprachebene sind als (expliziter oder impliziter) Baum notiert
      \ii Alle realen Maschinen sind \structure{Sequentielle Maschinen}\smallskip
      \ei
    }
    \ei
    \begin{btBlock}{Auswertungsreihenfolge}
      Abbildung der Operationen des ASTs auf eine lineare Befehlssequenz.
    \end{btBlock}

    \begin{columns}<2->
      \begin{column}{0.3\textwidth}
        \includegraphics[width=\textwidth,page=1]{fig/07-simple-expr}
      \end{column}\hfill
      \begin{column}{0.69\textwidth}
        \bii
        \ii \enquote{Links nach Rechts}      \hfill\btImage[baseline,anchor=west,text width=3.5cm,opts={page=3}]{fig/07-simple-expr}
        \ii \enquote{Rechts nach Links}      \hfill\btImage[baseline,anchor=west,text width=3.5cm,opts={page=4}]{fig/07-simple-expr}
        \ii \enquote{Beliebiges Kind zuerst}:\hfill\btImage[baseline,anchor=west,text width=3.5cm,opts={page=5}]{fig/07-simple-expr}
        \eii
      \end{column}
    \end{columns}
  \end{frame}

  \begin{frame}{Abhängigkeiten zwischen Operationen}
    \begin{columns}
      \begin{column}{0.49\textwidth}
        \centering
        \includegraphics[height=2cm,page=2]{fig/07-simple-expr}
        \par
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \btAnimation[width=\textwidth,page=6]{range=6-7:<1->,8:<3->}{fig/07-simple-expr}
      \end{column}
    \end{columns}
    \medskip

    \bi
    \ii \structure{Abhängigkeit}: Eine Operationen hängt vom Ergebnis einer anderen ab{
      \bi
      \ii Abhängige Operationen müssen zuerst ausgewertet werden
      \ii Bei der Auswertungsreihenfolge: Keine Abhängigkeiten in die Zukunft
      \ii AST definiert hierarchische Abhängigkeiten zwischen Eltern und Kind
      \ei
    }\medskip
    \ii<3-> \advantage{\textbf{Freiheiten}} in der Auswertungsreihenfolge {
      \bi
      \ii Haben Operationen keine Abhängigkeit ist ihre Reihenfolge \textbf{\advantage{beliebig}}
      \ii[$\Rightarrow$] Übersetzer kann Reihenfolge frei wählen um Ausführung zu optimieren\\
         z.B: Weniger Speicherlatenz durch Einschieben von unabhängigen Operationen
      \ei
    }
    \ei

    \begin{btBlock}<4->{}\small
      Viele Sprachkonstrukte und -regeln erlauben es uns die \textbf{Auswertungsreihenfolge zu formen}, um die Abhängigkeiten explizit zu machen.
    \end{btBlock}

  \end{frame}
#+end_src

Ein Programm besteht aus einer Menge an Operationen die in mit Hilfe der Sprachkonstrukte in eine logisch Beziehung (z.B.
wenn-dies-dann-das) zueinander gesetzt werden.
Die Extraktion dieser Strukturen ist das Parsen, welches den Abstrakte Syntaxbaum produziert.
Jetzt haben wir bei der Übersetzung allerdings das Problem, dass die realen Maschinen keinen Baum abarbeiten können.
Was wir haben sind sequentielle Maschinen, deren CPUs in einem einzelnen Zyklus genau eine Operation ausführen können.
Wir müssen daher die Baumstruktur des ASTs *flachklopfen* um eine linearisierte Befehlssequenz zu erhalten, die wir mit unserem x86 oder ARM Prozessor ausführen können.

Aber welche *Auswertungsreihenfolge* der Baumknoten sollen wir wählen?
Auf der Folie sehen wir 4 Operationen mit insgesamt 5 Operanden, die in einem AST angeordnet sind.
Auf der rechten Seite sehen wir 3 verschiedene Auswertungsreihenfolgen für die wir uns entscheiden können, diesen AST auf eine sequentielle Maschine abzubilden.
Wir könnten uns zum Beispiel dazu entscheiden, die Kinder von ~*~ von links nach rechts, von rechts nach links oder irgendwie gemischt ab zu arbeiten, bevor wir mit den gesammelten Ergebnissen die Multiplikation durchführen.
Diese drei Varianten sind alle valide und bei den meisten Sprachen kann der Übersetzer die Auswertereihenfolge der Kinder frei bestimmen[fn::Java ist hier eine Aufnahme, dort wird immer strikt von links nach rechts ausgewertet.].
Diese Freiheit erlaubt dem Übersetzer eine Sequenz zu wählen, die von der CPU am schnellsten abgearbeitet wird.
Generell gilt, dass Freiheiten bei der Auswertungsreihenfolge dem Übersetzer Möglichkeiten zur Optimierung an die Hand gibt; nur so kann er Operationen zusammenfassen und verschieben.

Allerdings sind nicht alle Linearisierungen dieses Baums ein valides Programm.
Bei den genannten dreien haben wir immer eine Post-Fix Besuchsreihenfolge angenommen, bei der die Kinder zuerst ausgewertet werden.
Aber was würde eigentlich passieren, wenn wir die Multiplikation vor den drei Kind-Operationen ausführen wollen würden?
Kurz gesagt: Das geht nicht bzw. es geht halt kaputt, weil die Multiplikation das Ergebnis der Addition, der Negation und des Bit-Shifts braucht.
Wenn wir diese, etwas Umgangssprachlich umschriebene Situation etwas gewählter ausdrücken wollen würden, würden wir sagen: /"Die Multiplikation ist abhängig vom Ergebnis der Addition"/.
Da real-existierende sequentielle Maschinen *nicht* in die Zukunft blicken können[fn::Wie schön wäre es doch nicht-deterministische Turing-Maschinen zu haben, die da viel flexibler sind.], folgt daraus direkt, dass die Addition vor der Multiplikation ausgeführt werden muss.

Für die einfachen Operationen (arithmetisch, bit-weise, logisch) sind die Abhängigkeiten ganz einfach:
Die Operation hängt von ihren jeweiligen Kindern ab, diese müssen also vorher ausgewertet werden; wir haben eine streng hierarchische Struktur von Abhängigkeiten.
Wir werden im folgenden Unterkapitel Sprachkonstrukte kennen lernen, mit denen wir die Ausführungsreihenfolge über diese hierarchische Struktur hinaus formen können.
Zum Beispiel indem wir sagen: Diese zwei Operationen müssen immer in dieser Reihenfolge ausgeführt werden (Sequenzierung:
~op1 ; op2~).


#+begin_src latex
  \begin{frame}{Die Zuweisungs-Operation (\texttt{:=})}
    \bi
    \ii Auswertung der rechten Seite $\rightarrow$ Ergebnis in der linken Seite speichern{
      \bi
      \ii Linke und rechte Seite werden \alert{nicht} symmetrisch übersetzt!
      \ii \structure{R-Wert}: Auf der rechten Seite berechnen wir das Ergebnis eines Ausdrucks
      \ii \structure{L-Wert}: Auf der linken Seite muss berechnet werden wohin das Ergebnis soll
      \ei
      \btAnimation[height=1.5cm]{center,padding,1:<1->}{fig/07-lvalue}
    }
    \ii<2-> Nicht jede Operation hat einen L-Wert{
      \bi
      \ii Konstanten (\codebox{1}, \codebox{"abc"}) haben keinen L-Wert\hfill\codebox{1   := 2}
      \ii Temporäre Zwischenergebnisse haben keinen L-Wert             \hfill\codebox{a+b := 2}
      \ei
    }
    \ii<3-> Unterschied bei L-Werten zwischen Werte- und Referenzmodell{
      \bi
      \ii \structure{Referenzmodell}: Alles was eine Referenz speichern kann ist ein L-Wert\\
          Variablen, Array-Elemente und Felder.\\[0.5ex]
      \ii \structure{Wertemodell}: Alles was ein Objekt speichern kann ist ein L-Wert\\
          zusätzlich: Dereferenzierung: \codebox{*(ptr)}
      \ei
    }
    \ei
  \end{frame}
  #+end_src


Eine Operation, bei der die Abhängigkeiten nicht so einfach sind, ist die *Zuweisungs-Operation*, für die ich hier die Notation ~:=~ verwende um eine deutliche Unterscheidung zur Vergleichs-Operation ~==~ zu machen.
Ziel einer Zuweisung ist das Ergebnis einer Berechnung einer Variable, oder einem Objekt, zuzuweisen.
Dafür hat die Zuweisungs-Operation zwei Operanden (rechte Seite/RHS und linke Seite/LHS) in denen sich die Asymmetrie des Informationsflusses wieder spiegelt.
Die rechte Seite wird ausgewertet und dann der linken Seite zugewiesen. 

Aus diese Asymmetrie folgt auch, dass die beiden Operanden auf unterschiedliche Weisen ausgewertet werden müssen[fn::Dies wird wichtig beim Übersetzerbau]. 
Die rechte Seite wird als *R-Wert* (rvalue) ausgewertet, was bedeutet dass wir uns nur für das Ergebnis der Rechnung interessieren, unabhängig davon wie und wo dieses gespeichert wird.
Die linke Seite wird als *L-Wert* (lvalue) ausgewertet. Dabei ist unser Ziel eine Speicheradresse zu erfahren, an die wir das Ergebnis ablegen sollen.
Im Beispiel ~a := b~, wollen beim Auswerten der Variable ~b~ (als R-Wert) wissen was ihr Inhalt ist, beim Auswerten der Variable ~a~ (als L-Value) geht es um die Speicheradresse der Variable. 
Gehen Sie noch einmal in sich, und wiederholen Sie: *"Zuweisungen werten ihre beiden Operanden asymmetrisch aus, bei der rechten Seite interessiert uns der Wert, bei der Linken ein Zielort für das Ergebnis"*.

Die Unterscheidung beider Auswertungsarten wird noch deutlicher, wenn wir uns anschauen, dass nicht jede Operation/jeder Operand einen L-Wert hat:
So haben Literale keinen L-Wert, da sie nicht wirklich an einem Ort gespeichert werden. Weisen wir einen C-Übersetzer an den Ausdruck ~1 = 2~ zu Übersetzen, so bekommen wir die Fehlermeldung /"error: lvalue required as left operand of assignment"/ um die Ohren gehauen. Und zurecht! Denn was sollte es denn bedeuten, wenn wir dem Literal 1 den Wert 2 zuweisen? Sollen ab jetzt alle Einsen im Programm zur Zwei werden? 

Die selbe Fehlermeldung über einen fehlenden L-Wert bekommen wir, wenn wir einem temporären Ergebnisobjekt einer einfachen Operation etwas zuweisen wollen (~(a + b) = c~).
Wir können für den Ausdruck ~a + b~ keine sinnvolle Antwort darauf geben, wo der Speicher des Ergebnisses liegt.
Selbst wenn linke und rechte Seite vom typkompatibel sind, so hätte der Programmierer nichts davon, wenn dem temprären Objekt der Wert von c zugewiesen wird; es gibt keine Möglichkeit darauf später zuzugreifen.

Welche Operationen als L-Wert ausgewertet werden können ist sprachabhängig.
Der größte Unterschied in dieser Frage kommt aus der Entscheidung über Referenz- oder Wertemodell für Variablen.
Beim *Referenzmodell für Variablen* gibt es keine separaten Zeiger- bzw.
Referenzobjekte, die dem Benutzer zugänglich sind.
Daher können nur Variablen, Feld-Zugriffe und Array-Zugriffe als L-Wert ausgewertet werden.
Beim *Wertemodell* kommt zu diesen L-Werten noch die *Derefenzierung* hinzu.
Während wir auf der rechten Seite dem Zeiger hinterherlaufen um den Wert aus zu lesen, schreiben wir auf der linken Seite an genau die diese Stelle das Ergebnis. 

#+begin_src latex
  \begin{frame}<handout:2,3>{Seiteneffekte und Idempotenz}
    \begin{btBlock}{}
      Die Zuweisungs-Operation hat den gewollten \structure{Seiteneffekt} den Zustand der virtuellen Maschine zu verändern.
    \end{btBlock}

    \bi
    \ii \structure{Seiteneffekte}: Wirkung über ein temporäres Zielobjekt hinaus {
      \bi
      \ii Operationen sind nicht mehr \structure{idempodent}\hfill \codebox{i := i + 1}
      \ii Nur beobachtbare Seiteneffekte sind ein Problem (seiteneffektfreie Funktion)
      \ii Strikt-Funktionale Sprachen (Haskell): Verbot jeglicher Seiteneffekte 
      \ei
    }\medskip
    \ii<2-> Wer sich auf Seiteneffekte verlässt erzeugt eine implizite Abhängigkeit.\\[0.5ex]{
     \begin{columns}
       \begin{column}{0.27\textwidth}
         \btAnimation[width=\textwidth] {padding,center,1:<-2>,2:<3->}{fig/07-side-effect}
       \end{column}\hfill
       \begin{column}{0.7\textwidth}
         \bi
         \ii Das Ergebnis von \codebox{(a := 2) + (b := a)} hängt von der Auswertungsreihenfolge ab
         \ii Ohne strikt-definierte Auswertungsreihenfolge ist das Ergebnis \ALERT{undefiniert}!
         \ii Sprachregeln und -konstrukte \textbf{vermeiden} implizite Abhängigkeiten oder \textbf{machen sie explizit}.
         \ei
       \end{column}
     \end{columns}
   }
   \ei
  \end{frame}
#+end_src

Das mit der Asymmetrie zwischen linker und rechter Seite ist schon diffizil, aber es kommt noch schlimmer!
Denn die Zuweisung-Operation ist der Inbegriff der *Seiteneffekt-behafteten Operation*.
Wir führen Zuweisungen ja sogar ausschließlich wegen ihrer Seiteneffekte aus!
Wir wollen den Zustand der virtuellen Maschine mit der Zuweisung ja ganz explizit verändern.

Ich habe bereits angedeutet, dass eine Operation dann frei von Seiteneffekten ist, wenn sie ausschließlich einen temporäres Zielobjekt verändern.
Wenn wir den gesamten Zustand der Maschine vor und nach der einer seiteneffektfreien Operation vergleichen, so gibt kommt nur ein einzelnes temporäres Ergebnisobjekt hinzu, der Rest des Speichers bleibt unverändert.
Verwerfen wir das Ergebnis ist es als wäre nie etwas passiert. Dies bedeutet auch, dass wir die Operation immer und immer wieder direkt hintereinander ausführen können ohne das es zu einem anderen Ergebnis kommt; seiteneffektfreie Operationen sind immer *idempotent*.

Ganz anderes sieht das bei Operationen mit Seiteneffekten aus.
Dort wird nicht nur ein Ergebnis erzeugt, sondern der Speicher der Maschine verändert.
Bei einer Zuweisung verändert sich der Informationsgehalt eines bereits vorher existierenden Objekts dauerhaft.
Weisen wir der Variable a den Wert ~2~ zu, so wird der aktuelle Inhalt der Variable überschrieben (Informationsverlust!) und ist ab sofort, bis zur nächsten Zuweisung, 2. 
Kommen in diese Situation noch Zeiger hinzu (Wertemodell!), so können Zuweisungen (~*ptr = 4~) schnell zu "magischen Fernwirkungen" kommen[fn:: Einstein hat die Quantentheorie damit abgelehnt, dass die "Spooky Actions at a Distance" die Relativitätstheorie verletzen würden. Tatsächlich tun Quanteneffekte dies allerdings nicht, da sie keine Informationen übertragen können.].
Daher gibt es Programmiersprachen, die keine bzw. fast keine Operationen mit Seiteneffekten anbieten (z.B. Haskell). Dort findet der gesamte Informationsfluss über temporäre Zieloperanden statt. Haskell kennt keine Zuweisungen!

Mit den Seiteneffekten der Zuweisung wird auch unsere Auswertungsreihenfolge schwieriger. Denn was passiert, wenn die Auswertung eines Operanden einen Seiteneffekt hat, auf den sich der andere Operand verlässt. In diesem Fall sollte der Übersetzer die Operanden tunlichst in der richtigen Reihenfolge auswerten, da ansonsten eine Verletzung der Abhängigkeiten vorliegt und das Programm nicht korrekt arbeitet.

Im Beispiel sehen wir das zwei Zuweisungs-Operationen als Operanden für eine Addition benutzt werden.
Semantisch bedeutet dies, dass die rechte Seite nicht nur der linken Seite zugewiesen wird, sondern zusätzlich als temporäres Objekt nach oben zur Addition fließt.
Im Beispiel von ~(a := 2) + (b := a)~ kommt es zu gänzlich unterschiedlichen Ergebnissen wenn wir von links nach rechts oder von rechts nach links auswerten.
Gibt die Sprache keine strikte Auswertereihenfolge vor, so können wir auch garnicht wissen für welche Variante sich der Übersetzer entscheiden wird und das Ergebnis des Programms wird *undefiniert*!

Im folgenden werden wir Sprachkonstrukte kennen lernen, die es uns erlauben ein Programm so auf zu notieren, dass es nicht zu solche Uneindeutigkeiten kommt und dass die Auswertung des Programms entweder das eine (~a := 2; b := a~) oder das andere (~b := a; a := 2~) hat.
Wir lösen die impliziten Abhängigkeiten auf, indem wir eine feste Ausführungsreihenfolge vorgegeben.


* Sprachkonstrukte zur Kontrolle der Auswertungsreihenfolge
:PROPERTIES:
:CUSTOM_ID: 07-control-flow-constructs
:END:

#+begin_src latex
\dividerframe{Kontrolle über die Auswertungsreihenfolge}
  \begin{frame}{Umgang mit impliziten Abhängigkeiten}
    \begin{center}
      \btAnimation[height=2.5cm]{padding,range=1-3:<1->,4:<4->}{fig/07-dependency-model}
    \end{center}
    \medskip
  
    \bi
    \ii \textbf{Ausgangspunkt} und geistiges Modell für die folgenden Folien {
      \bi
      \ii<2-> \textbf{Gegeben}: Menge von Operationen mit Seiteneffekten \hfill($\alpha, \beta,\gamma, \ldots$)
      \ii<3-> Die Operationen hängen implizit voneinander ab             \hfill (gestrichelt)
      \ii<4-> Sprachmittel geben Reihenfolge und Vorrang explizit vor    \hfill(durchgezogen)
      \ii<5->  \textbf{Ziel}: \btSetTab Eine wohldefinierte Auswertungsreihenfolge, welche die\\
                              \btUseTab Abhängigkeiten erfüllt\\[2ex]
      \begin{center}
        \includegraphics[height=2cm,page=5]{fig/07-dependency-model}
      \end{center}
      \ei
    }
    \ei
  
  \end{frame}
#+end_src
** Sequenzierung: Statements und Goto
:PROPERTIES:
:CUSTOM_ID: 07-sequencing
:END:
#+begin_src latex
  \begin{frame}[fragile]{Sequenzierung: Statements}
    \bi
    \ii \structure{Sequenzierung}: Vorgabe einer linearen, strikten Reihenfolge {
      \bi
      \ii Der Sequenzoperator (\codebox{;}) führt seine Kinder hintereinander aus
      \ii Die Operanden des Sequenzoperators heißen \structure{Statements}
      \ii Ergebnisse werden verworfen oder das erste/letzte wird zurückgegeben
      \ei
    }
    \ii<2-> Statements sind das grundlegende Sprachmittel in imperativen Sprachen\\[1ex] {
      \btAnimation{center,padding,1:<1->}{fig/07-statements}
    }
    \ei

    \begin{columns}<3->
      \begin{column}{0.49\textwidth}
        \begin{code}[tag=C]
          \begin{C}
            int a, b;
            void foo() {
              a = 1; a++; b = (a+=4, a * 3);
            } // b == 18
          \end{C}
        \end{code}
        \structure{C/C++}
        \bii
        \ii Sequenzierung: Komma, Semikolon
        \ii \texttt{$\alpha$;$\beta$} hat kein Ergebnis
        \ii \texttt{$\alpha$,$\beta$} liefert letztes Teilergebnis ($\beta$)
        \eii
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \begin{code}[tag=Ruby]
          \begin{ruby}
            a = (1+2 ; begin
                  x = 1 + 2
                  x * 3
                end + 1) # a == 10
          \end{ruby}
        \end{code}
        \structure{Ruby}
        \bii
        \ii Sequenzierung: \texttt{'\textbackslash n'}, Semikolon
        \ii Letztes Statement liefert  den Rückggabewert
        \eii
      \end{column}
    \end{columns}
  \end{frame}

  \begin{frame}[fragile]{Unterscheidung zwischen Expressions und Statements}
    \OrangeBox{Die meisten Sprachen treffen diese Unterscheidung}\medskip

    \bi
    \ii \structure{Ausdrücke/Expressions} {
      \bi
      \ii Haben einen Rückgabewert
      \ii Haben einen Rückggabetypen (bei statischer Typisierung)
      \ii Können Operanden anderer Expressions sein
      \ei
    }\medskip
    \ii \structure{Statements} {
      \bi
      \ii Haben keinen Rückggabewert und daher auch keinen Typen
      \ii Dienen als Elemente der Sequenzierung und anderer Programmstrukturen
      \ii Entsprechen (in etwa) einer Zeile Code
      \ii Werden in Code-Blöcken bzw. Compound-Statements zusammengefasst.
      \ei
    }\medskip
    \ii<2-> Manche Operationen haben eine Expression- und eine Statement-Form\\
    C: \codeinline{if (cond) { then_block } else { else_block}}\hfill%
    \codeinline{ cond ? then_expr : else_expr}

    
    \ei
  \end{frame}
#+end_src

#+begin_src latex
  \begin{frame}{Sequenzierung: Goto}
    \bi
    \ii Ein \structure{unbedingter Sprung} verbindet syntaktisch entfernte Statements {
      \bi
      \ii \structure{Sprungmarke}: Gibt einer Operation einen Namen
      \ii \structure{Sprung}: \btSetTab Auswertung wird an dieser Stelle \alert{abgebrochen} und an der\\
                              \btUseTab genannten Sprungmarke fortgesetzt.
      \ei
    }
    \ei
    \medskip
    \begin{columns}
      \begin{column}{0.40\textwidth}
        \centering\includegraphics[width=0.8\textwidth,page=1]{fig/07-goto}\par
      \end{column}\hfill
      \begin{column}{0.59\textwidth}
        \btAnimation[width=\textwidth]{range=2-4:<1->,5:<3->}{fig/07-goto}
      \end{column}
    \end{columns}
    \medskip

    \bi
    \ii<5-> Nachfolge-Operation einer Operation wird explizit und statisch benannt {
      \bi
      \ii Sprünge erlauben es Sequenzen zusammen zu stückeln
      \ii (Endlos laufende) Schleifen sind nun möglich \hfill \textit{Rückwärtssprünge}
      \ei
    }
    \ei

    \begin{btBlock}<6->{Definition: Kontrollfluss \hfill \textit{(vgl. mit Kontrollwerk der CPU)}}
      Ein Kontrollfluss ist eine \textbf{konkrete} Sequenz von Operationen, die hintereinander ausgeführt werden.
    \end{btBlock}

  \end{frame}
#+end_src
** Invokation: Funktionsaufrufe
:PROPERTIES:
:CUSTOM_ID: 07-invocation
:END:
#+begin_src latex
  \begin{frame}{Invokation: Funktionsaufrufe}
    \bi
    \ii Kontrollfluss-Brille: Sprung und Funktionsaufruf sind sehr ähnlich.{
      \bi
      \ii Der Kontrollfluss verlässt die aktuelle Operations-Sequenz
      \ii Die Auswertung wird an einer entfernten, benannten Operation fortgesetzt
      \ei
    }\smallskip
    \ii<2-> \textbf{Aber}: Funktionsaufrufe haben zwei \structure{grundlegende Erweiterungen} {
      \bi
      \ii \structure{Rücksprung}: \btSetTab Wir können von verschiedenen Stellen angesprungen werden und \\
                                  \btUseTab zur jeweiligen verlassenen Operations-Sequenz zurückkehren.
      \ii \structure{Argumente}: Wir können Daten an den Kontrollfluss heften
      \ei
    }
    \ei
    \bigskip
    \begin{columns}<3->
      \begin{column}{0.40\textwidth}
        \centering\includegraphics[width=0.8\textwidth,page=1]{fig/07-call}\par
      \end{column}\hfill
      \begin{column}{0.59\textwidth}
        \btAnimation[width=\textwidth]{2:<-3>, 3:<4>, 4:<5>,5:<6->}{fig/07-call}
      \end{column}
    \end{columns}
  \end{frame}


  \begin{frame}[fragile]{Teilfazit: Sequenzierung und Invokation}
    \begin{columns} 
      \begin{column}{0.3\textwidth}
        \begin{code}\ttfamily\small
        F1:\,\btSetNamedTab{\X}$\alpha$;\\
            \X \textbf{goto} L1;\\
        L2: \X $\gamma$;\\
            \X \textbf{call} F2;\\
            \X $\omega$;\\
            \X \textbf{goto} F1;\\
        L1: \X $\beta$;\\
            \X \textbf{goto} L2;\\
        F2: \X $\delta$;\\
            \X \textbf{return};\\[1ex]
        \end{code}\\
        \medskip
        \includegraphics[page=6,width=\textwidth]{fig/07-call}
      \end{column}\hfill
      \begin{column}<2->{0.65\textwidth}
        \btUseExtraItemSep[2ex]
        \bi
        \ii Übersichtlichkeit von Code{
          \bi
        \ii Sprungmarken, Sprünge und der Aufruf von Labels werden schnell unübersichtlich.
        \ii Dijkstra, 1968: \enquote{GOTO considered harmful}
        \ii Manche argumentieren, dass goto einen Anwendungsfall bei der Fehlerbehandlung hat (z.B. Linus Torvalds)
        \ii<3->[$\Rightarrow$] \structure{Funktionen mit Blockstruktur}, Sprünge nur selten:
        % 
        \begin{columns}
          \begin{column}{0.45\textwidth}
            \begin{code}[]
              \begin{C}[escapechar=!]
                void F1() {
                  !$\alpha$!; !$\beta$! ; F2() ; $\omega$
                }
              \end{C}
            \end{code}
          \end{column}\hfill
          \begin{column}{0.45\textwidth}
            \begin{code}
              \begin{C}[escapechar=!]
                void F2() {
                  !$\gamma$!; 
                }
              \end{C}
            \end{code}
          \end{column}
        \end{columns}
         \ei} \ei
      \end{column}
    \end{columns}
  
  \end{frame}
#+end_src
** Selektion: Bedingte Ausführung
:PROPERTIES:
:CUSTOM_ID: 07-selection
:END:

#+begin_src latex
  \begin{frame}{Selektion: Bedingte Ausführung}
    \begin{btBlock}{Sequenzoperator, Sprüngen und Funktionsaufrufe}
      Wir können nur einen \textbf{linearen} Kontrollfluss vorschreiben; nur endlose Schleifen/Rekursionen sind möglich.
    \end{btBlock}
    \bigskip
    \bi
    \ii<2-> \ALERT{Wichtiger} als Operationen zu reihen, ist es Operationen auszulassen {%
      \bi
      \ii if-then-else--Operation (\texttt{ite}) wählt eine der Nachfolge-Operationen aus
      \ii Auswahl der nächsten Operation erfolgt anhand des \textbf{Programmzustandes}
      \ei
    }
    \ei
    \smallskip
    \begin{columns}
      \begin{column}<2-> {0.49\textwidth}\centering
        \includegraphics[width=0.7\textwidth,page=1]{fig/07-ite}
      \end{column}\hfill
      \begin{column}<3->{0.49\textwidth}\centering
        \includegraphics[width=0.7\textwidth,page=2]{fig/07-ite}
      \end{column}
    \end{columns}
    \smallskip
    \bii
    \ii<3-> Mit Bedingungen gibt es plötzlich \structure{mehrere Kontrolflüsse} durch das Programm
    \ii<4-> Variationen von Bedingungen: Wie viele Nachfolger? Wie wird ausgewählt?
    \eii

  \end{frame}

  \begin{frame}[t]{Die Selektion-Operation ist eine seltsame Operation}
    \vspace{-1.5em}
    \begin{columns}
      \begin{column}{0.49\textwidth}
        \centering
        \structure{Normale Operationen}
      \end{column}\hfill
      \begin{column}<5->{0.49\textwidth}
        \centering
        \structure{Selektion }
      \end{column}
    \end{columns}
    \begin{columns}
      \begin{column}{0.49\textwidth}
        \btAnimation[width=0.45\textwidth]{raisebox,center,padding,range=1-3:<1->,4:<4->}{fig/07-ite-ast}
      \end{column}\hfill
      \begin{column}<5->{0.49\textwidth}
        \btAnimation[width=0.7\textwidth]{raisebox,center,padding,range=5-6:<5->,7:<7->}{fig/07-ite-ast}
      \end{column}
    \end{columns}

    \begin{columns}[t]
      \begin{column}{0.49\textwidth}
        \bii
        \ii Operation hängt von \textbf{allen} Kinder ab
        \ii Kinder werden zuerst ausgeführt
        \ii Reihenfolge der Kinder nicht zwingend
        \eii
      \end{column}\hfill
      \begin{column}<5->{0.49\textwidth}
        \bii
        \ii Hängt \textbf{immer} von der Bedingung ab
        \ii Nur ein anderes Kind wird ausgeführt
        \ii Auswertung wird Daten-sensitiv
        \ii[$\Rightarrow$] \structure{hat programmierbare Abhängigkeit}\\[2ex]
        \eii
      \end{column}
    \end{columns}

    \begin{btBlock}<8>{}
      McCarthy (Erfinder von Lisp), 1960: \enquote{[...] but the notion of conditional expression is believed to be new, and the use of conditional expressions permits functions to be defined recursively in a new and convenient way.}
    \end{btBlock}
  \end{frame}
#+end_src

#+begin_src latex

  \begin{frame}[fragile]{Verschiedene Formen der Selektion}

    \begin{columns}[t]
      \begin{column}{0.49\textwidth}
        \columntitle{if--then--else}
        \begin{code}[tag=C]
          \begin{C}
            if (cond) { /* then-block */ }
            else      { /* else-block */ }
          \end{C}
        \end{code}

        \bii
        \ii Weitere Selektionen im else-block
        \ii Oder: elif, elsif, else if, \ldots
        \ii Manchmal auch Postfix-Notation:\\
        \codeinline[style=ruby]{expr if cond} (Ruby)
        \eii
      
      \end{column}\hfill
      \begin{column}<3->{0.49\textwidth}
        \columntitle{Short-Circuit Expression}
        \begin{code}[tag=C]
          \begin{C}
            expr1 && expr2 && expr3;
            expr4 || expr5 || expr6;
          \end{C}
        \end{code}

        \bii
        \ii Frühzeitiger Auswertungs-Abbruch, sobald der Wahrheitswert feststeht.
        \ii \texttt{!expr1} $\Rightarrow$ Übersprung von expr2/3
        \eii

      \end{column}
    \end{columns}
    \bigskip

    \begin{columns}[t]
      \begin{column}<2->{0.49\textwidth}
        \columntitle{cond}

        \begin{code}[tag=Lisp]
          \begin{lisp}
            (cond
              (cond1 expr1)
              (cond2 expr2)
              (cond3 expr3))
          \end{lisp}
        \end{code}

        \bii
        \ii Lineares Durchlaufen der Paare
        \ii Kurzform der if-elsif-else Kaskade
        \eii
      
      \end{column}\hfill
      \begin{column}<4->{0.49\textwidth}
        \columntitle{Switch/Case}

        \begin{code}[tag=\scriptsize Rust]
          \begin{rust}[style=smaller]
            match number {
               1          => println!("One"),
               2 | 3 | 5  => println!("Two"),
               13..=19    => println!("Range"),
               _          => println!("Def"),
            }
          \end{rust}
        \end{code}

        \bii
        \ii Verzweigungs-Auswahl am Wert
        \ii Wertebereiche, Default-Verzweigung
        \ii Effizient durch Sprungtabellen
        \eii
      \end{column}
    \end{columns}

  
  \end{frame}
#+end_src

#+begin_src latex
  \begin{frame}{Rekursion: Invokation und Selektion}
    \begin{columns}[b]
      \begin{column}{0.49\textwidth}
        \includegraphics[width=\textwidth]{fig/07-rekursion}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \btAnimation[width=\textwidth]{2:<-2>,3:<3->}{fig/07-rekursion}
      \end{column}
    \end{columns}
    \medskip
    \bi
    \ii Rekursion ist das Zusammenspiel von Invokation und Selektion{
      \bi
      \ii \texttt{call} erlaubt uns Operationen mehrfach auszuführen
      \ii \texttt{ite} erlaubt uns die Invokation irgendwann auszulassen
      \ii Selbe Operation mit unterschiedlichen Daten auswerten ($\alpha_1, \alpha_2$,\ldots)
      \ei
    }\medskip
    \ii<2-> Warum macht das überhaupt Sinn? {
      \bi
      \ii \texttt{call} hat formt nicht nur den Kontrollfluss, sondern auch den Datenfluss!
      \ii Argumente \enquote{fließen} in die Call-Operation, Rückgabewerte hinaus\\[1ex]
      \ii Datenfluss trotz seiteneffekt-freier Operationen
      \ii[$\Rightarrow$] \texttt{call F1} ist eine \structure{Komplexoperation} (= zusammengesetzte Operation)
      \ei
    }
    \ei
  \end{frame}
#+end_src


** Iteration: Wiederholte Ausführung
:PROPERTIES:
:CUSTOM_ID: 07-iteration
:END:
#+begin_src latex
  \begin{frame}{Iteration: Dasselbe, immer wieder tun}
    \bi
    \ii Operationen in \structure{Schleifen} werden wiederholt ausgeführt {
      \bi
      \ii Nur Kontrollfluss-, \alert{keine Datenflusseigenschaften} ($\Leftrightarrow$ Invokation)
      \ii Selbe Operation, selbe Operanden, immer wieder auswerten.
      \ii Das macht \textbf{nur Sinn}, wenn die Operationen \textbf{Seiteneffekte} haben
      \ei
    }
    \ei

    \medskip
    \begin{columns}<2->
      \begin{column}{0.49\textwidth}\centering
        \includegraphics[page=1,height=0.33\textheight]{fig/07-loops}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \btAnimation[height=0.27\textheight]{2:<-2>,3:<3->}{fig/07-loops}
      \end{column}
    \end{columns}

    \medskip
    \bi
    \ii<4-> Wie oft wird der \structure{Schleifenkörper} (loop body) ausgewertet? {
      \bi
      \ii \structure{Logically-Controlled}: Wiederholung bis die Abbruchbedingung fehl schlägt
      \ii \structure{Enumeration-Controlled}: Wiederholung für jedes jedes Element einer Aufzählung
      \ei
    }
    \ei
  \end{frame}


  \begin{frame}[fragile]{Logically-Controlled Loops}
    \hspace{-1em}\vspace{-1.5em}\begin{columns}[t]
      \begin{column}{0.5\textwidth}
        \centering\structure{Test am Anfang}\\[1ex]
        \begin{code}[tag=C]
          \begin{C}
            while (cond) {
              stmt1;
              stmt2
            }
          \end{C}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \centering\structure{Test am Ende}\\[1ex]
        \begin{code}[tag=C]
          \begin{C}
            do {
              stmt1;
              stmt2
            } while (cond)
          \end{C}
        \end{code}
      \end{column}
    \end{columns}

    \medskip

    \bi
    \ii Logisch-kontrollierte Schleifen unterscheiden sich kaum {
      \bi
      \ii Liefert der Test ein \alert{negatives} Ergebnis, wird die Schleife \alert{abgebrochen}
      \ii Zeitpunkt des Tests: \textbf{Vor oder nach} jedem Durchlauf?
      \ei
    }\medskip
    \ii<2-> Komplexere Schleifentypen können in einfachere umgewandelt werden {
      \begin{columns}
        \begin{column}{0.4\textwidth}
          \begin{code}[tag=C]
            \begin{C}
              for (init; cond; next) {
                stmt1;
                stmt2;
              }
            \end{C}
          \end{code}
        \end{column}\hfill{\Large $\Rightarrow$}\hfill
        \begin{column}{0.4\textwidth}
          \begin{code}[tag=C]
            \begin{C}
              init;
              while(cond) {
                stmt1; stmt2;
                next;
              }
            \end{C}
          \end{code}
        \end{column}
      \end{columns}
    }\medskip
    \ii<3-> Spezialisierte \texttt{goto}-Befehle für Schleifen {
      \bi
      \ii \structure{\texttt{break}}: Sprung hinter die Schleife
      \ii \structure{\texttt{continue}}: Sprung ans Endes des Schleifenkörpers
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[fragile]{Enumeration-Controlled Loops}
    \begin{columns}
      \begin{column}{0.33\textwidth}
        \begin{code}[tag=C++]
          \begin{CPP}[style=smaller]
            std::vector<int> numbers;
          
            for (int elem : numbers) {
              stmt1; stmt2;
            }
          \end{CPP}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.33\textwidth}
        \begin{code}[tag=Python]
          \begin{py}[style=smaller]
            numbers = [23, 42, 65]
          
            for elem in numbers:
               stmt1
               stmt2
          \end{py}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.33\textwidth}
        \begin{code}[tag=Fortran]
          \begin{fortran}[style=smaller]
            ! [1, 3, 5, 7, 9]
            do i = 1, 10, 2
              stmt1;
              stmt2;
            end
          \end{fortran}
        \end{code}
      \end{column}
    \end{columns}

    \medskip
    \bi
    \ii \structure{Aufzählungsschleifen} iterieren über eine Aufzählung {
      \bi
      \ii Aufzählung liefert eine \structure{Sequenz von Objekten}
      \ii Für jedes Sequenz-Element wird der Schleifenkörper einmal ausgeführt
      \ii Aktuelles Element wird an eine lokale Variable \textbf{gebunden}
      \ei
    }
    \ei
    \pause
    \begin{center}\ttfamily
      enumerate(tree) $\rightarrow$ node, node, node, node,\ldots
    \end{center}
    \bi
    \ii Bei der Aufzählung muss man sich für eine Ordnung entscheiden{
      \bi
      \ii Vorgegeben bei Sequenzen/Listen und Arrays
      \ii Belibig bei ungeordneten Mengen (häufig: internen Datenstruktur)
      \ii Pre-, Post-, oder In-Order bei Bäumen
      \ei
    }
    \ei
  \end{frame}


  \begin{frame}[fragile]{Iteratoren und Generatoren}
    \bi
    \ii Aufzählungen können als eigenständige Objekte existieren{
      \bi
      \ii \structure{Iterator}: Ein Objekt auf dem man \texttt{next(obj)} ausführen kann
      \ii \structure{Generator}: Eine \structure{pausierte Funktionsinstanz} (Continuation)
      \ei
    }
    \ei

    \begin{columns}[t]
      \begin{column}<2->{0.49\textwidth}
        {\centering \structure{Iterator}\par}\smallskip
        \begin{code}[tag=Python]
          \lstinputlisting[style=py,linerange=s0-e0]{lst/07-iterator.py}
        \end{code}
      
      \end{column}\hfill
      \begin{column}<3->{0.49\textwidth}
        {\centering \structure{Generatoren}\par}\smallskip
        \begin{code}[tag=Python]
          \lstinputlisting[style=py,linerange=s1-e1]{lst/07-iterator.py}
        \end{code}

        \bii
        \ii \texttt{fib()} erzeugt Funktionsinstanz\\[0.5ex]
        \ii Bei jedem \texttt{next(it)}:{
          \bi
          \ii \textbf{Fortsetzung} bis \codeinline[style=py]{yield}
          \ii Generator liefert einen Wert
          \ii Funktion wird wieder pausiert 
          \ei
        }
        \eii
      \end{column}
    \end{columns}
  \end{frame}
#+end_src

* Vom Befehlsstrom zum Kontrollflussgraphen
:PROPERTIES:
:CUSTOM_ID: 07-control-flow-graph
:END:
#+begin_src latex
  \dividerframe{Kontrollflussgraphen}
  \begin{frame}{Kontrollflüsse am Beispiel}
    \textbf{Erinnerung}: \btSetTab -- Ein Kontrollfluss ist eine Sequenz von Operationen.\\
    \btUseTab -- Mit Sprachkonstrukten manipulieren wir den Kontrollfluss.\\[3ex]
    \pause

    {
      \btAnimation[width=0.8\textwidth]{center,padding=2ex,1:<1>,range=1-6:<2->}{fig/07-cfg}
    }

   \textbf{\advantage{Intuition}}: Im Kontrollflussgraphen sind alle potentiellen Kontrollflüsse


  \end{frame}

  \begin{frame}[t]{Der Kontrollflussgraph}
    \begin{btBlock}{Definition: \structure{Kontrollflussgraph} (CFG)}
      Der CFG ist die \textbf{Überlagerung aller möglichen Kontrollflüsse} durch ein Codestück. Seine Knoten sind die \structure{Basisblöcke} des Codestücks.
    \end{btBlock}
    \begin{btBlock}{Definition: \structure{Basisblock} (BB)}
      Ein Basisblock ist eine Sequenz von Operationen.\\
      Einmal gestartet, wird die Sequenz \textbf{immer} komplett abgearbeitet.
    \end{btBlock}
    \bi
    \ii<2-> Fakten für Basisblöcke, die aus den Definitionen folgen{
      \bi
      \ii Nur die erste Instruktion eines BB kann angesprungen werden
      \ii Nur die letzte Instruktion eines BB kann ein Sprung sein
      \ii Eine einzelne Operation ist ein \structure{minimaler Basisblock}
      \ei
    }\smallskip
    \ii<3-> Fakten über den CFG, die aus den Definitionen folgen{
      \bi
      \ii Können zwei BBs hintereinander ausgeführt werden, existiert eine CFG-Kante
      \ii \textbf{Aber:} Nicht jeder Pfad durch den CFG ist ein valider Kontrolfluss
      \ei
    }
    \ei
  \end{frame}


  \begin{frame}[fragile]{Kontrollflussgraphen im Übersetzungsprozess}
    \vspace{-1.5em}
    \begin{columns}[t]
 
      \begin{column}{0.49\textwidth}
        \begin{onlyenv}<-7>
        \bi
        \ii Übersetzer: AST $\rightarrow$ CFG {
          \bi
          \ii CFG ist zentrale Datenstruktur
          \ii Codeerzeugung: if,\ldots $\rightarrow$ \texttt{goto}
          \ii Nur Sprünge (und \enquote{Durchfallen})
          \ii Bereits nahe an realen Maschinen
          \ei
        } \medskip
        \ii<2-> CFG-Struktur im Maschinencode{
          \bi
          \ii<3-> BB endet nach Sprüngen
          \ii<4-> BB endet vor Sprungmarken
          \ii<5-> \structure{Maximale Basisblöcke}
          \ii<6-> Kanten anhand von Sprüngen und beim Durchfallen.
          \ei
        }\medskip
        \ii<7-> Vorteile des CFG vs. AST {
          \bi
          \ii Flachegeklopfte Hierarchie
          \ii Nähe zum Maschinenmodell
          \ii Optimierung durch Graphalgorithmen
          \ei
        }
        \ei
      \end{onlyenv}%
      \begin{onlyenv}<8->
        \begin{code}[tag=C]
            \lstinputlisting[style=C,linerange=s0-e0]{lst/07-cfg.c}
          \end{code}
          \medskip

        \Large \textbf{Nächste Vorlesung:}\\
        \hspace{-1em}Codeerzeugung (AST$\rightarrow$CFG)
        
      \end{onlyenv}
    \end{column}\hfill
       \begin{column}{0.49\textwidth}
        \uncover<2->{
          \btAnimation[width=\textwidth]{raisebox,1:<1>,range=1-5:<2->,5:<7->}{fig/07-asm-cfg}
        }
      \end{column}
    \end{columns}
  \end{frame}
#+end_src

#+begin_src latex
  \begin{frame}{Einordnung des CFGs in die Vorlesung}
    \includegraphics[page=2,width=\textwidth]{fig/01-overview-small}
  
  \end{frame}
#+end_src

#+begin_src latex
  \begin{frame}[t]{Kontrollflussgraph auf mehreren Ebenen}
    \setbeamercovered{still covered={\opaqueness<1->{0}},again covered={\opaqueness<1->{30}}}
    \begin{center}
      \OrangeBox{\textbf{Frage}: Beendet ein \texttt{call} den aktuellen Basisblock?}
    \end{center}
    \begin{columns}[t]
      \begin{column}<2->{0.49\textwidth}
        \ALERT{Nein}: Calls sind  Komplexbefehle

        \centerline{$\Downarrow$}

        \columntitle{Funktions-lokaler CFG}

        \bii
        \ii Nur Sprünge teilen einen BB
        \ii CFG überdeckt nur eine Funktion
        \ii Anwendung: lokalen Optimierungen\\[1ex]
        \ii[$\Rightarrow$] Der \enquote{normale} CFG
        \eii
      \end{column}\hfill
      \begin{column}<-5>{0.49\textwidth}
        \ADVANTAGE{Ja}: Ein Call ist ein Jump

        \centerline{$\Downarrow$}

        \columntitle{Interprozeduraler CFG}
        \bii
        \ii Kante: \texttt{call}$\rightarrow$Aufgerufene Funktion
        \ii Alle Blöcke aus allen Funktionen
        \ii Whole-Program Analysis\\[1ex]
        \ii[$\Rightarrow$] Der selten-verwandte CFG
        \eii
      \end{column}
    \end{columns}

    \bigskip\bigskip
    \uncover<4->{
      \btAnimation[width=0.8\textwidth]{center,1:<1-4>,2:<5-6>}{fig/07-icfg}
    }
    \smallskip
  \end{frame}
#+end_src

* Zusammenfassung
#+begin_src latex

  \begin{frame}{Zusammenfassung: Operationen}
    \bi
    \ii \structure{Operationen} lesen Objekte, verarbeiten Daten und liefern Ergebnisse {
      \bi
      \ii \structure{Abhängigkeiten} zu anderen Operationen müssen zuerst ausgewertet werden
      \ii \structure{Seiteneffekte}: Operation verändert ein Objekt oder eine Variable
      \ii \structure{Auswertungsreihenfolge} bildet Operationen auf lineare Operationssequenz ab
      \ei
    }\medskip
    \ii Sprachkonstrukte formen die möglichen \structure{Kontrolflüsse}{
      \bi
      \ii \structure{Sequenzierung} \btSetTab Operationen werden direkt hintereinander ausgeführt
      \ii \structure{Invokation} \btUseTab Einschub einer Funktionsausführung, Komplexbefehl
      \ii \structure{Selektion} \btUseTab Operationen durch dynamische Entscheidungen auslassen
      \ii \structure{Iteration} \btUseTab Operationen wegen ihrer Seiteneffekte mehrfach ausführen
      \ei
    }\medskip
    \ii \structure{Kontrollflussgraphen} überdecken die möglichen Kontrolflüsse {
      \bi
      \ii \structure{Basisblöcke} sind ununterbrochen Operationssequenzen
      \ii \textbf{Ausblick}: Ergebnis der Codeerzeugung und Grundlage für die Optimierung
      \ei
    }
    \ei
  
  \end{frame}
#+end_src
