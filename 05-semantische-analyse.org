#+TITLE: Programmiersprachen und Übersetzer
#+SUBTITLE: 05 - Semantische Analyse
#+SETUPFILE: setup.org
#+INCLUDE: export-prologue.org
#+PROPERTY: header-args:latex :tangle yes :noweb yes :tangle-macros yes :tangle-prologue topic :tangle-epilogue endtopic :exports none

#+NAME: topic
#+BEGIN_SRC latex :tangle no
\psuSectionStart{{{{property(ITEM)}}}}{{{{n(block)}}}}
#+END_SRC

#+NAME: endtopic
#+BEGIN_SRC latex :tangle no
\psuSectionStop{{{{property(ITEM)}}}}{{{{n(block,-)}}}}
#+END_SRC

* Gedanken zu dieser Vorlesung                                     :noexport:
Was lernt man aus dieser Vorlesung für die Ziele effektiv und effizient?
 - Wie fließen Attribute  [effektiv]
   - Attribut Grammatike
 - Übersetzertechniken kennen lernen [effizient]
   - Visitor Pattern


* Ziele der semantischen Analyse
:PROPERTIES:
:CUSTOM_ID: 05-einleitung
:END:
#+begin_src latex
  \subtitle{{{{subtitle()}}}}
  \begin{frame}
    \maketitle
  \end{frame}

  \begin{frame}{Einordnung in die Vorlesung: Semantische Analyse}
    \begin{center}
      \includegraphics[page=5,width=0.8\linewidth]{fig/01-overview-small}
    \end{center}
    \bi
    \ii Übersetzer prüft bei der semantische Analyse die letzten Sprachregeln.\\
    \alert{$\Rightarrow$ In der semantischen Analyse werden die letzten Fehler entdeckt.} \medskip
    \ii Was sollte der \emph{effektive} und \emph{effiziente} Informatiker darüber Wissen? {
      \bi
      \ii Datenfluss auf einem Baum geschieht entlang und quer zu den Kanten.
      \ii Übersetzertechniken sind auch in anderen Bereichen einsetzbar.
      \ei
      }
      \ei

  \end{frame}

  \begin{frame}{Beispiel: Semantische Analyse eines Programms}
    \btAnimation[width=\textwidth]{center,range=1-5:<1->}{fig/05-example-ast}
  \end{frame}

  \begin{frame}[t]{Ziele der Semantischen Analyse}
    \begin{btBlock}{Syntaktische und Semantische Analyse prüfen alle Sprachregeln}\small
      Die syntaktische Analyse prüft die kontextfreien Regeln einer Sprache. Alles was nicht kontextfrei geprüft werden kann, überprüft die semantische Analyse.
    \end{btBlock}
    \bi
    \ii Abschließende Prüfung der Sprachregeln und Informationsgewinnung{
      \bi
      \ii Alle restlichen, nicht-syntaktischen, Sprachfehler werden hier aufgedeckt.
      \ii \enquote{Wo ist diese verwendete Variable deklariert und mit welchem Typ?}
      \ei
    }\medskip\pause
    \ii \tikzmark{A}\structure{Deklariertheit}: Kann jede (statische) Namensreferenz aufgelöst werden?{
      \bi
      \ii Zu jedem Namen(spfad) muss eine Deklaration gefunden werden.
      \ii Auffinden der passenden Überladung für eine Aufrufstelle.
      \ei
    }\medskip
    \ii \tikzmark{B}\structure{Typkonsistenz}: Werden die statischen Typen korrekt verwendet?{
      \bi
      \ii Die Typen der Argumente müssen zur Signatur einer Operation passen.
      \ii Nicht jede Inkonsistenz ist ein Fehler (Implizite Typumwandlung)
      \ei
    }
    \ei
    \begin{tikzpicture}[remember picture,overlay,visible on=<3->]
      \draw[<->,srared,thick] ($(pic cs:A)+(west:1.2em)$) coordinate(@) -- ($(pic cs:B)+(west:1.2em)+(up:1ex)$);
    \end{tikzpicture}
  \end{frame}
#+end_src

* AST Struktur und Attributierung
#+begin_src latex
\dividerframe{AST Knoten}
  \begin{frame}[t,fragile]{AST: Baumstruktur im Übersetzer}
    \textbf{Theoretisch} ganz einfach. Ein AST ist eine Menge von Knoten....

    \tikzmark{X}\begin{columns}[b]
      \begin{column}{0.44\textwidth}
        \begin{code}[]
          \begin{CPP}[style=smaller]
            struct node_t {
              int    type;
              string token;
              vector<node_t> children;
            };
          \end{CPP}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.55\textwidth}
        \begin{code}[]
          \begin{CPP}[style=smaller]
            string getName(node_t *n) {
              if (n->type == VAR_DECL) {
                return n->children[1].token;
              } else if (n->type == VAR_REF) {
                return n->token;
              } ....
            }
          \end{CPP}
        \end{code}
      \end{column}
    \end{columns}

    \bi
    \ii<2-> \textbf{In Realität}: Code des Übersetzers muss auf dem dem AST operieren {
      \bi
      \ii Struktur der Grammatik sollte sich in den Datenstrukturen widerspiegeln
      \ii Übersetzer sind komplexe Programme, Bugs sind besonders schwerwiegend
      \ii Nutzung der verfügbaren Sprachfeatures um Übersetzer \structure{robust} zu machen
      \ei
    }
    \ei

    \begin{code}<2->[tag=Java]
      \tikzset{every node/.style={inner sep=0}}
      \begin{java}[style=smaller,escapechar=`]
        class `\tikznode[name=classdef]{ClassDef}` extends Definition {
          public Name               name;
          public ClassDef           extending;
          public `\tikznode[name=type]{List<InterfaceDef>}`    implementing;
          public List<Definition>   `\tikznode[name=member]{defs}`;
          ....
        }
      \end{java}
    \end{code}
    \begin{tikzpicture}[remember picture,overlay]
      \begin{visible}<2->
        \draw[ultra thick, srared](pic cs:X) -- node[sloped,fill=srared!2,draw]{\Huge NEIN}++(12cm,-2.2cm);
      \end{visible}
      \begin{visible}<3->
        \node[fit=(classdef),draw,pin={[draw,fill=badbee!20!white]60:Knotentypen als Klassen}] {};
        \node[fit=(type),draw,pin={[draw,fill=badbee!20!white]-90:Kinder haben Typen}] {};
        \node[fit=(member),draw,pin={[draw,fill=badbee!20!white]10:Kinder haben Namen}] {};
      \end{visible}
    \end{tikzpicture}
  \end{frame}

  \begin{frame}[fragile]{AST: Eine Hierarchie von Knotentypen}
    \bi
    \ii<+-> Die Grammatik legt bereits eine Hierarchie von Knotentypen nahe\\{
      \btSetNamedTab[1cm]{\first}%
      \first Grammatik:      \grammarrule{\NT{smt}}{assign\_stmt \OR while\_stmt \OR if\_stmt \OR \ldots}\\
      \first AST Definition: \codeinline[style=java]{class AssignStmt extends Stmt {...}}
    }
    \ii<+-> Zusammenfassung von Ähnlichkeiten verschiedener Knotentypen\\
        \textit{Beispiel}: Viele Deklarationen können einen Namen tragen. Lassen wir diese von \codebox{NamedDecl} erben, so können wir sie gleich behandeln.\medskip

    \ii<+-> Häufig verwendete Klassen von Knotentypen{
      \bi
      \ii \structure{Expression}: Ausdrücke die man auswerten kann und die ein Ergebnis liefern.\\
      \hspace{5mm}\textit{Beispiele:} Addition, Dereferenzierung, \codeinline{(<cond> ? <then> : <else>)}
      \ii \structure{Statement}: Anweisungen die sequentiell bearbeitet werden.\\
      \hspace{5mm}\textit{Beispiele:} if-else, Schleifen, Zuweisungen
      \ii \structure{Typen}: Literal notierte Typausdrücke.\\
      \hspace{5mm}\textit{Beispiele:} Typname, Typausdruck innerhalb eines Casts
      \ii \structure{Deklaration}: Jede statisch Bekanntmachung für den Compiler\\
      \hspace{5mm}\textit{Beispiele:} Variablendefinition, Klassendeklarationen, \codeinline[style=C]{typedef}
      \ei
    }
    \ei

  \end{frame}

  \begin{frame}[fragile]{AST: Zusätzliche Attribute}
    \vspace{-1ex}
    \bi
    \ii Der Parser erzeugt die Knoten und die Baumstruktur.{
      \bi
      \ii \structure{Parseraktionen} machen dies nebenher, wenn eine Regel angewendet wird:\\
         \codeinline!while_stmt -> WHILE ( expr ) body         { new WhileStmt(cond=T3, body=T5) }!
      \ii \codebox{expr} ist ein Expression Knoten und ist über T3 zugreifbar.
      \ei
    }
    \ii<2-> Semantische Analyse berechnet zusätzliche \structure{Attribute}{
      \bi
      \ii Datenhaltung während Analyse, Wissensbasis für den Rest des Übersetzers
      \ii \textit{Beispiel}: Berechneten Typ einer Expression, Zeiger auf die Deklaration.
      \ei
    }
    \ei

    \begin{columns}<3->[t]
      \begin{column}{0.49\textwidth}
        \begin{code}[tag=Python]
          \lstinputlisting[style=py,style=smaller,linerange={range0-range1}]{lst/05-DeclRefExpr.py}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \btAnimation[width=0.9\textwidth]{raisebox,center,1:<1->}{fig/05-member-expr.pdf}
      \end{column}
    \end{columns}
  \end{frame}


  \begin{frame}{Clang: AST Knoten und ihre Attribute}
    \begin{center}
      \btImage[text width=0.7\textwidth,draw,label=below:\scriptsize Ausschnitt aus der Klassenhierarchie]{fig/05-llvm-named-decl-tree}
      \medskip

      \btImage[text width=0.7\textwidth,draw,label=below:\scriptsize Öffentliches Interface von \texttt{clang::NamedDecl}]{fig/05-llvm-named-decl-member}
    \end{center}
  \end{frame}

  \begin{frame}[fragile]{Clang: AST für ein einfaches Programm}
    \begin{columns}
      \begin{column}{0.4\textwidth}
        \begin{code}[tag=C]
          \lstinputlisting[style=CPP,style=smaller,numbers=left,]{lst/05-example.cc}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.59\textwidth}
        \bii
        \ii CLang: C/C++ Frontend für LLVM
        \ii Source-to-Source Transformation
        \ii \texttt{clang::VarDecl} ist ein \texttt{clang::NamedDecl}
        \eii
      \end{column}
    \end{columns}

    \begin{btBlock}{\$ clang -Xclang -ast-dump -fsyntax-only /tmp/test.cc}
      \scriptsize
      \input{fig/05-clang-output}
    \end{btBlock}
  \end{frame}

#+end_src
- AST: Baumstruktur und Knoteninhalte
  - Vererbungshierarchie von Knoten
  - Angehängte Attribute an AST Knoten
  - Deklarationen, Statements, Expressions

* Informationsfluss auf Bäumen
#+begin_src latex
  \begin{frame}[t]{Semantische Regeln als Attributgleichungen}
    \bi
    \ii Die sem. Analyse berechnet die Werte der Attribute für jeden Knoten{
      \bi
      \ii Attribute hängen von anderen (benachbarten) AST Knotenattributen ab.
      \ii Abstrakte Sicht: Gleichungssystem mit Gleichungen für jeden Knotentyp
      \ii Reihenfolge der Auswertung ist nicht fest gelegt.
      \ei
    }
    \ei
    \begin{btBlock}[type=example]{\textbf{Beispiel}: Höhe (h) und Wert (v) in einem Additionsbaum}
      \btAnimation[width=0.9\textwidth]{center,1:<1>,range=1-9:<2->}{fig/05-attribute-tree}
      \btAnimation[width=0.6\textwidth]{center,10:<11->}{fig/05-attribute-tree}
    \end{btBlock}
    \bi
    \ii<11-> \structure{Attributgrammatiken} annotieren die Regeln direkt an die Produktionen\\
    \bi
    \ii \codebox{\small\ttfamily\grammarrule{plus}{expr + expr}\hspace{1cm}\{ \$0.h = max(\$1.h, \$3.h) + 1 \}}
    \ii Parseaktionen (Parsebaum$\rightarrow$AST) sind bereits Attributgrammatiken
    \ei
    \ei
  \end{frame}

  \begin{frame}{Abhängigkeitsgraphen und Attributtypen}
    \bi
    \ii Attribut-Gleichungssystem beinhaltet einen \structure{Abhängigkeitsgraphen} {
      \bi
      \ii Für jedes Attribut auf der rechten Seite gibt es eine Abhängigkeit
      \ii Topologische Sortierung bestimmt die Auswertereihenfolge
      \ii Verschiedene Verfahren für unterschiedliche Typen von Abhängigkeiten
      \ei
    }
    \begin{columns}[t]
      \begin{column}<2->{0.32\textwidth}
        \begin{center}
          \includegraphics[height=2.5cm,page=1]{fig/05-dependency-tree}\\
          \structure{Synthetische Attribute}
          \scriptsize \enquote{von unten nach oben}
        \end{center}
        \bii
        \ii S-Attribute
        \ii Abhängig von Kindern
        \ii Typen in Expressions
        \ii Technik: Traversierung
        \eii
    \end{column}\hfill
    \begin{column}<3->{0.33\textwidth}
      \begin{center}
        \includegraphics[height=2.5cm,page=2]{fig/05-dependency-tree}\\
        \structure{Geerbte Attribute}\\
        \scriptsize \enquote{von links nach rechts}
      \end{center}
      \bii
      \ii L-Attribute
      \ii Abhängig von Vorgängern und Nachbarn
      \ii Namensauflösung
      \ii Technik: Symboltabelle
      \eii
    \end{column}
    \begin{column}<4->{0.33\textwidth}
      \begin{center}
        \includegraphics[height=2.5cm,page=3]{fig/05-dependency-tree}\\
        \structure{Zyklen Abhängig.}
        \scriptsize \enquote{all-over-the-place}
      \end{center}
      \bii
      \ii Fixpunktberechnung
      \ii Eher zu vermeiden
      \ii Typinferenz in Haskell
      \ii Technik: Unifikation
      \eii
    \end{column}
    \end{columns}

    \ei

  \end{frame}

#+end_src
** Traversierung von Bäumen
#+begin_src latex
  %%ONLY%%
  \begin{frame}[t]{Traversierung von Bäumen}
    \begin{btBlock}{Berechnung der synthetischen Attribute}
      Wir müssen \textbf{jeden Knoten} besuchen, \textbf{knotenspezifischen} Code ausführen, und die Attributwerte \textbf{von unten nach oben} propagieren.
    \end{btBlock}
    \medskip

    \begin{columns}[t]<2->
      \begin{column}{0.49\textwidth}
        \begin{code}[tag=Python]
          \lstinputlisting[style=py,linerange={v0s-v0e}]{lst/05-traversal.py}%
          \uncover<3->{%
            \lstinputlisting[style=py,linerange={v1s-v1e}]{lst/05-traversal.py}%
          }%
          \uncover<4->{%
            \lstinputlisting[style=py,linerange={v2s-v2e}]{lst/05-traversal.py}%
          }
        \end{code}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \structure{Baumtraversierung (Post-Order)}
        \bii
        \ii Bäume sind rekursiv.
        \ii Jeden Knoten besuchen auch!\\[5ex]
        \ii<3-> Dynamischer Typ des Knoten
        \ii<3-> Zugriff auf Attribute der Kinder
        \ii<3-> Attributgleichung ausrechnen\\[6ex]
        \ii<4-> Setzen des Attributs
        \ii<4-> Wert im Aufrufer verfügbar
        \eii

      \end{column}
    \end{columns}
  \end{frame}

  \begin{frame}{Probleme von Ad-Hoc Traversierung}
      \textbf{Ironie}: Das geht aber noch mehr ad-hoc und unlesbar!
      \begin{center}
        \begin{minipage}{0.5\linewidth}
        \begin{code}[]
          \lstinputlisting[style=py,linerange={v3s-v3e}]{lst/05-traversal.py}
        \end{code}
        \end{minipage}
      \end{center}

      \bi
      \ii<2-> Die \structure{Attributgleichungen} gehen im \alert{fragilen} Boilerplate unter{
        \bi
        \ii Duplikation der Traversierungslogik für jedes Attribut
        \ii Duplikation der \codebox{isinstance} Kaskade für jedes Attribut
        \ii Ein neuer AST Knotentyp $\rightarrow$ N Traversierungsfunktionen anpassen.
        \ei
      }\medskip
      \ii<3-> Wende informatische Super-Power \alert{"Trennung der Belange"} an! {
        \bi
        \ii Attributgleichungen werden in einer Besucherklasse gekapselt
        \ii Generischer Code für Traversierung in definierter Ordnung
        \ei
      }
      \ei
  \end{frame}

  \begin{frame}[fragile]{Visitor-Pattern: Operationen auf Knoten kapseln}
    \begin{code}[tag=C++]
      \lstinputlisting[style=CPP,linerange={Vs-Ve}]{lst/05-visitor.cc}
    \end{code}
    \bi
    \ii Bündelung der Attributgleichungen in einem Visitor-Objekt {
      \bi
      \ii Die \codebox{visit()} Funktion wird für jeden Knotentyp überladen
      \ii Visitor-Objekt kann zusätzlichen Zustand als Member speichern
      \ii Vererbungshierarchie kann beachtet werden (\codeinline[style=CPP]{void visit(NamedDecl D)})
      \ei
    }
    \ei

    \begin{columns}<2->
      \begin{column}{0.49\textwidth}
        \begin{code}[]
          \lstdefinestyle{error}{
            escapechar=`,
            moredelim=**[is][{\btHL[fill=srared!50!white,name=error]<3->}]{@}{@},
          }
          \lstinputlisting[style=CPP,style=smaller,style=error,linerange={Ts-Te}]{lst/05-visitor.cc}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.48\textwidth}
        \bi
        \ii Generischer Traversierer {
          \bi
          \ii Knoten haben Liste der Kinder
          \ii Definierte Besuchsreihenfolge
          \ii Visitor wird auf jeden Knoten angewendet.
          \ei
        }
        \ei
      \end{column}
    \end{columns}
    \begin{tikzpicture}[remember picture,overlay]
      \only<3>{
        \draw(error) -- ++(0:2cm) node[right,fill=srared!20!white,draw=srared,thick,align=left]{Das ist so kaputt!\\
          Dynamischer Dispatch nur im nullten Argument!\\
        Ruft immer \fbox{\texttt{Visitor::visit(Tree)}} auf!};
      }
    \end{tikzpicture}

  \end{frame}
#+end_src
  - Synthetische Attribute
  - Visitor Pattern: Emulate Double Dispatch
  - type_equal, type_compatible
** Symboltabelle
  - Geerbte Attribute
  - find_decl, find_decl_fun
** Was tun bei Fehlern?
* Integration
  - Language: Coercion
    - Unifikation am Beispiel von Typen?
