#+TITLE: Programmiersprachen und Übersetzer
#+SUBTITLE: 05 - Semantische Analyse
#+SETUPFILE: setup.org
#+INCLUDE: export-prologue.org
#+PROPERTY: header-args:latex :tangle yes :noweb yes :tangle-macros yes :tangle-prologue topic :tangle-epilogue endtopic :exports none

#+NAME: topic
#+BEGIN_SRC latex :tangle no
\psuSectionStart{{{{property(ITEM)}}}}{{{{n(block)}}}}
#+END_SRC

#+NAME: endtopic
#+BEGIN_SRC latex :tangle no
\psuSectionStop{{{{property(ITEM)}}}}{{{{n(block,-)}}}}
#+END_SRC

* Gedanken zu dieser Vorlesung                                     :noexport:
Was lernt man aus dieser Vorlesung für die Ziele effektiv und effizient?
 - Wie fließen Attribute             [effektiv]
   - Attribut Grammatiken
 - Übersetzertechniken kennen lernen [effizient]
   - Visitor Pattern
   - Symboltabelle
   - Unifikation


* Ziele der semantischen Analyse
:PROPERTIES:
:CUSTOM_ID: 05-einleitung
:END:
#+begin_src latex
  \subtitle{{{{subtitle()}}}}
  \begin{frame}
    \maketitle
  \end{frame}

  \begin{frame}{Einordnung in die Vorlesung: Semantische Analyse}
    \begin{center}
      \includegraphics[page=5,width=0.8\linewidth]{fig/01-overview-small}
    \end{center}
    \bi
    \ii Übersetzer prüft bei der semantische Analyse die letzten Sprachregeln.\\
    \alert{$\Rightarrow$ In der semantischen Analyse werden die letzten Fehler entdeckt.} \medskip
    \ii Was sollte der \emph{effektive} und \emph{effiziente} Informatiker darüber Wissen? {
      \bi
      \ii Datenfluss auf einem Baum geschieht entlang und quer zu den Kanten.
      \ii Übersetzertechniken sind auch in anderen Bereichen einsetzbar.
      \ei
      }
      \ei

  \end{frame}
  #+end_src


In dieser Vorlesungseinheit werden wir uns mit der *semantischen Analyse* befassen.
In den letzten beiden Kapiteln haben wir uns mit zwei essentiellen Bereichen des Sprachdesigns (Typen und Namen) befasst.
Diese beiden Themenbereiche greifen wir bei der semantischen Analyse wieder auf, betrachten Sie diesmal allerdings aus Sicht des Übersetzers:
"Wie *implementieren* wir Typprüfung und Namensauflösung in einem Übersetzer?"
Dazu werden wir zum einen einen theoretischen Hintergrund kennen lernen, der uns erklärt was wir in der semantischen Analyse überhaupt ausrechnen (Knotenattribute) und welche Techniken dafür geeignet sind (Baumtraversierung, Symboltabelle, Unifikation).
Die Vorlesung ist dabei stark von möglichen Implementierungen getrieben; Schnallen Sie sich also an, es wird Codebeispiele regnen!

Zunächst wollen wir die semantische Analyse einmal in den Ablauf des Übersetzungsvorgangs einordnen.
In der zweiten Vorlesung haben wir uns mit der syntaktischen Analyse befasst, die einen Zeichenstrom einließt und durch Anwendung eines kontextfreien Parsers einen abstrakten Syntaxbaum (AST) extrahiert.
Ausgehend vom Syntaxbaum, welcher für jede Anwendung einer Grammatikregel einen Knoten enthält, berechnen wir den AST als eine kondensierte Form der Programmstruktur.
Durch die Baumstruktur des AST können wir beliebig tiefe syntaktische Schachtelungen (z.B. geklammerte arithmetische Ausdrücke) darstellen.
Der AST ist die *Eingabe der semantischen Analyse*.

Während die syntaktische Analyse bereits sicher stellt, dass ein Programm korrekt notiert wurde und syntaktisch korrekt ist (z.B.
Klammerung ist balanciert), können sich immer noch inhaltliche (oder semantische) Fehler im AST verstecken.
So könnte in einem Ausdruck eine Variable referenziert werden, die nirgends deklariert ist, oder wir könnten versuchen eine Ganzzahl auf zu rufen (~int x = 1; x();~).
Beide Fehler können, prinzipbedingt, nicht durch einen kontextfreien Parser erkannt werden, da sie erst in einer gewissen Umgebung, einem Kontext, erkennbar werden.
Daher teilt man die Menge aller Sprachregeln in die syntaktischen Regeln und die semantischen Regeln ein.
Im Prinzip prüft die semantische Analyse all übrigen Regeln ab, die nicht bereits im Parser geprüft werden konnten.
Dies bedeutet aber auch, dass wir am Ende der semantischen Analyse sicher wissen, ob ein vorliegendes Programm wirklich ein Programm der Sprache ist oder nur ein Zeichenstrom der einem validen Programm zum verwechseln ähnlich sieht[fn::Wenn ihr "C Programm" nicht kompliert, ist es kein Programm der Sprache C].

Das Ergebnis der semantischen Analyse ist wieder der AST.
Allerdings reichert die semantische Analyse die Knoten des AST um *semantische Attribute* an.
Diese Attribute beinhalten Zeiger auf die Deklaration bei Namensreferenzen oder den berechneten Rückggabetyp eines komplexen Ausdrucks.
Diese Attribute hängen dabei nicht nur von dem Knoten ab, an den wir sie anhängen, sondern auch von den Kindern, den Geschwistern oder dem Vorgänger des aktuellen Knotens.
Die Techniken mit denen wir diese Attribute berechnen und auf Konsistenz prüfen, sind dabei nicht nur für den Übersetzerbau hilfreich, sondern auch für andere Bereiche der Informatik.

TL;DR: Semantische Analyse(AST) -> AST mit semantischen Attributen an jedem Knoten


#+begin_src latex
\begin{frame}{Beispiel: Semantische Analyse eines Programms}
  \btAnimation[width=\textwidth]{center,range=1-5:<1->}{fig/05-example-ast}
\end{frame}

\begin{frame}[t]{Ziele der Semantischen Analyse}
    \begin{btBlock}{Syntaktische und Semantische Analyse prüfen alle Sprachregeln}\small
      Die syntaktische Analyse prüft die kontextfreien Regeln einer Sprache. Alles was nicht kontextfrei geprüft werden kann, überprüft die semantische Analyse.
    \end{btBlock}
    \bi
    \ii Abschließende Prüfung der Sprachregeln und Informationsgewinnung{
      \bi
      \ii Alle restlichen, nicht-syntaktischen, Sprachfehler werden hier aufgedeckt.
      \ii \enquote{Wo ist diese verwendete Variable deklariert und mit welchem Typ?}
      \ei
    }\medskip\pause
    \ii \tikzmark{A}\structure{Deklariertheit}: Kann jede (statische) Namensreferenz aufgelöst werden?{
      \bi
      \ii Zu jedem Namen(spfad) muss eine Deklaration gefunden werden.
      \ii Auffinden der passenden Überladung für eine Aufrufstelle.
      \ei
    }\medskip
    \ii \tikzmark{B}\structure{Typkonsistenz}: Werden die statischen Typen korrekt verwendet?{
      \bi
      \ii Die Typen der Argumente müssen zur Signatur einer Operation passen.
      \ii Nicht jede Inkonsistenz ist ein Fehler (Implizite Typumwandlung)
      \ei
    }
    \ei
    \begin{tikzpicture}[remember picture,overlay,visible on=<3->]
      \draw[<->,srared,thick] ($(pic cs:A)+(west:1.2em)$) coordinate(@) -- ($(pic cs:B)+(west:1.2em)+(up:1ex)$);
    \end{tikzpicture}
  \end{frame}
#+end_src

Um die Schritte der semantischen Analyse deutlicher zu machen, wollen wir uns ein Beispiel ansehen.
Beim AST, den wir aus dem Parser bekommen, sind alle Kinder eines AST Knotens erst einmal gleichberechtigt, haben aber eine Ordnung, die sich aus den Regeln der Grammatik ergeben; Wir können diese also in einem Knoten in einem Array speichern (im Beispiel ist der Rückgabetyp der Funktion in ~function.children[2]~ gespeichert.
Da solche magischen Konstanten den Code unseres Übersetzers unübersichtlich macht, geben wir den Kindern der AST Knoten, wo dies Sinn macht, symbolische Namen (~function.rettype~).

Bei der *Namensauflösung* prüfen wir zum einen ob es eine passende Deklaration (*Deklariertheitseigenschaft*) gibt und zum anderen speichern wir die gefundene Referenz als Attribut an der Verwendungsstelle.
Bemerkenswert im Beispiel ist, dass wir bei der Referenz ~"a"~ nicht auf den deklarierenden Bezeichner ~"a"~ zeigen lassen, sondern auf den inneren Knoten der das semantische Element "Variablendeklaration" darstellt; Wir etablieren so eine *semantische Querverbindung* im AST.
Querverbindung deshalb, weil sich die Kante nicht entlang der kanten des Baums hangelt, sondern direkt, quer zu jeder Eltern-Kind Beziehung, gezogen wird.

Das Ziel der *Typprüfung* ist es sicher zu stellen, dass jede angewandte Operation kompatibel zu den statischen Typen der Operanden ist; Operanden und Operationen müssen konsistent zueinander sein!
So dürfen wir das Ergebnis einer Addition nicht als Funktion aufrufen:
~(1+1)()~, weil man Ganzzahlen, immer noch nicht, aufrufen kann.
Um diese Typprüfung durch zu führen, berechnen wir für die Knoten des ASTs einen Rückggabetyp:
Beginnend bei den Blättern, die entweder konstante Laterale (~1~) oder Namensreferenzen sind (Typ der Deklaration), propagieren wir die Typinformationen im Baum von unten nach oben.
Bei jedem inneren Knoten prüfen wir ob die Typen der direkten Kinder (= die Operanden) zum Knotentyp (= die Operation) passt.
So erwartet die ~+~ Operation im Beispiel, dass sowohl das linke (left-hand side, lhs) als auch das rechte (right-hand side, rhs) Kind ein ~int~ ist. Das Ergebnis dieser Addition ist wiederum selbst vom Typ ~int~.
Außerdem wird sichergestellt, dass die zurückgegebenen Werte zum deklarierten Rückggabetyp der Funktion passen.

Am gezeigten Additionsknoten können wir wieder sehen, dass Typprüfung und Namensauflösung, wie bereits erwähnt, miteinander interagieren. Hätte unsere Sprache die Möglichkeit diesen Operator zu überladen, so würden wir für den ~+~-Knoten zunächst die Typen der Kinder berechnen, eine Aufrufsignatur erstellen und per Namensauflösung eine Referenz auf die verwendete Überladung ziehen. Der Knotentyp unserer Addition wäre dann nicht immer ~+~, sondern der Rückgabetyp der gefundenen Überladung.


Wir wollen uns im Folgenden den notwendigen Techniken für diese beiden Aspekte der semantischen Analyse widmen.
Neben Typkonsistenz und Deklariertheit kann es allerdings noch andere Sprachregeln geben, die nicht kontextfrei prüfbar sind und daher in den Bereich der semantischen Analyse fallen.
Diese lassen sich in aller Regeln mit den selben Techniken erledigen.

* AST Struktur und Knotenattribute
:PROPERTIES:
:CUSTOM_ID: 05-ast-types
:END:

#+begin_src latex
\dividerframe{AST Knoten}
  \begin{frame}[t,fragile]{AST: Baumstruktur im Übersetzer}
    \textbf{Theoretisch} ganz einfach. Ein AST ist eine Menge von Knoten....

    \tikzmark{X}\begin{columns}[b]
      \begin{column}{0.44\textwidth}
        \begin{code}[]
          \begin{CPP}[style=smaller]
            struct node_t {
              int    type;
              string token;
              vector<node_t> children;
            };
          \end{CPP}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.55\textwidth}
        \begin{code}[]
          \begin{CPP}[style=smaller]
            string getName(node_t *n) {
              if (n->type == VAR_DECL) {
                return n->children[1].token;
              } else if (n->type == VAR_REF) {
                return n->token;
              } ....
            }
          \end{CPP}
        \end{code}
      \end{column}
    \end{columns}

    \bi
    \ii<2-> \textbf{In Realität}: Code des Übersetzers muss auf dem dem AST operieren {
      \bi
      \ii Struktur der Grammatik sollte sich in den Datenstrukturen widerspiegeln
      \ii Übersetzer sind komplexe Programme, Bugs sind besonders schwerwiegend
      \ii Nutzung der verfügbaren Sprachfeatures um Übersetzer \structure{robust} zu machen
      \ei
    }
    \ei

    \begin{code}<2-|handout:2->[tag=Java]
      \tikzset{every node/.style={inner sep=0}}
      \begin{java}[style=smaller,escapechar=`]
        class `\tikznode[name=classdef]{ClassDef}` extends Definition {
          public Name               name;
          public ClassDef           extending;
          public `\tikznode[name=type]{List<InterfaceDef>}`    implementing;
          public List<Definition>   `\tikznode[name=member]{defs}`;
          ....
        }
      \end{java}
    \end{code}
    \begin{tikzpicture}[remember picture,overlay]
      \begin{visible}<2-|handout:2->
        \draw[ultra thick, srared](pic cs:X) -- node[sloped,fill=srared!2,draw]{\Huge NEIN}++(12cm,-2.2cm);
      \end{visible}
      \begin{visible}<3-|handout:3->
        \node[fit=(classdef),draw,pin={[draw,fill=badbee!20!white]60:Knotentypen als Klassen}] {};
        \node[fit=(type),draw,pin={[draw,fill=badbee!20!white]-90:Kinder haben Typen}] {};
        \node[fit=(member),draw,pin={[draw,fill=badbee!20!white]10:Kinder haben Namen}] {};
      \end{visible}
    \end{tikzpicture}
  \end{frame}
  #+end_src

Bevor wir zu den Analysetechniken kommen, werfen wir einen genaueren Blick auf die Knoten des abstrakten Syntaxbaums.
Für die semantische Analyse müssen wir viel Code schreiben, der auf den Knoten des ASTs operiert.
Bauen wir dabei einen Fehler ein, so ist dieser um ein vielfaches schwerwiegender als ein Bug in einem anderen Programm, da ein Übersetzerbug beliebig viele Programme beeinflussen kann.
Wir sollten daher bei der Konstruktion von Übersetzern besonders vorsichtig sein und so viele Sicherheits- und Verständlichkeits-Features unserer Host-Sprache (Programmiersprache in der der Übersetzer selbst verfasst ist) nutzen.
Der Code des Übersetzer muss also *robust* sein und wir sollten *defensiv programmieren*.

Für den AST bedeutet dies, dass wir wegkommen müssen von der Vorstellung ein AST sei einfach eine Sammlung von Knoten und Kanten, welche zu der sehr minimalistischen, ersten Implementierung auf den Folien führt.
Dort sind alle AST Knoten vom gleichen Datentyp (~node_t~), unterschieden durch eine magische Ganzzahlkonstante (~tag~), und versehen mit einer unstrukturierten Liste aller Kinder (~std::vector<node_t>~).
Eine solche simplistische Darstellung ist zwar maximal flexibel ist, verhindert aber, dass wir die Host-Sprache voll ausnützen und führt außerdem zu wirklich unlesbarem Code.

Besser ist es da jeden AST-Knotentyp auf einen Typen der Host-Sprache abzubilden und seine Kinder unter sprechenden Namen bekannt zu machen.
Auf diese Weise können wir auch jedem Kind einen statischen Typen zuordnen und so verhindern, dass eine Typdeklaration als Operand einer Addition zuweisen.
Wir bekommen so ein weiteres Sicherheitsnetz durch das Typssystem.

#+begin_src latex
  \begin{frame}[fragile]{AST: Eine Hierarchie von Knotentypen}
    \bi
    \ii<+-> Die Grammatik legt bereits eine Hierarchie von Knotentypen nahe\\{
      \btSetNamedTab[1cm]{\first}%
      \first Grammatik:      \grammarrule{\NT{smt}}{assign\_stmt \OR while\_stmt \OR if\_stmt \OR \ldots}\\
      \first AST Definition: \codeinline[style=java]{class AssignStmt extends Stmt {...}}
    }
    \ii<+-> Zusammenfassung von Ähnlichkeiten verschiedener Knotentypen\\
        \textit{Beispiel}: Viele Deklarationen können einen Namen tragen. Lassen wir diese von \codebox{NamedDecl} erben, so können wir sie gleich behandeln.\medskip

    \ii<+-> Häufig verwendete Klassen von Knotentypen{
      \bi
      \ii \structure{Expression}: Ausdrücke die man auswerten kann und die ein Ergebnis liefern.\\
      \hspace{5mm}\textit{Beispiele:} Addition, Dereferenzierung, \codeinline{(<cond> ? <then> : <else>)}
      \ii \structure{Statement}: Anweisungen die sequentiell bearbeitet werden.\\
      \hspace{5mm}\textit{Beispiele:} if-else, Schleifen, Zuweisungen
      \ii \structure{Typen}: Literal notierte Typausdrücke.\\
      \hspace{5mm}\textit{Beispiele:} Typname, Typausdruck innerhalb eines Casts
      \ii \structure{Deklaration}: Jede statisch Bekanntmachung für den Compiler\\
      \hspace{5mm}\textit{Beispiele:} Variablendefinition, Klassendeklarationen, \codeinline[style=C]{typedef}
      \ei
    }
    \ei

  \end{frame}

  \begin{frame}[fragile]{AST: Zusätzliche Attribute}
    \vspace{-1ex}
    \bi
    \ii Der Parser erzeugt die Knoten und die Baumstruktur.{
      \bi
      \ii \structure{Parseraktionen} machen dies nebenher, wenn eine Regel angewendet wird:\\
         \codeinline!while_stmt -> WHILE ( expr ) body         { new WhileStmt(cond=T3, body=T5) }!
      \ii \codebox{expr} ist ein Expression Knoten und ist über T3 zugreifbar.
      \ei
    }
    \ii<2-> Semantische Analyse berechnet zusätzliche \structure{Attribute}{
      \bi
      \ii Datenhaltung während Analyse, Wissensbasis für den Rest des Übersetzers
      \ii \textit{Beispiel}: Berechneten Typ einer Expression, Zeiger auf die Deklaration.
      \ei
    }
    \ei

    \begin{columns}<3->[t]
      \begin{column}{0.49\textwidth}
        \begin{code}[tag=Python]
          \lstinputlisting[style=py,style=smaller,linerange={range0-range1}]{lst/05-DeclRefExpr.py}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \btAnimation[width=0.9\textwidth]{raisebox,center,1:<1->}{fig/05-member-expr.pdf}
      \end{column}
    \end{columns}
  \end{frame}
  #+end_src

Wenn wir auf die Grammatik einer Sprache schauen, sehen wir oft auch eine Hierarchie der einzelnen Knotentypen.  
So beinhaltet ein Codeblock mehrere Statements, aber jedes Statement kann entweder eine Zuweisung (~assign_stmt~), eine Schleife (~while_stmt~), eine Bedingung (~if_stmt~), usw. sein.
Diese Flexibilität können wir auch im Code des Übersetzers gewinnbringend abbilden, indem wir eine Vererbungshierarchie von Knotentypen definieren.
Dies ermöglicht es uns die statischen Typen für Kinder weiterhin möglichst strikt zu halten:

#+begin_src java
class CodeBlock extends Statement {
   public List<Statement> stmts;
}
#+end_src

Außerdem können wir Eigenschaften in mehrere Knotentypen vorkommen in eine Oberklasse heraus zu destillieren.
In der Vorlesung zur Namensauflösung haben wir über benannte Deklarationen geredet, ein Aspekt der Sprache den man in einer Klasse ~NamedDecl~ (mit ~.name~ Attribut) abbilden kann.
Auf diese Weise kann der Code zur Namensauflösung Variablen- als auch Funktionsdeklarationen gleich behandeln.

Grundsätzlich hat man in übersetzten Sprachen vier Knotentypen, die üblicherweise als Wurzel der Vererbungshierarchie für AST Knoten dienen:
Expressions (Ausdrücke), Statements (Anweidungen), Typen und Deklarationen.
Diese vier Knotentypen sind auch Vokabel, die Sie als effektiver Lerner einer neuen Sprache brauchen um einen Text über die Sprache leicht verstehen zu können.

*Expressions* sind all jene Konstrukte, die bei ihrer Ausführung einen Ergebniswert liefern.
So ist eine Addition ebenso eine Expression wie ein Literal eine Expression ist[fn::Der Ausdruck (1+2) besteht aus drei Expressions. Zählen Sie diese auf!].
Bei Expressions gibt es auch weniger intuitive Überraschungen:
So funktioniert der ternäre ~?:~-Operator zwar wie ein if-else, ist aber eine Expression das er einen Ergebniswert liefert.
Auch Definition einer C-Funktion keine Expression, dafür aber ihr Aufruf (~CallExpr~).

*Statements* sind Anweisungen die von der virtuellen Maschine, welche diese definiert, sequentiell abgearbeitet werden.
Zu den Statements gehören alle Zuweisungen und alle Kontrollflusskonstrukte (Bedingungen, Schleifen).
Für C kann man, in etwa sagen, dass jede semantisch-zusammengehörige Programmzeile ein Statement ist.

Die *Typ*-Knotentypen[fn::Jetzt nicht verwirren lassen!]
sind jene syntaktischen Elemente mit denen wir Typausdrücke im Code notieren.
Diese brauchen wir zum Beispiel für ~typedef~, zur Notation von Parametertypen einer Funktion oder als Inhalt einer Cast-*Expression*[fn::Überlegen Sie sich für ~(void *) a~, was hier Expression und was ein Typknoten ist.].
Die Typ-Knotentypen können wir direkt als Typausdrücke verwenden, was eine Dopplung von Klassen vermeidet (~ast.IntType~ vs. ~type_expr.IntType~).

*Deklarationen* sind all jene Programmstrukturen, die dem Übersetzer etwas bekannt machen.
Dies beinhaltet sowohl Variablendefinition als auch ~typedef~-Konstrukte.
Deklarationen sind das statische Rückgrat der Programmstruktur.
Wir hängen Typen an die Deklaratione und füllen sie mit Statements, die wiederum Expressions beinhalten.

#+begin_src latex
  \begin{frame}{Clang: AST Knoten und ihre Attribute}
    \begin{center}
      \btImage[text width=0.7\textwidth,draw,label=below:\scriptsize Ausschnitt aus der Klassenhierarchie]{fig/05-llvm-named-decl-tree}
      \medskip

      \btImage[text width=0.7\textwidth,draw,label=below:\scriptsize Öffentliches Interface von \texttt{clang::NamedDecl}]{fig/05-llvm-named-decl-member}
    \end{center}
  \end{frame}

  \begin{frame}[fragile]{Clang: AST für ein einfaches Programm}
    \begin{columns}
      \begin{column}{0.4\textwidth}
        \begin{code}[tag=C]
          \lstinputlisting[style=CPP,style=smaller,numbers=left,]{lst/05-example.cc}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.59\textwidth}
        \bii
        \ii CLang: C/C++ Frontend für LLVM
        \ii Source-to-Source Transformation
        \ii \texttt{clang::VarDecl} ist ein \texttt{clang::NamedDecl}
        \eii
      \end{column}
    \end{columns}

    \begin{btBlock}{\$ clang -Xclang -ast-dump -fsyntax-only /tmp/test.cc}
      \scriptsize
      \input{fig/05-clang-output}
    \end{btBlock}
  \end{frame}

#+end_src

Die hier vorgeschlagene Klassenhierarchie, bestehend aus Deklarationen, Expressions, Statements und Typen, findet sich auch im LLVM C-Frontend CLang.
Dort erben, beispielsweise, alle Deklarationen, die einen Namen einführen könnten, von ~NamedDecl~.
Werfen Sie einen Blick auf die Vererbungsbeziehungen von [[https://clang.llvm.org/doxygen/classclang_1_1NamedDecl.html][NamedDecl]] in der automatisch generierten Dokumenation von CLang.
Wenn Sie sich noch mehr für die Implementierung eines real existierenden Übersetzers interssieren bietet auch die [[https://clang.llvm.org/docs/IntroductionToTheClangAST.html]["Introduction to the CLang AST"]] einen guten Einstieg.
Dort gibt es auch den Hinweis zum [[https://clang.llvm.org/docs/RAVFrontendAction.html][RecursiveASTVisitor]], der das später beschriebene Visitor-Pattern für den CLang AST implementiert.
Mit seiner Hilfe ist es leicht möglich CLang Plugins zu bauen, welches Operationen auf C/C++ Code ausführt. Es ist diese einfache Zugänglichkeit, das relativ moderne Design, und eine existente Dokumentation, die CLang (und LLVM) zu einer guten Basis für Forschung im Bereich des Übersetzerbaus macht.

Auf den Folien ist auch eine textuelle Representation des CLang ASTs für ein kurzes Programm gezeigt.
Dort können wir die einzelnen Aspekte eines gut handhabbaren ASTs direkt sehen.
Alle Elemente einer Übesetzungseinheit[fn::Eine Übersetzungseinheit ist die (oder mehrere) C-Dateien, die zu einem Object-File (.o-Datei) übersetzt werden.]
sind unter dem Wurzelknoten ~TranslationUnitDecl~ gespeichert; in unserem Beispiel ist dies genau die gezeigte Funktion.
Innerhalb des ASTs finden wir Statements und Deklarationen, die sich ineinander schachteln. Jedem dieser Knotentypen entspricht eine C++ Klasse innerhalb CLang API.

An jedem Knoten wird seine Adresse im Speicher ausgegeben um Referenzierung innerhalb der Ausgabe zu erlauben. Diese Adressen sind nicht Teil der Programmstruktur und sie können sich mit jedem Aufruf des Übersetzers ändern. Die einzelnen Knoten sind zum einen entlang ihrer Baumkanten in einer Eltern-Kind-Beziehung verbunden, und zum anderen über die Querverbindungen welche die Namensauflösung eingeführt hat. So Referenziert die  ~DeclRefExpr~ in der letzten Zeile den ~VarDecl~ Knoten, welcher die lokale Variable ~result~ eingeführt hat.

Eigentlich sind auch die Typknoten Teil der Baumstruktur.
In der hier gezeigten textuellen Darstelung werden sie allerdings, der Übersichtlichkeit halber, nicht als eigene Knoten dargestellt, sondern "nur" als Attribute von anderen Knoten.
So hat die ~FunctionDecl~ für unsere Funktion ~f~ den Typen ~"int (int)"~.
Arbeitet man allerdings programmatisch mit dem CLang AST, so stellen sich diese Typen allerdings auch als Baum dar und entsprechen den von uns besprochenen Typausdrücken.
In unserer Sprache könnte man auch sagen, dass die Typ-AST Knoten zu einem Typausdruck zusammengefaltet wurden und als Knotenattribut
an die Deklarationen/Statements geheftet wurden.

* Informationsfluss auf Bäumen
:PROPERTIES:
:CUSTOM_ID: 05-attribute-flow
:END:

#+begin_src latex
  \begin{frame}[t]{Semantische Regeln als Attributgleichungen}
    \bi
    \ii Die sem. Analyse berechnet die Werte der Attribute für jeden Knoten{
      \bi
      \ii Attribute hängen von anderen (benachbarten) AST Knotenattributen ab.
      \ii Abstrakte Sicht: Gleichungssystem mit Gleichungen für jeden Knotentyp
      \ii Reihenfolge der Auswertung ist nicht fest gelegt.
      \ei
    }
    \ei
    \begin{btBlock}[type=example]{\textbf{Beispiel}: Höhe (h) und Wert (v) in einem Additionsbaum}
      \btAnimation[width=0.9\textwidth]{center,1:<1>,range=1-9:<2->}{fig/05-attribute-tree}
      \btAnimation[width=0.6\textwidth]{center,10:<11->}{fig/05-attribute-tree}
    \end{btBlock}
    \bi
    \ii<11-|handout:11-> \structure{Attributgrammatiken} annotieren die Regeln direkt an die Produktionen\\
    \bi
    \ii \codebox{\small\ttfamily\grammarrule{plus}{expr + expr}\hspace{1cm}\{ \$0.h = max(\$1.h, \$3.h) + 1 \}}
    \ii Parseaktionen (Parsebaum$\rightarrow$AST) sind bereits Attributgrammatiken
    \ei
    \ei
  \end{frame}
  #+end_src

Wir wollen uns nun der semantischen Analyse etwas formaler nähern um auf einer abstrakteren Ebene zu verstehen, was da eigentlich gemacht wird.
Ich habe bereits in der Einführung gesagt, dass wir für jeden AST Knoten *Attribute*, wie den Typ, ausrechnen werden.
Diese Attribute hängen von der Nachbarschaft des Knotens ab und erlauben es kontext-sensitive Sprachregeln abzubilden.
Eine solche kontext-sensitive Sprachregel wäre zum Beispiel, dass die Operanden einer Addition zwei Ganzzahlen sein müssen und das Ergebnis der Addition wiederum eine Ganzzahl ist.

Abstrakt gesehen bilden die Knotenattribute untereinander ein *Gleichungssystem*[fn::Dies ist ein wichtiger Satz!].
An jedem Knoten definieren wir die Attribute als Gleichungen, welche die Attribute anderer Knoten als Variablen verwenden.
Die Form dieser Gleichungen ist in den semantischen Regeln der Sprache festgelegt und sind abhängig vom Knotentyp. Sie werden dann für jeden Knoten, anhand der Blaupause in den Sprachregeln, instanziiert.
In Verlauf der semantischen Analyse lösen wir dieses Gleichungssystem auf indem wir konkrete Werte für die Attribute berechnen. Dabei ist die *Reihenfolge der Berechnenung nicht vorgegeben*!

Um dieses wichtige Prinzip zu veranschaulichen, zeigen die Folien einen sehr einfachen AST mit nur 2 Knotentypen (Literal, Addition), für den wir zwei Attribute (Höhe und Summe) ausrechnen wollen.
Ich wähle hier absichtlich zwei Attribute, die nichts mit Übersetzern zu tun haben um klar zu machen, dass diese Gleichungssysteme aus Attributen ein allgemeines Prinzip sind und keine spezialisierte Übersetzertechnik ist.
Die Herangehensweise Knotenattribute als symbolische Gleichungen zu beschreiben, ohne dass man darüber nachdenkt wie man diese Attribute ausrechnet, erlaubt es uns konzentrierter über die Beziehungen der Knoten nachzudenken und uns nicht in rekursiven Traversierungslogiken zu verirren.

Die Analyse beginnt damit, dass wir die Gleichungen aus den semantischen Sprachregeln für jeden Knoten instantiieren und die konkrete Nachbarschaft einsetzen.
Für die literalen Blätter ist die Baumhöhe immer 1 und die Summe der Ganzzahlwert des angehängten Tokens.
Für ~plus~-Knoten, die nur als innere Knoten auftreten können, ist das Attribut ~v~, die Summe der ~v~-Attribute der Kinder; Für die Höhe ist es das Maximum der Höhe der beiden Unterbäume, plus eins.
Um dieses Gleichungssystem zu verstehen, stelle ich mir immer vor ganz lokale auf einem der Knoten zu stehen:
Dort sehe ich genau die ausgehenden Kanten zu den Kinds- und zum Elternknoten, und kann von den Gleichungen sagen, dass Sie im prinzip wahr sind.
So kann ich mir auf einem ~plus~-Konten sagen:
"Ich bin ~x~ und meine Wert ~x.v~ ist die Addition der Werte ~v~ meiner linken Seite (~x.lhs.v~) und meiner rechten Seite (~x.rhs.v~)!
Das sollte mal jemand ausrechnen, und mir ist eigentlich auch egal wie!"

Nachdem wir die Attributgleichungen aufgestellt haben, geht es daran diese Aufzulösen.
Als Mensch können wir hergehen, auf den gesamten AST blicken und eine Attributgleichung auflösen, für die alle benötigten Werte bereits ausgerechnet sind.
Das habe ich für das Folienbeispiel gemacht, was zu einer sehr eratischen Berechungsreihenfolge geführt hat.
Das war pädagogische Absicht um ihnen nochmals zu sagen:
Die Berechnungsreihenfolge ist in den Attributen nicht festgelegt!

Diese Attribute-getriebene Herangehensweise an die semantische Analyse hat einen breiteren theoretischen Hintergrund, in Form von *Attributgrammatiken*, dessen Details ich ihnen hier ersparen möchte.
Für unsere Zwecke reicht es aus, dass sie eine Intuition dafür entwickeln, was dabei ungefähr passiert.
Bei einer Attributgrammatik legt man nicht für jeden AST Knotentyp eine semantische Regel fest, sondern für jede Produktion der Grammatik.
Solange allerdings alle Grammatik-Regeln die eine bestimmte Knotenart erzeugen, die selbe Gleichung haben, ist unser vorgestelltes Modell von Attributgleichungen äquivalent zu Attributgrammatiken.

Ein Beispiel für solche Attributgrammatiken sind die *Parseraktionen*, die viele Parsergeneratoren erlauben.
Dabei wird ein Stück Code an jede Regeln geheftet, welches der Parser ausgeführt wenn er die Grammatik-Regel anwendet.
In der Übung werden wir solche Parseraktionen allerdings nur verwenden um den AST während des Parsevorgangs zu konstruieren ohne zuerst den vollständigen Syntaxbaum zu erzeugen.

#+begin_src latex
  \begin{frame}{Abhängigkeitsgraphen und Attributtypen}
    \bi
    \ii Attribut-Gleichungssystem beinhaltet einen \structure{Abhängigkeitsgraphen} {
      \bi
      \ii Für jedes Attribut auf der rechten Seite gibt es eine Abhängigkeit
      \ii Topologische Sortierung bestimmt die Auswertereihenfolge
      \ii Verschiedene Verfahren für unterschiedliche Typen von Abhängigkeiten
      \ei
    }
    \begin{columns}[t]
      \begin{column}<2->{0.32\textwidth}
        \begin{center}
          \includegraphics[height=2.5cm,page=1]{fig/05-dependency-tree}\\
          \structure{Synthetische Attribute}
          \scriptsize \enquote{von unten nach oben}
        \end{center}
        \bii
        \ii S-Attribute
        \ii Abhängig von Kindern
        \ii Typen in Expressions
        \ii Technik: Traversierung
        \eii
    \end{column}\hfill
    \begin{column}<3->{0.33\textwidth}
      \begin{center}
        \includegraphics[height=2.5cm,page=2]{fig/05-dependency-tree}\\
        \structure{Geerbte Attribute}\\
        \scriptsize \enquote{von links nach rechts}
      \end{center}
      \bii
      \ii L-Attribute
      \ii Abhängig von Vorgängern und Nachbarn
      \ii Namensauflösung
      \ii Technik: Symboltabelle
      \eii
    \end{column}
    \begin{column}<4->{0.33\textwidth}
      \begin{center}
        \includegraphics[height=2.5cm,page=3]{fig/05-dependency-tree}\\
        \structure{Zyklen Abhängig.}
        \scriptsize \enquote{all-over-the-place}
      \end{center}
      \bii
      \ii Fixpunktberechnung
      \ii Eher zu vermeiden
      \ii Typinferenz in Haskell
      \ii Technik: Unifikation
      \eii
    \end{column}
    \end{columns}

    \ei

  \end{frame}

#+end_src

Nun wollen wir uns der maschinellen Berechnung der AST Attribute zuwenden. Dazu wollen wir uns zunächst die Struktur der aufgestellten Gleichungssysteme nähern, indem wir über die *Abhängigkeiten* zwischen den Knotenattributen nachdenken.
Für jedes Attribut dass auf der rechten Seite einer Gleichung auftaucht gibt es eine Berechnungsabhängigkeit zwischen diesem Knoten und dem Attribut des referenzierten Knoten. Es ensteht ein *Abhängigkeitsgraph*, bei dem die Attribute die Knoten und die Abhängigkeiten die Kanten sind.

Im Beispiel mit der Baumhöhe erzeugt die Gleichung ~x.h = max(x.lhs.h, x.rhs.h) + 1~ zwei Kanten im Abhängigkeitsgraphen. Diese Kanten gehen vom Attribut ~x.h~ zu den Höhnenattributen der beiden Kinder von ~x~. Die Gleichungen für die Summe eines ~plus~-Knotens erzeugt ebenfalls zwei Abhängigkeiten, ebenfalls gerichtet auf direkte Kindsattribute.

Würden wir ganz generell eine Berechnungsreihenfolge für diesen Abhängigkeitsgraphen angeben wollen, so würden wir die Attribute *toplogisch Sortieren*. Eine topologische Sortierung bedeutet, dass wir alle Attribute, aus dem gesamten AST, in eine Reihenfolge bringen, sodass alle Abhängigkeiten erfüllt sind, wenn ein Attribut an die Reihe kommt. Für die Höhe des Beispielbaums wäre die Reihenfolge ~[B.h, D.h, E.h, C.h, A.h]~ eine topologische Sortierung für den enstandenen Abhängigkeitsgraphen. *Aufgabe:* Vollziehen Sie diese Reihenfolge anhand des Baums nach!

Allerdings wäre es viel zu aufwendig, den Abhängigkeitsgraphen tatsächlich aufzustellen und dann topologisch zu sortieren.
Er ist nur ein gedankliches Modell um auf eine praktikable Berechnungsvorschrifft zu kommen, die implizit die topologische Berechnungsreihenfolge erzeugt. Dazu teilen wir die Abhängigkeiten der Attribute in unterschiedliche Klassen ein.

Bei *synthetischen Attributen* (S-Attribute) erzeugen die Sprachregeln nur Abhängigkeiten zu den Kindern, sodass der Wert eines Knotens genau dann ausgerechnet werden kann, wenn die Werte all seiner Kinder ausgerechnet sind.
Die Abhängigkeiten eines S-Attributs sind also streng hierarchisch "von unten nach oben".
Die Attribute Höhe und Summe aus unserem Beispiel sind ebensolche S-Attribute.
Aber auch die Ergebnis-Typen von arithmetrischen Ausdrücken sind synthetisch[fn::Ich finde den Namen "synthetische Attribute" so überhaupt nicht sprechend, aber so heißen diese Attribute nunmal in der Literatur.]. 
Die Technik für solche Attribute ist die Baumtraversierung, genauer gesagt die Baumtraversierung mit Post-Order Reihenfolge[fn::Wie bei der Titanic: Post-Order=Kinder zuerst!]. Wir werden uns diese im folgenden genauer ansehen.

Bei *geerbten Attributen* (L-Attribute) zeigen die Abhängigkeiten "nach links" in den Baum.
Ein L-Attribut kann also von Attributen von "älteren" Geschwistern und den Eltern-Knoten abhängen.
Bilden wir dies auf einen Programmcode ab, so hat ein L-Attribut nur Abhängigkeiten zu Elementen die weiter oben in der Datei stehen.
Ein Beispiel für solche L-Attribute sind Namensreferenzen, die auf vorher deklarierte Namen zeigen müssen.
Wir werden solche L-Attribute mittels der Symboltabelle und einer Baumtraversierung berechnen.
Dabei ist die Symboltabelle eine Art "Datenrucksack" den wir während der Baumtraversierung mit uns herumtragen und mit Informationen füllen.

Die dritte Art von Attributen sind die "zyklischen Attribute". Bei diesen sind beliebige Abhängkeiten zwischen den Knoten des ASTs möglich; eben auch zyklische Abhängigkeiten. Traditionell haben Sprachdesigner solche zyklischen Attribute eher vermieden, da sie relativ komplex auszurechnen sind und sie nicht mittels einer einfachen Baumtraversierung aufgelößt werden können. Allerdings kann man mittels zyklischer Attribute das Problem der Typinferenz formulieren. Deswegen werfen wir einen kurzen Blick auf die Technik der *Unifikation*, die es erlaubt solche zyklischen Attribute zu berechnen.

Im Folgenden werde ich also drei Techniken vorstellen um unterschiedliche Typen von Attributen zu berechnen:
Baumtraversierung (S-Attribute), Symboltabelle (L-Attribute) und Unifikation (zyklische Attribute).  Los gehts!

** Traversierung von Bäumen
#+begin_src latex
  \begin{frame}[t]{Traversierung von Bäumen}
    \begin{btBlock}{Berechnung der synthetischen Attribute}
      Wir müssen \textbf{jeden Knoten} besuchen, \textbf{knotenspezifischen} Code ausführen, und die Attributwerte \textbf{von unten nach oben} propagieren.
    \end{btBlock}
    \medskip

    \begin{columns}[t]<2->
      \begin{column}{0.49\textwidth}
        \begin{code}[tag=Python]
          \lstinputlisting[style=py,linerange={v0s-v0e}]{lst/05-traversal.py}%
          \uncover<3->{%
            \lstinputlisting[style=py,linerange={v1s-v1e}]{lst/05-traversal.py}%
          }%
          \uncover<4->{%
            \lstinputlisting[style=py,linerange={v2s-v2e}]{lst/05-traversal.py}%
          }
        \end{code}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \structure{Baumtraversierung (Post-Order)}
        \bii
        \ii Bäume sind rekursiv.
        \ii Jeden Knoten besuchen auch!\\[5ex]
        \ii<3-> Dynamischer Typ des Knoten
        \ii<3-> Zugriff auf Attribute der Kinder
        \ii<3-> Attributgleichung ausrechnen\\[6ex]
        \ii<4-> Setzen des Attributs
        \ii<4-> Wert im Aufrufer verfügbar
        \eii

      \end{column}
    \end{columns}
  \end{frame}

  \begin{frame}{Probleme von Ad-Hoc Traversierung}
      \textbf{Ironie}: Das geht aber noch mehr ad-hoc und unlesbar!
      \begin{center}
        \begin{minipage}{0.5\linewidth}
        \begin{code}[]
          \lstinputlisting[style=py,linerange={v3s-v3e}]{lst/05-traversal.py}
        \end{code}
        \end{minipage}
      \end{center}

      \bi
      \ii<2-> Die \structure{Attributgleichungen} gehen im \alert{fragilen} Boilerplate unter{
        \bi
        \ii Duplikation der Traversierungslogik für jedes Attribut
        \ii Duplikation der \codebox{isinstance} Kaskade für jedes Attribut
        \ii Ein neuer AST Knotentyp $\rightarrow$ N Traversierungsfunktionen anpassen.
        \ei
      }\medskip
      \ii<3-> Wende informatische Super-Power \alert{"Trennung der Belange"} an! {
        \bi
        \ii Attributgleichungen werden in einer Besucherklasse gekapselt
        \ii Generischer Code für Traversierung in definierter Ordnung
        \ei
      }
      \ei
  \end{frame}

  \begin{frame}[fragile]{Visitor-Pattern: Operationen auf Knoten kapseln}
    \begin{code}[tag=C++]
      \lstinputlisting[style=CPP,linerange={Vs-Ve}]{lst/05-visitor.cc}
    \end{code}
    \bi
    \ii Bündelung der Attributgleichungen in einem Visitor-Objekt {
      \bi
      \ii Die \codebox{visit()} Funktion wird für jeden Knotentyp überladen
      \ii Visitor-Objekt kann zusätzlichen Zustand als Member speichern
      \ii Vererbungshierarchie kann beachtet werden (\codeinline[style=CPP]{void visit(NamedDecl D)})
      \ei
    }
    \ei

    \begin{columns}<2->
      \begin{column}{0.49\textwidth}
        \begin{code}[]
          \lstdefinestyle{error}{
            escapechar=`,
            moredelim=**[is][{\btHL[fill=srared!50!white,name=error]<3->}]{@}{@},
          }
          \lstinputlisting[style=CPP,style=smaller,style=error,linerange={Ts-Te}]{lst/05-visitor.cc}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.48\textwidth}
        \structure{Generische Traversierung}
        \bii
        \ii Knoten haben Liste der Kinder
        \ii Definierte Besuchsreihenfolge
        \ii Visitor wird auf jeden Knoten angewendet.
        \eii
      \end{column}
    \end{columns}
    \begin{tikzpicture}[remember picture,overlay]
      \only<3>{
        \draw(error) -- ++(0:2cm) node[right,fill=srared!20!white,draw=srared,thick,align=left]{Das ist so kaputt!\\
          Dynamischer Dispatch nur im nullten Argument!\\
        Ruft immer \fbox{\texttt{Visitor::visit(Tree)}} auf!};
      }
    \end{tikzpicture}
  \end{frame}

  \begin{frame}[fragile]{Visitor-Pattern: Double Dynamic Dispatch}
    \begin{btBlock}[type=alert]{Statische Typen an der Aufrufstelle: \texttt{visit(Visitor, Tree)}}
      Bei der Traversierung soll \texttt{visit(v, t)} für das konkrete Visitor-Objekt und spezifisch für den AST Knoten aufgerufen werden.\\
      \begin{columns}
        \begin{column}{0.49\textwidth}
          \begin{CPP}[style=smaller]
            visit(HeightVisitor, literal)
            visit(HeightVisitor, plus)
          \end{CPP}
        \end{column}\hfill
        \begin{column}{0.49\textwidth}
          \begin{CPP}[style=smaller]
            visit(ValueVisitor,  literal)
            visit(ValueVisitor,  plus)
          \end{CPP}
        \end{column}
      \end{columns}
    \end{btBlock}

    \bi
    \ii<2-> Dynamischer Dispatch in den \textbf{ersten zwei Argumenten} nötig{
      \bi
      \ii Emulation mittels zweifachem virtuellen Methodenaufruf.

      \btAnimation[width=0.9\textwidth]{center,padding top=1ex,1:<1-2>,range=2-3:<3->}{fig/05-accept-visit}

      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[fragile]{Visitor-Pattern: Dispatch mit Introspection}
    \bi
    \ii Python hat Überladung nur im ersten Argument (self), dafür dynamisch!{%
      \bi
      \ii Keine statischen Typen $\Rightarrow$ Keine doppelte Definition von Methoden.
      \ii Jedoch kann man Namensauflösung zur Laufzeit durchführen.
      \ei
    }
    \ei
    \vspace{-1em}
    \begin{columns}<2->[t]
      \begin{column}{0.49\textwidth}
        \begin{code}[]
          \lstinputlisting[style=py,style=smaller,style=error,linerange={tgs-tge}]{lst/05-traversal.py}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \begin{code}[]
          \lstinputlisting[style=py,style=smaller,style=error,linerange={vgs-vge}]{lst/05-traversal.py}
          \vspace{-1ex}
        \end{code}
        \begin{code}[]
          \lstinputlisting[style=py,style=smaller,style=error,linerange={igs-ige}]{lst/05-traversal.py}
        \end{code}
      \end{column}
    \end{columns}

    \bi
    \ii<2-> Emulation von Überladung durch Introspektion{
      \bi
      \ii \codeinline[style=py]{type(T)} extrahiert den \textbf{dynamischen} Typen des Knotens
      \ii \codeinline[style=py]{M_name = "visit_" + ...} erzeugt dynamisch einen \textbf{Namen}
      \ii \codeinline[style=py]{getattr(V, "visit_plus")} löst den Namen; gibt die Methode zurück
      \ei
    }
    \ei
  \end{frame}
#+end_src
  - Synthetische Attribute
  - Visitor Pattern: Emulate Double Dispatch

#+begin_src latex
   \begin{frame}{Berechnung des Typen und Typkonsistenz}
    \vspace{-1ex}
    \bi
    \ii S-Attribut: Für \structure{Expressions} berechnen wir Typen (bottom-up) {
      \bi
      \ii \structure{Blätter}: \btDefTab Konstante Literale (23, "foobar") haben feste, eingebaute Typen\\
                   \btUseTab Namensreferenzen haben Typen der Deklaration (später mehr)
      \ii \structure{Innere Knoten}: Jeder Knotentyp hat eine Typ-Gleichung.\\
                   \btUseTab Jeder Knoten propagiert seinen Ergebnistypen nach oben.\\
      \ei
      \OrangeBox{Typberechnung und -prüfung geschiet \enquote{in einem Rutsch}!}
    }
    \ei

    \begin{columns}<2->
      \begin{column}{0.52\textwidth}
        \raisebox{-\height}{%
          \begin{code}[]
            \lstinputlisting[style=py,style=smaller,linerange={V1s-V1e}]{lst/05-type-visitor.py}
            \vspace{-1ex}
            \uncover<3->{
              \lstinputlisting[style=py,style=smaller,linerange={V2s-V2e}]{lst/05-type-visitor.py}
            }\vspace{-1ex}
            \uncover<4->{
              \lstinputlisting[style=py,style=smaller,linerange={V3s-V3e}]{lst/05-type-visitor.py}
            }
          \vspace{-1ex}
        \end{code}
      }
      \end{column}\hfill
      \begin{column}{0.47\textwidth}
        \mbox{}\\[1ex]
        \structure{Minimalbeispiel}
        \bii
        \ii Monomorphes Typsystem
        \ii Ganzzahl und Pointertyp
        \ii Addition nur auf Ganzzahlen
        \eii

        \smallskip
        \begin{center}
          \includegraphics[height=2.5cm,page=1]{fig/05-dependency-tree}
        \end{center}
        \smallskip


      \end{column}
    \end{columns}
  \end{frame}
#+end_src
** Coercion: Automatische Typumwandlung
#+begin_src latex
  \dividerframe{Coercion:\\Automatische Typumwandlung}
  \begin{frame}{Automatische Typumwandlung}
    \begin{btBlock}{Was passiert bei inkompatiblen Typen?}\small
      Passen gefordertert (z.B. Parameter) und vorhandener Typ (z.B.Argument) nicht zusammen, kann eine \textbf{implizite} Typumwandlung eingefügt werden.
    \end{btBlock}

    \medskip
    \begin{columns}
      \begin{column}{0.40\textwidth}
        \includegraphics[width=\textwidth]{fig/05-coercion}
      \end{column}
      \begin{column}<2->{0.20\textwidth}
        \centering
        \Huge $\Rightarrow$
      \end{column}
      \begin{column}<2->{0.40\textwidth}
        \includegraphics[width=\textwidth,page=2]{fig/05-coercion}
      \end{column}
    \end{columns}

    \bi
    \ii<3-> Sprachen definieren eine Reihe von automatischen Typumwandlungen{
      \bi
      \ii \structure{Ganzzahlweitung}: Umwandlung in breitere Integer ohne Informationsverlust
      \ii C: \codebox{char}$\rightarrow$\codebox{short}$\rightarrow$\codebox{int}$\rightarrow$\codebox{long}
      \ii C++: Implizite Umwandlung von \codebox{void*} zu beliebigen Zeigern (z.B., \codebox{int *})
      \ei
    }
    \ei

  \end{frame}

  \begin{frame}{Einordnung der automatischen Typumwandlung}
    \btAnimation[width=0.8\textwidth]{center, padding, 4:<1->}{fig/03-polymorphismus}
    \bi
    \ii Automatisch umgewandelte Typen verhalten sich \structure{polymorph}!{
      \bi
      \ii \structure{Ad-Hoc}: Die Umwandlung ist abhängig vom konkreten Kontext
      \ii Typumwandlung \btDefTab ist polymorph auf Seite des Produzenten\\Überladung\btUseTab ist polymorph auf Seite des Konsumenten
      \ei
    }\smallskip
    \ii<2-> Manche Sprachen erlauben es nutzerdefinierte implizite Umwandlungen.{
      \bi
      \ii \structure{Converting constructors} (C++): Konstruktoren mit genau einem Argument ergänzen die eingebauten Regeln zur Typumwandlung.
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{Probleme der automatischen Typumwandlung}
    \begin{center}
      \includegraphics[width=4cm]{fig/05-js-triangle}
    \end{center}
    \bi
    \ii Implizite Typumwandlung können leicht zu Verwirrung führen!
        \bi
        \ii Javascript: Umwandlungen von Strings und leeren Arrays zur Zahl \texttt{0}\\
        \enquote{When using two equals signs [...] some funky conversions take place}
        \ii Inkonsistente Gleicheit: \codebox{([]!="0")} vs. \codebox{(([]==0)\&\&(0=="0"))}
        \ei
        \medskip
    \ii[$\Rightarrow$] Die traurige Wahrheit: JavaScript hat zusätzlich einen \texttt{===}-Operator.
    \ei
  \end{frame}
#+end_src
** Symboltabelle
#+begin_src latex

  \dividerframe{Namensauflösung\\mittels\\Symboltabelle}

  \begin{frame}[fragile]{Statische Namensauflösung als L-Attribut}
    \bi
    \ii Referenzen beziehen sich auf benannte, aber entfernte Deklarationen{%
      \bi
      \ii Deklaration muss vor der Benutzung stattfinden (im AST links)
      \ii Welche Deklaration gemeint ist, ist ein L-Attribut.
      \ei
    }
    \begin{columns}
      \begin{column}{3cm}
          \smallskip
          \begin{center}
            \includegraphics[height=2.5cm,page=2]{fig/05-dependency-tree}
          \end{center}
          \smallskip
      \end{column}\hfill
      \begin{column}{9cm}
        \structure{Vorgehen der Namensauflösung}
        \bii
        \ii Traversierung aller Deklarationen, Referenzen und Namensraumkonstrukte
        \ii \structure{Symboltabelle} speichert die aktuell sichtbaren Namen
        \ii Fortwährende Aktualisierung der Tabelle
        \ii Auflösung von Referenzen über API der Symboltabelle
        \eii
      \end{column}
    \end{columns}
    \ii<2-> \structure{Symboltabelle}: Mögliche API in Java\\[1ex]
    \begin{code}[tag=Java]
      \begin{java}
        interface SymbolTable {
          ...
          public void openNamespace(Tree NS);
          public void createName(Name name, Tree node);
          public Tree findName(Name name);
          public void closeNamespace(Tree NS);
          ...
        }
      \end{java}
    \end{code}
    \ei
  \end{frame}

  \begin{frame}[fragile]{AST Traversierung mit Symboltabelle}
    \begin{columns}[t]
      \begin{column}{0.49\textwidth}
        \begin{code}
          \lstinputlisting[style=py,style=smaller,linerange={V1s-V1e}]{lst/05-name-resolution.py}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \bii
        \ii Visitor hält eine Symboltabelle, die den aktuellen Kontext speichert.
        \ii \codeinline[style=py]{self.ST} ist der \enquote{Datenrucksack} für die Traversierung.
        \eii
      \end{column}
    \end{columns}

    \begin{columns}[t]<2->
      \begin{column}{0.49\textwidth}
        \begin{code}
          \lstinputlisting[style=py,style=smaller,linerange={V2s-V2e}]{lst/05-name-resolution.py}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \bii
        \ii Visitor muss es erlauben Code vor (\codebox{pre\_}) und nach (\codebox{post\_}) Besuch der Kindsknoten auszuführen.
        \ii \tikzmark{visitor} Einige AST Knoten öffen einen neuen Namensraum.
        \eii
      \end{column}
    \end{columns}

      \begin{columns}[t]<3->
      \begin{column}{0.49\textwidth}
        \begin{code}
          \lstinputlisting[style=py,style=smaller,linerange={V3s-V3e}]{lst/05-name-resolution.py}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \bii
        \ii Deklarationen führen Namen (\codebox{N}) für AST Knoten (\codebox{fn}) ein.
        \eii
      \end{column}
    \end{columns}

      \begin{columns}[t]<4->
      \begin{column}{0.49\textwidth}
        \begin{code}
          \lstinputlisting[style=py,style=smaller,linerange={V4s-V4e}]{lst/05-name-resolution.py}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \bii
        \ii Referenz \codebox{R} mittels Tabelle auflösen
        \ii Ergebnis (\codebox{decl}) als Attribut speichern
        \eii
      \end{column}
    \end{columns}

    \begin{tikzpicture}[remember picture,overlay]
      \only<2>{
        \draw (pic cs:visitor) ++(-1cm,5mm) -- ++(-80:1.2cm) node[below,fill=codecolor]{
          \lstinputlisting[style=py,style=smaller,linerange={ts-te}]{lst/05-name-resolution.py}
        };
      }
    \end{tikzpicture}
  \end{frame}

  \begin{frame}{Symboltablle als Stack von Namensräumen}
    \btAnimation[width=\textwidth]{range=1-12:<1->}{fig/05-symbol-table}
  \end{frame}

  \begin{frame}[fragile]{Erweiterte Traversierung bei der Namensauflösung}
    \bi
    \ii Beliebige Reihenfolge von Deklaration und Referenzen in einem NS{
      \bi
      \ii Java: Reihenfolge der Methodendefinition ist egal!
      \ii \textbf{Lösung:} Wir traversieren den AST \alert<1>{zweimal}.{
        \be
        \ii Einsammeln aller Deklarationen.Speicherung an den Knoten (z.B. \codebox{ClassDecl})
        \ii Auflösen der Referenzen beim zweiten Durchlauf
        \ee
      }
      \ei
    }
    \ei
    \bigskip
    \bi
    \ii<2-> Überladung von Funktionen anhand der statischen Signaturen{
      \bi
      \ii Typinformationen müssen bei der Namensauflösung bereit stehen
      \ii \textbf{Lösung}: Typberechnung und Namensauflösung im \alert<2>{selben Visitor} durchführen.\\
      \begin{code}[tag=Python]
        \begin{py}
          def post_CallExpr(self, call): # Post-Order: Bekannte Argumenttypen
             # 1. Berechnung der Statischen Signatur
             N = signature(call.func_name)
             for A in call.arguments:
               N.addParam(A.Type)

             # 2. Namensauflösung des komplexen Namens
             call.decl = self.ST.findName(N)

             # 3. Ergebnistyp der CallExpr
             call.Type = call.decl.ReturnType
        \end{py}
      \end{code}
      \ei
    }
    \ei
  \end{frame}
#+end_src
  - Geerbte Attribute
  - find_decl, find_decl_fun

** Unifikation
#+begin_src latex
  \dividerframe{Zyklische Attribute\\und\\Unifikation}

  \begin{frame}[fragile]{Zyklisch-abhängige Attribute}
    \begin{columns}
      \begin{column}{3cm}
        \includegraphics[height=2.5cm,page=3]{fig/05-dependency-tree}
      \end{column}\hfill
      \begin{column}{8cm}
        \bii
        \ii Zyklische Attribute erfordern komplexen Datenfluss{
          \bi
          \ii Knoten liefern Teilwissen um das Attribut
          \ii Gleichungssystem für Attribute ist \alert<-2>{selbst-referenziell}
          \ii Einfaches zyklisches Beispiel: \only<2->{\texttt{x.h = 1, y.h = 2}}\\
              \hfill\colorbox{badbee!20}{\parbox[b]{0.8\textwidth}{
                  \texttt{x.h = y.h - 1} \hspace{1cm}\textit{Konsekutive Zahlen}\\
                  \texttt{y.h = 2 * x.h} \hspace{1cm}\textit{Vielfachheit}
                }
              }\hfill
          \smallskip
          \ii<3-> ... wurden lange für Programmiersprachen gemieden.
          \ei
        }
        \eii
      \end{column}
    \end{columns}
    \bigskip\bigskip

    \bi
    \ii<4-> \structure{Typinferenz} erleichtert statische Typisierung, erzeugt aber Zyklen{
      \btUseExtraItemSep
      \bi
      \ii Inferenz: Ableitung der statischen Typen aus der Verwendung der Variablen
      \ii \codeinline{fun(x) { return x + 2 }} $\rightarrow$ Der Parameter x muss vom Typ \codeinline[style=C]{int} sein
      \ii \structure{Hindley-Milner Typinferenz} kombiniert zyklische Attribute mit\\ \textbf{parametrischem Polymorphismus}; Grundlage der \alert{funktionalen Programmierung}
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[fragile]{Typinferenz durch Ersetzung von Typvariablen}
    \begin{columns}
      \begin{column}{0.40\textwidth}
        \btAnimation[width=\textwidth]{range=1-6:<1->}{fig/05-inference}
      \end{column}\hfill
      \begin{column}{0.58\textwidth}
        \OrangeBox{Was ist der Typ von \codebox{append(p1, p2)}?}
        \smallskip
        \bii
        \ii Blätter: Einsetzen des vorhandenen Wissens{%
          \bi
          \ii Die Variable p2 hat Typ \codebox{int}
          \ii \codebox{append()} ist generische Funktion und hängt ein Element an homogene Liste an
          \ii Alles unbekannte wird durch eine \structure{freie Typvariable} ($\alpha, \beta, \gamma$) dargestellt.
          \ei
        }\medskip
        \ii<2-> Regeln als \structure{parametrische Bedingungen}{%
          \bi
          \ii CallExpr: Die Signatur der aufgerufene Funktion muss zu den Argumenten passen.
          \ii Rückggabetyp (E.T) soll ermittelt werden
          \ei
        }\medskip
        \ii<3->Variablen-Elimination durch \structure{Ersetzungen}{
          \bi
          \ii \textbf{Ziel:} \alert<-5>{Bedingungen müssen erfüllt} sein
          \ii Ersetztung: Variable $\rightarrow$ Typausdruck
          \ii Finde Sequenz \only<6>{\color{safegreen}\bfseries}{unifizierender Ersetztungen}
          \ei
        }
        \eii

      \end{column}
    \end{columns}
  \end{frame}

  \begin{frame}{Unifikation: Berechnung von passenden Ersetzungen}
    \begin{btBlock}{Unifikation}
      Finden eine Sequenz von Variablen-Ersetzungen, die zwei Terme angleicht.
    \end{btBlock}
    \medskip
    \begin{columns}
      \begin{column}{0.49\textwidth}
        \hspace{3mm}$T_1=\text{func}(\text{list}(\gamma),$ \btSetNamedTab\first $\gamma$,\hspace{1em}\btSetNamedTab\second$ \text{list}(\gamma))$\\
        \hspace{3mm}$T_2=\text{func}(\beta,$\first $\text{int},$ \second$\alpha)$\\[1ex]
      \end{column}
      \begin{column}<2->{0.49\textwidth}
        $U=\{\underbrace{\alpha\mapsto \beta}_{S_1}, \underbrace{\beta\mapsto list(\gamma)}_{S_2}, \underbrace{\gamma\mapsto\text{int}}_{S_3}\}$
      \end{column}
    \end{columns}
    \medskip
    \begin{columns}[t]
      \begin{column}{0.49\textwidth}
        \structure{Typausdrücke mit freien Variablen}
        \bii
        \ii Typ(konstruktoren): int, func, List
        \ii Variablen: $\alpha, \beta, \gamma$
        \ii Variablen können in beiden Termen, auch mehrfach, vorkommen%
        \eii
      \end{column}
      \begin{column}<2->{0.49\textwidth}
        \structure{Unifizierende Ersetzung}
        \bii
        \ii Ersetzungssequenz: $S_1\circ S_2 \circ S_3$
        \ii Reihenfolge ist relevant!
        \ii \textbf{Allgemeinster Unifikator} nimmt nur notwendige Ersetzungen vor.
        \eii
      \end{column}
    \end{columns}

    \bigskip\bigskip
    \bi
    \ii<3-> Mehrere Unifikations-Algorithmen \texttt{unify($T_1$, $T_2$)$\rightarrow U$}{
      \bi
      \ii Erster Algorithmus von Robinson (1965) hat exponentielle Laufzeit
      \ii Lineare Laufzeit: Paterson, Wegman (1978); Martelli, Montanari (1982)
      \ei
    }
    \ei
  \end{frame}

#+end_src

https://eli.thegreenplace.net/2018/unification/

* Zusammenfassung
#+begin_src latex
  \begin{frame}{Zusammenfassung: Semantische Analyse}
    \bi
    \ii Semantische Analyse prüft die restlichen, kontextsensitiven Sprachregeln{
      \bi
      \ii \structure{Namensauflösung}: Gibt es zu jeder Referenz es eine Deklaration?
      \ii \structure{Typkonsistenz}:  Werden die statische Typen korrekt verwendet?\\[1ex]
      \ii[\color{srared}$\Rightarrow$] Nach der semantischen Analyse haben wir ein korrektes Programm vor uns!
      \ei
    }\medskip
    \ii<2-> Berechnung der \structure{semantischen Attribute} für jeden Knoten (z.B. Typ){
      \bi
      \ii Attribute sind Abhängig von anderen (auch entfernten) Knotenattributen\\
          $\Rightarrow$ Gleichungssystem zwischen allen Knotenattributen\\[1ex]
      \ii \structure{S-Attribut}: Nur Abhängigkeiten zu den eigenen Kindern \hfill(\enquote{nach unten})
      \ii \structure{L-Attribut}: Abhängigkeiten von Geschwister und Vorgängern \hfill(\enquote{nach links})
      \ii \structure{Zyklische Attribute}: Wechselseitig-abhängige Attributgleichungen
      \ei
    }\medskip
    \ii<3-> \structure{Übersetzertechniken} zur Attributberechnung und Regelprüfung{
      \bi
      \ii \structure{Baumtraversierung}: Visitor bündelt Knotentyp-abhängige Operationen
      \ii \structure{Symboltabelle}: Speichert die aktuell deklarierten Namen beim Traversieren
      \ii \structure{Unifikation}: Angleichung von parametrischen Typausdrücken durch Ersetzung
      \ei
    }
    \ei
  \end{frame}

#+end_src
