#+TITLE: Programmiersprachen und Übersetzer
#+SUBTITLE: 05 - Semantische Analyse
#+SETUPFILE: setup.org
#+INCLUDE: export-prologue.org
#+PROPERTY: header-args:latex :tangle yes :noweb yes :tangle-macros yes :tangle-prologue topic :tangle-epilogue endtopic :exports none

#+NAME: topic
#+BEGIN_SRC latex :tangle no
\psuSectionStart{{{{property(ITEM)}}}}{{{{n(block)}}}}
#+END_SRC

#+NAME: endtopic
#+BEGIN_SRC latex :tangle no
\psuSectionStop{{{{property(ITEM)}}}}{{{{n(block,-)}}}}
#+END_SRC

* Gedanken zu dieser Vorlesung                                     :noexport:
Was lernt man aus dieser Vorlesung für die Ziele effektiv und effizient?
 - Wie fließen Attribute  [effektiv]
   - Attribut Grammatike
 - Übersetzertechniken kennen lernen [effizient]
   - Visitor Pattern


* Ziele der semantischen Analyse
:PROPERTIES:
:CUSTOM_ID: 05-einleitung
:END:
#+begin_src latex
  \subtitle{{{{subtitle()}}}}
  \begin{frame}
    \maketitle
  \end{frame}

  \begin{frame}{Einordnung in die Vorlesung: Semantische Analyse}
    \begin{center}
      \includegraphics[page=5,width=0.8\linewidth]{fig/01-overview-small}
    \end{center}
    \bi
    \ii Übersetzer prüft bei der semantische Analyse die letzten Sprachregeln.\\
    \alert{$\Rightarrow$ In der semantischen Analyse werden die letzten Fehler entdeckt.} \medskip
    \ii Was sollte der \emph{effektive} und \emph{effiziente} Informatiker darüber Wissen? {
      \bi
      \ii Datenfluss auf einem Baum geschieht entlang und quer zu den Kanten.
      \ii Übersetzertechniken sind auch in anderen Bereichen einsetzbar.
      \ei
      }
      \ei

  \end{frame}

  \begin{frame}{Beispiel: Semantische Analyse eines Programms}
    \btAnimation[width=\textwidth]{center,range=1-5:<1->}{fig/05-example-ast}
  \end{frame}

  \begin{frame}[t]{Ziele der Semantischen Analyse}
    \begin{btBlock}{Syntaktische und Semantische Analyse prüfen alle Sprachregeln}\small
      Die syntaktische Analyse prüft die kontextfreien Regeln einer Sprache. Alles was nicht kontextfrei geprüft werden kann, überprüft die semantische Analyse.
    \end{btBlock}
    \bi
    \ii Abschließende Prüfung der Sprachregeln und Informationsgewinnung{
      \bi
      \ii Alle restlichen, nicht-syntaktischen, Sprachfehler werden hier aufgedeckt.
      \ii \enquote{Wo ist diese verwendete Variable deklariert und mit welchem Typ?}
      \ei
    }\medskip\pause
    \ii \tikzmark{A}\structure{Deklariertheit}: Kann jede (statische) Namensreferenz aufgelöst werden?{
      \bi
      \ii Zu jedem Namen(spfad) muss eine Deklaration gefunden werden.
      \ii Auffinden der passenden Überladung für eine Aufrufstelle.
      \ei
    }\medskip
    \ii \tikzmark{B}\structure{Typkonsistenz}: Werden die statischen Typen korrekt verwendet?{
      \bi
      \ii Die Typen der Argumente müssen zur Signatur einer Operation passen.
      \ii Nicht jede Inkonsistenz ist ein Fehler (Implizite Typumwandlung)
      \ei
    }
    \ei
    \begin{tikzpicture}[remember picture,overlay,visible on=<3->]
      \draw[<->,srared,thick] ($(pic cs:A)+(west:1.2em)$) coordinate(@) -- ($(pic cs:B)+(west:1.2em)+(up:1ex)$);
    \end{tikzpicture}
  \end{frame}
#+end_src

* AST Struktur und Attributierung
#+begin_src latex
  \begin{frame}[t,fragile]{AST: Baumstruktur im Übersetzer}
    \textbf{Theoretisch} ganz einfach. Ein AST ist eine Menge von Knoten....

    \tikzmark{X}\begin{columns}[b]
      \begin{column}{0.44\textwidth}
        \begin{code}[]
          \begin{CPP}[style=smaller]
            struct node_t {
              int    type;
              string token;
              vector<node_t> children;
            };
          \end{CPP}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.55\textwidth}
        \begin{code}[]
          \begin{CPP}[style=smaller]
            string getName(node_t *n) {
              if (n->type == VAR_DECL) {
                return n->children[1].token;
              } else if (n->type == VAR_REF) {
                return n->token;
              } ....
            }
          \end{CPP}
        \end{code}
      \end{column}
    \end{columns}

    \bi
    \ii<2-> \textbf{In Realität}: Code des Übersetzers muss auf dem dem AST operieren {
      \bi
      \ii Struktur der Grammatik sollte sich in den Datenstrukturen widerspiegeln
      \ii Übersetzer sind komplexe Programme, Bugs sind besonders schwerwiegend
      \ii Nutzung der verfügbaren Sprachfeatures um Übersetzer \structure{robust} zu machen
      \ei
    }
    \ei

    \begin{code}<2->[tag=Java]
      \tikzset{every node/.style={inner sep=0}}
      \begin{java}[style=smaller,escapechar=`]
        class `\tikznode[name=classdef]{ClassDef}` extends Definition {
          public Name               name;
          public ClassDef           extending;
          public `\tikznode[name=type]{List<InterfaceDef>}`    implementing;
          public List<Definition>   `\tikznode[name=member]{defs}`;
          ....
        }
      \end{java}
    \end{code}
    \begin{tikzpicture}[remember picture,overlay]
      \begin{visible}<2->
        \draw[ultra thick, srared](pic cs:X) -- node[sloped,fill=srared!2,draw]{\Huge NEIN}++(12cm,-2.2cm);
      \end{visible}
      \begin{visible}<3->
        \node[fit=(classdef),draw,pin={[draw,fill=badbee!20!white]60:Knotentypen als Klassen}] {};
        \node[fit=(type),draw,pin={[draw,fill=badbee!20!white]-90:Kinder haben Typen}] {};
        \node[fit=(member),draw,pin={[draw,fill=badbee!20!white]10:Kinder haben Namen}] {};
      \end{visible}
    \end{tikzpicture}
  \end{frame}

  \begin{frame}[fragile]{AST: Eine Hierarchie von Knotentypen}
    \bi
    \ii<+-> Die Grammatik legt bereits eine Hierarchie von Knotentypen nahe\\{
      \btSetNamedTab[1cm]{\first}%
      \first Grammatik:      \grammarrule{\NT{smt}}{assign\_stmt \OR while\_stmt \OR if\_stmt \OR \ldots}\\
      \first AST Definition: \codeinline[style=java]{class AssignStmt extends Stmt {...}}
    }
    \ii<+-> Zusammenfassung von Ähnlichkeiten verschiedener Knotentypen\\
        \textit{Beispiel}: Viele Deklarationen können einen Namen tragen. Lassen wir diese von \codebox{NamedDecl} erben, so können wir sie gleich behandeln.\medskip

    \ii<+-> Häufig verwendete Klassen von Knotentypen{
      \bi
      \ii \structure{Expression}: Ausdrücke die man auswerten kann und die ein Ergebnis liefern.\\
      \hspace{5mm}\textit{Beispiele:} Addition, Dereferenzierung, \codeinline{(<cond> ? <then> : <else>)}
      \ii \structure{Statement}: Anweisungen die sequentiell bearbeitet werden.\\
      \hspace{5mm}\textit{Beispiele:} if-else, Schleifen, Zuweisungen
      \ii \structure{Typen}: Literal notierte Typausdrücke.\\
      \hspace{5mm}\textit{Beispiele:} Typname, Typausdruck innerhalb eines Casts
      \ii \structure{Deklaration}: Jede statisch Bekanntmachung für den Compiler\\
      \hspace{5mm}\textit{Beispiele:} Variablendefinition, Klassendeklarationen, \codeinline[style=C]{typedef}
      \ei
    }
    \ei

  \end{frame}

  \begin{frame}[fragile]{AST: Zusätzliche Attribute}
    \vspace{-1ex}
    \bi
    \ii Der Parser erzeugt die Knoten und die Baumstruktur.{
      \bi
      \ii \structure{Parseraktionen} machen dies nebenher, wenn eine Regel angewendet wird:\\
         \codeinline!while_stmt -> WHILE ( expr ) body         { new WhileStmt(cond=T3, body=T5) }!
      \ii \codebox{expr} ist ein Expression Knoten und ist über T3 zugreifbar.
      \ei
    }
    \ii<2-> Semantische Analyse berechnet zusätzliche \structure{Attribute}{
      \bi
      \ii Datenhaltung während Analyse, Wissensbasis für den Rest des Übersetzers
      \ii \textit{Beispiel}: Berechneten Typ einer Expression, Zeiger auf die Deklaration.
      \ei
    }
    \ei

    \begin{columns}<3->[t]
      \begin{column}{0.49\textwidth}
        \begin{code}[tag=Python]
          \lstinputlisting[style=py,style=smaller,linerange={range0-range1}]{lst/05-DeclRefExpr.py}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \btAnimation[width=0.9\textwidth]{raisebox,center,1:<1->}{fig/05-member-expr.pdf}
      \end{column}
    \end{columns}
  \end{frame}


  \begin{frame}{Clang: AST Knoten und ihre Attribute}
    \begin{center}
      \btImage[text width=0.7\textwidth,draw,label=below:\scriptsize Ausschnitt aus der Klassenhierarchie]{fig/05-llvm-named-decl-tree}
      \medskip

      \btImage[text width=0.7\textwidth,draw,label=below:\scriptsize Öffentliches Interface von \texttt{clang::NamedDecl}]{fig/05-llvm-named-decl-member}
    \end{center}
  \end{frame}

  \begin{frame}[fragile]{Clang: AST für ein einfaches Programm}
    \begin{columns}
      \begin{column}{0.4\textwidth}
        \begin{code}[tag=C]
          \lstinputlisting[style=CPP,style=smaller,numbers=left,]{lst/05-example.cc}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.59\textwidth}
        \bii
        \ii CLang: C/C++ Frontend für LLVM
        \ii Source-to-Source Transformation
        \ii \texttt{clang::VarDecl} ist ein \texttt{clang::NamedDecl}
        \eii
      \end{column}
    \end{columns}

    \begin{btBlock}{\$ clang -Xclang -ast-dump -fsyntax-only /tmp/test.cc}
      \scriptsize
      \input{fig/05-clang-output}
    \end{btBlock}
  \end{frame}

#+end_src
- AST: Baumstruktur und Knoteninhalte
  - Vererbungshierarchie von Knoten
  - Angehängte Attribute an AST Knoten
  - Deklarationen, Statements, Expressions
* Informationsfluss auf Bäumen
** Attributierte Grammatiken
  - Synthethische Attribute (Von unten nach oben)
  - Geerbte Attribute ( Von links nach rechts)
** Traversierung von Bäumen
  - Synthetische Attribute
  - Visitor Pattern: Emulate Double Dispatch
  - type_equal, type_compatible
** Symboltabelle
  - Geerbte Attribute
  - find_decl, find_decl_fun
** Was tun bei Fehlern?
* Integration
  - Language: Coercion
    - Unifikation am Beispiel von Typen?
