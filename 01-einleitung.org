#+TITLE: Programmiersprachen und Übersetzer
#+SUBTITLE: 01 - Einleitung
#+INCLUDE: export-prologue.org
#+PROPERTY: header-args:latex :tangle yes :noweb yes :tangle-macros yes :tangle-prologue topic :tangle-epilogue endtopic :exports none

#+NAME: topic
#+BEGIN_SRC latex :tangle no
\psuSectionStart{{{{property(ITEM)}}}}
#+END_SRC

#+NAME: endtopic
#+BEGIN_SRC latex :tangle no
\psuSectionStop{{{{property(ITEM)}}}}{{{{range()}}}}
#+END_SRC

#+BEGIN_SRC latex :tangle-prologue nil :tangle-epilogue nil
\subtitle{{{{subtitle()}}}}
\begin{frame}
  \maketitle
\end{frame}
\psuSectionStop{Titlepage}{{{{range()}}}}
#+END_SRC

* Gedanken zu dieser Vorlesungseinheit                             :noexport:
Mit der ersten Vorlesung, soll der Studierene für die Vorlesung
motiviert werden. Es soll verstehen, welcher ganz konkreten
Erkenntnisgewinn daraus gezogen werden kann sich mit
Programmiersprachen und deren Implementierungen zu beschäftigen. Ihm
muss klar werden, dass er hier zukunftssicheres Wissen erlangt.

- Was muss der Studierende wissen um eine neue Programmiersprache
  effektiv und effizient ein zu setzen?

  - Welche Abstraktion bietet eine Programmiersprache an und was hat dies mit dem Ebenenmodell zu tun?

  - Was ist der Unterschied zwischen einem Interpreter und einem Übersetzer?

  - Was darf ein Übersetzer und was darf dieser nicht?


* Einleitung
:PROPERTIES:
:CUSTOM_ID: 01-einleitung
:END:

In diesem Skript[fn::Shift+Mouse Click für Rückwärts in den Folien]
sind die Themen der Vorlesung "Programmiersprachen und Übersetzer"
noch einmal schriftlich erörtert. Dabei erhebt das Skript **keinen**
Anspruch auf Vollständigkeit und es ersetzt auch nicht die Lektüre von
Lehr- und Fachbüchern. Im Verlaufe der Veranstaltung finden sie die
entsprechenden Literaturhinweise.

#+BEGIN_SRC latex
  \begin{frame}{Der Dozent}
    \PutAt{(10cm,1.6cm)}{
      \includegraphics[width=2cm]{fig/01-dietrich}
    }
    \bi
    \ii Wer ist der Dozent da? (22. Semester)\\{
      \bi
      \ii Informatikstudium in Erlangen (ab 2009)
      \ii System- und Rechnerarchitektur (ab 2017)
      \ii Promotion in Hannover (2019)
      \ii Betriebssysteme, Emacs User, Schwäche für Graphen
      \ei
    }\medskip
    \ii Ich mag Programmiersprachen! {
      \bi
      \ii Sie erleichtern mir Lösungen klar und deutlich aufzuschreiben.
      \ii Sowohl eleganter als auch zu komplexer Code ist Kunst.
      \ei
    }\qquad\qquad
    \ii<2-> Dies ist meine erste eigene Vorlesung. {
      \bi
      \ii Wir müssen das jetzt gemeinsam durchstehen.
      \ii Ich werde mein Bestes geben ihnen nur Sinnvolles zu vermitteln.
      \ii Melden sie sich mit Fehlern, Kritik und Anregungen.
      \ei
    }
    \ei
  \end{frame}
#+END_SRC


#+BEGIN_SRC latex
  \begin{frame}{Was soll diese Veranstaltung leisten?}
    \btUseExtraItemSep
  \bi
  \ii<+-> Informatiker werden fortwährend mit neuen Sprachen konfrontiert. {
    \bi
    \ii The next 700 programming languages, P. J. Landin\only<+->{, \citeyear{landin:66:cacm}\hfill\cite{landin:66:cacm}}
    \ii<+-> Hype Train (z.B. Rust), Evolution (C++20), Legacy (COBOL)
    \ii<.-> Sprachen Allerorten: HTML5, LaTex/TikZ, SQL, QT5/QML,
    \ei
  }
  \ii<+-> \Structure{Anforderung an Sie}: Schnell \alert{effektiv} und \alert{effizient} entwickeln können. {
    \bi
    \ii Effektiv:  In der Lage sein ein komplexes Program zu schreiben.
    \ii Effizient: Das Programm soll schnell und sparsam sein.
    \ii Häufig gibt es eine Abwägung zwischen beiden Zielen (siehe Skriptsprachen)
    \ei
  }
  \ii<.-> \Structure{Mein Ziel}: Vermittlung von Handwerkszeug und Denkweisen {
    \bi
    \ii Welche Fragen muss ich an eine neue Programmiersprache stellen?
    \ii Welche Konstrukte müssen prinzipbedingt teuer sein?
    \ii Demystifizierung der Compiler Black Box.
    \ei
  }
  \ei
  \end{frame}

  \begin{frame}[fragile,t]{Wieso ist das überhaupt möglich?}
    \btUseExtraItemSep
    \bi
    \ii Sprachen wurden von Ingenieuren erdacht. Man baut was man kennt.  {
      \bi
      \ii Jede neue Sprache bringt nur eine Hand voll neuer Konzepte
      \ii Der Rest ist eine Rekombination von bereits bekanntem
      \ei
    }
    \ii<+-> Beispiel: Über einen Zahlenvektor iterieren {

    \begin{code}<.>[tag=C]
      \begin{C}[]
        int sum = 0;
        int *it;
        for (it  = &vec[0];    // Initialisierung
             it != &vec[10];   // Abbruchbedingung
             ++it) {           // Nächstes Element
          sum += (*i);
        }
      \end{C}
    \end{code}%
    \begin{code}<+>[tag=C++03]
      \begin{CPP}[]
        int sum = 0;
        std::vector<int>::iterator it;
        for (it = vec.begin();  // Initialisierung
             it != vec.end();   // Abbruchbedingung
             ++it) {            // Nächstes Element
          sum += (*i);
        }
      \end{CPP}
    \end{code}%
    \begin{code}<+>[tag=C++11]
      \begin{CPP}[]
        int sum = 0;
        for (int x : vec) { // foreach Schleife
          sum += x
        }
      \end{CPP}
    \end{code}%
    \begin{code}<+->[tag=Python]
      \begin{py}[]
        sum = 0
        for x in vec:
            sum += x
      \end{py}
    \end{code}
  }
    \ii<+> Gemeinsame Konzepte von verschiedenen Programmiersprachen {
      \bi
      \ii Datentypen, Objekte, Benennung von Objekten, Operationen auf Objekten
      \ii Gemeinsamkeiten erleichtern erfahrenen Programmierern den Einstieg.
      \ii Unendliche Mannigfaltigkeit in unendlicher Kombination!
      \ei
    }
    \ei

  \end{frame}
#+END_SRC

* Inhalt der Veranstaltung
:PROPERTIES:
:CUSTOM_ID: 01-inhalt
:END:

#+BEGIN_SRC latex
  \begin{frame}{Welchen Inhalt hat diese Veranstaltung?}
    \bi
    \ii \STRUCTURE{Programmiersprachen}: Abstrahiert von der echten Maschine {
      \bi
      \ii Kernkonzepte die sich in vielen Sprachen wiederfinden
      \ii High-Level Paradigmen (funktional, OO), die sich daraus zusammensetzen
      \ii Wir werden uns verschiedenste Programmiersprachen anschauen
      \ei
      }
    \ei

    \begin{center}
      \Large {\Huge $\downarrow$} Programmiersprachen und Übersetzer {\Huge $\uparrow$}
    \end{center}

    \bi
    \ii \STRUCTURE{Übersetzer}: Bringt die Abstraktionen auf die Maschine {
      \bi
      \ii Zwischenschritte vom Zeichenstrom zum Assemblerprogram
      \ii Nötige Datenstrukturen und Algorithmen
      \ii Praktische Arbeit an einem einfachen Übersetzer
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{Literaturhinweise}\small
    \begin{columns}
      \begin{column}{2cm}
        \includegraphics[width=\linewidth]{fig/01-pragmatics}%
      \end{column}
      \begin{column}{9cm}
        \emph{Programming Language Pragmatics, Fourth Edition.\\Michael L. Scott, 2015.}\\[1ex]
        Folgt einer ähnlichen Herangehensweise wie die Vorlesung. Deckt sowohl den Sprach- als auch den Übersetzerteil ab.
      \end{column}
    \end{columns}
    \bigskip
    \begin{columns}
      \begin{column}{2cm}
        \includegraphics[width=\linewidth]{fig/01-aho}%
      \end{column}

      \begin{column}{8cm}
        \emph{Compiler: Prinzipien, Techniken und Werkzeuge.\\Ullmann, Lam, Sethi, Aho, 2008.}\\[1ex]
         \textbf{Das} klassische Buch zum Übersetzerbau (Drachenbuch). Auch bereits in der alten Auflage von unschätzbarem Wissen.
       \end{column}
       \begin{column}{2cm}
         \includegraphics[width=\linewidth]{fig/01-aho-old}%
       \end{column}
     \end{columns}
  \end{frame}
#+END_SRC

#+begin_src latex
  \begin{frame}{Programmiersprachen}
    \centering
    \includegraphics[height=\textheight-2cm,page=1]{fig/01-overview-small}
  \end{frame}

  \begin{frame}{Übersetzer}
    \includegraphics[width=\textwidth,page=2]{fig/01-overview-small}
  \end{frame}

  \begin{frame}{Übersicht}
    \includegraphics[width=\textwidth,page=3]{fig/01-overview-small}
  \end{frame}

  \begin{frame}[fragile]{Was passiert in den Übungen?}
    \Alert{Ziel:} Vertiefung von theoretischem Wissen und praktische Erfahrungen.
    \medskip
    \bi
    \ii Theorieaufgaben zur Durchdringung des Vorlesungsinhalts
    \ii Praktische Programmieraufgaben {
      \bi
      \ii Erweiterung eines kleinen Beispielübersetzers (in Python)
      \ii Arbeiten am Parser, der Typprüfung, Codeerzeugung, und am Optimierer
      \ii Übersetzer macht selbst rege gebrauch von Python Sprachfeaturen
      \ei
    }\medskip
    \ii Die Programmiersprache L0 - Basis unseres Übersetzers{
      \begin{columns}
        \begin{column}{0.49\textwidth}
          \begin{code}[tag=L0]
            \begin{lzero}[]
              var fib_calls : int;

              func fib(n : int) : int {
                fib_calls = fib_calls + 1;
                if (n <= 1) {
                  return n;
                }
                return fib(n-1) + fib(n-2);
              }

            \end{lzero}
          \end{code}
        \end{column}
        \hfill
        \begin{column}{0.49\textwidth}
          \btUseExtraItemSep[-\smallskipamount]
          \bi
          \ii Globale und lokale Variablen
          \ii Funktionen mit mehreren Argumenten
          \ii Nur Ganzahlen und Pointer
          \ii Keine Sicherheitsnetze
          \ei

        \end{column}
      \end{columns}
    }
    \ei
  \end{frame}
#+END_SRC

* Organisation der Veranstaltung
:PROPERTIES:
:CUSTOM_ID: 01-organisation
:END:

#+BEGIN_SRC latex
  \begin{frame}[t]{Organisatorische Hinweise}
  \PutAt{(10.5cm,1cm)}{
    \includegraphics[width=2cm]{fig/01-dietrich}\\[2ex]
    \includegraphics[width=2cm]{fig/01-landsberg}
  }
  \bi
  \ii Vorlesung: 13 Vorlesung, wöchentlich {
    \bi
    \ii Dienstag 9:00-11:00, 201, Conticampus
    \ii Semesterplan und Vorlesungskipt auf der SRA Webseite
    \ii \url{https://www.sra.uni-hannover.de/p/lehre-V\_PS\%C3\%9C}
    \ei
  }\medskip
  \ii Wie funktioniert der Übungsbetrieb? {
    \bi
    \ii 2 Übungstracks (A,B), mit einer Woche Versatz (wie GBS)
    \ii 6 Übungsaufgaben mit praktischem und theoretischem Inhalt\\[1ex]
    \ii Pro Track: 6 Tafel- und 6 Kleingruppenübungen, alternierend
    \ii Tafelübung: Dienstag 16:00-18:00,
    \ii Kleingruppenübung: Betreuung durch studentische Hilfskräfte
    \ei
  }\medskip
  \ii Bonuspunkte auf die Klausur {
    \bi
    \ii Abgabe der Übungsaufgaben
    \ii Testatklausur am \alert{23. Juni 2019}
    \ii Maximaler Bonus: 2 Notenstufen (-0.7); Übertragbar ins Folgesemester
    \ei
  }\bigskip
  \ii<2-> Was ist Klausurrelevant? \hfill\ALERT{\strut \only<3->{Vorlesung+Skript+Übung} }
  \ei
  \end{frame}
#+END_SRC


* Ebenenmodell und Virtuelle Maschinen
:PROPERTIES:
:CUSTOM_ID: 01-ebenenmodell
:END:

Das Ebenenmodell

#+BEGIN_SRC latex
  \begin{frame}
  \centering
  \Huge Ebenenmodell\\und\\ Virtuelle Maschinen
  \end{frame}

  \begin{frame}{Systemnahe Informatik}\framesubtitle{Der Blick aus 10000 Meilen}
      \begin{columns}
        \begin{column}{0.35\textwidth}
          \begin{center}\small
            \includegraphics[width=1.5cm]{fig/01-problem}\\\relax
            [Problem]\\[1ex]
            \fbox{\parbox{0.8\textwidth}{\centering
              Hochsprache\\
              $\Uparrow$\\
              \structure{Semantische Lücke}\\
              $\Downarrow$\\
              CPU-Steuersignale
            }}\\[1ex]\relax
          [Ausführung]\\\relax
          \includegraphics[width=1.5cm]{fig/01-cpu}
          \end{center}
        \end{column}\hfill
        \begin{column}{0.6\textwidth}
          \bi
          \ii {Informatisches Urproblem:\\ Schließen der Semantischen Lücke}\bigskip
          \ii Komplexitätsreduktion durch Abstraktion {
            \bi
            \ii Hierarchisch angeordnete \structure{virtuelle Maschinen}
            \ii Definierte Schnittstellen nach oben
            \ii Schrittweise Vereinfachungen nach unten
            \ei
          }\bigskip
          \ii PSÜ: Zwei Sichtweisen {
            \bi
            \ii Top-Down: Was bieten Sprachen an?
            \ii Bottom-Up: Wie bildet ein Compiler das ab?
            \ei
          }
          \ei
        \end{column}
      \end{columns}
    \end{frame}


    \newcommand{\down}[2][1em]{\tikzmark{#2}\tikz[remember picture,overlay]\draw[>=latex',->,thick,srared] (pic cs:#2)--++(down:#1);}
    \begin{frame}[label=vm-hierarchie]
      \frametitle{Hierarchie virtueller Maschinen\,\cite[S.\,3]{tanenbaum:06:sco}}

      \begin{columns}
        \begin{column}{0.7\textwidth}
          \bi
          \ii Schrittweises Schließen der semantischen Lücke\\[2ex]{
            \begin{tabular}{cllc}
              Ebene & Abstraktion & \\\hline
              $n$ & virtuelle Maschine $M_n$ & Sprache $L_n$ & \down{a} \\ \hline
              $\vdots$ & \multicolumn{1}{c}{$\vdots$}  & \multicolumn{1}{c}{$\vdots$}&\down{x}\\[0.5ex] \hline
              $2$ & virtuelle Maschine $M_2$ & Sprache $L_2$ &\down{b}\\ \hline
              $1$ & virtuelle Maschine $M_1$ & Sprache $L_1$ &\down{c}\\ \hline
              $0$ & reale Maschine $M_0$ & Sprache $L_0$\\\hline
            \end{tabular}
          }\bigskip
          \ii {$L_x$-Program wird auf Maschine $M_{x-1}$ abgebildet
            \bi
            \ii \STRUCTURE{Dynamisch}: Interpreter als $L_{x-1}$-Program
            \ii \STRUCTURE{Statisch}: Compiler erzeugt $L_{x-1}$ Program\\
                Spätere Abbildung von $L_{x-1}$ auf $M_{x-2}$.
            \ei
          }
          \ei
        \end{column}\hfill
        \begin{column}{0.2\textwidth}
          \begin{tikzpicture}
            \foreach \x/\s in {0/0.7,1/0.8,2/0.9,3/1} {
              \node at (\x*1mm,-\x * 8mm) {
                \includegraphics[width=\s\textwidth]{fig/01-matroschka}
              };
            }
          \end{tikzpicture}
          \legalcode[commons=Dedoushka-no_bg.jpg]{CC BY-SA 3.0}{Dedoushka}
        \end{column}
      \end{columns}
    \end{frame}

    \begin{frame}[t,label=vm-hierarchie-beispiel]{Beispiel: Arbeitsplatzrechner}
      \animation[trim={\btLeftMargin} 0pt 0pt 0pt, width=\textwidth]{1/1,2/2}{fig/01-layers}
    \end{frame}

#+END_SRC

Virtuelle Maschinen

#+begin_src latex
  \begin{frame}[t]{"Virtuelle Maschinen"}
    \alert{Wichtig:} Wir meinen nicht VMWare, Virtualbox oder KVM.\bigskip

    \bi
    \ii Maschienenmodell der virtuellen Maschine {
      \bi
      \ii \structure{Speicher/Objekte}: Wie kann man Daten ablegen und wieder abrufen?
      \ii \structure{Befehle/Operationen}: Wie kann man Daten miteinander kombinieren?
      \ii Ein "\structure{Prozessor}" kann dieses Modell implementieren.
      \ei
    }\medskip
    \ii Maschinenprogramme {
      \bi
      \ii Eine Menge Befehlen, die gegen das Maschinenmodell geschrieben wurden.
      \ii Wird von einem Prozessor verarbeitet um ein Ergebnis zu berechnen.
      \ei
    }\medskip
    \ii Sprache der virtuellen Maschiene {
      \bi
      \ii Nicht jede Zeichenkette ist ein für jedes Maschinenmodell ein valides Program.
      \ii Synaktische und Semantische Regeln um valide Programme zu schreiben.
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[fragile,t]{Beispiel: Die (virtuelle) RISC-V Maschine}
    RISC-V ist eine Rechnerarchitektur, die an industrieller Relevanz gewinnt.\bigskip

    \bi
    \ii Maschinenmodell (RV32I) {
      \bi
      \ii \structure{Speicher}: 32 CPU Register + frei addressierbarer Speicher.
      \ii \structure{Befehle}: 47 Instruktionen mit arithmetischen, binären und Sprungbefehlen.
      \ii Der SweRV von Western Digital is \alert{ein} Prozessor für dieses Modell.
      \ei
    }\medskip
    \ii Beispiel eines Maschinenprograms: 02 b5 05 3b 80 82 \pause{
      \\{\scriptsize (Wir tun mal so als wäre Assembler und Binärcode das gleiche)}\smallskip
      \begin{code}[tag=RV32I]
        \begin{asm}[]
          multiply: # int multiply(int a, int b) { return a*b; }
              mul a0, a0, a1
              ret
        \end{asm}
      \end{code}
    }\medskip
    \ii Die RV32I Assemblersprache {
      \bi
      \ii Welche Mnemonics gibt es? Anzahl und Art der Argumente.
      \ii \texttt{add}: 1 Ziel- und 2 Quellregister; \texttt{addi}: 1 Zielregister und 12-Bit Ganzzahl
      \ii \enquote{\texttt{addi a0, a2, $\gamma_i$}} -- wäre nicht valide in der RV32I Sprache.
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[fragile,t]{Beispiel: Die virtuelle C Maschine}
    \bi
    \ii Maschinenmodell {
      \bi
      \ii \structure{Speicher}: Definierten Variablen und über Pointer erreichbarer Speicher
      \ii \structure{Befehle}: z.B: \lstinline{if (a < 3) return b * (c + d);}
      \ii Sowohl GCC als auch Clang sind \enquote{Prozessoren} für dieses Modell.
      \ii Es gibt auch C Interpreter die als Prozessoren agieren.
      \ei
    }\medskip
    \ii Beispielprogramm : Der Obfuscated Tiny C Compiler (2048 Zeichen)\footnote{\url{https://bellard.org/otcc/}}{
      \begin{code}[tag=C90]
        \lstinputlisting[basicstyle=\ttfamily\tiny, breaklines=true, postbreak=\mbox{}]{lst/01-otcc.c}
      \end{code}
    }\medskip
    \ii Die C Sprache (eigentlich eine ganze Familie von Sprachen) {
      \bi
      \ii Variablen und Funktionen müssen deklariert sein, um sie zu nutzen.
      \ii Eine Ganzzahl is kein valider Funktionsname.
      \ii \enquote{\texttt{"12345(b, c)}} -- is kein valides C Programm.
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}<1-2>{Definitionen}
    \btUseExtraItemSep \setbeamercovered{transparent}
    \begin{description}
    \item[Programmiersprache] Regelwerk zur Erstellung von Zeichenketten, die valide Programme für ein bestimmtes
      Maschinenmodell sind. Verletzt eine Zeichenkette auch nur eine dieser Regeln ist es kein entsprechendes Programm.
    \item<1>[Interpreter] Ein Programm das  Sprachprozessor für bestimmten Maschinenmodell ist und andere Programme direkt ausführt.
    \item[Übersetzer] Ebenfalls ein Sprachprozessor, der das gegebene Programm allerdings nicht ausführt, sondern in eine valides
      Maschinenprogramm für eine andere Sprache übersetzt.
    \end{description}
  \end{frame}

#+end_src

Beobachtbare Zustände

#+begin_src latex
  \begin{frame}{Beobachtbare Zustände und Zustandsfolgen}
    \structure{Frage:} Wann ist eine Übersetzung eigentlich korrekt?\bigskip

    \bi
    \ii Das Maschinenmodell bestimmt den beobachtbaren Zustand ($q_n$) {
      \bi
      \ii Bei RISC-V: Zustand ist der Registersatz nach jeder Instruktionen.
      \ii Wir werden keine halb ausgeführten Instruktionen sehen.
      \ii Definition des beobachtbaren Zustands ist schwer bei komplexeren Sprachen.
      \ei
    }\medskip
    \ii Programmausführung durch einen Prozessor ergibt eine Zustandfolge: \\
    $q = (q_1, q_2, \ldots, q_n)$ {
      \bi
      \ii Die Zustände sind vom Speicher der Maschine abgeleitet
      \ii Die Übergänge sind Folge von ausgeführten Operationen: $q_t\rightarrow q_{t+1}$
      \ei
    }
    \ei
    \medskip
    \includegraphics[page=1]{fig/01-zustand}
  \end{frame}


  \begin{frame}[fragile]{Beispiel einer Zustandsfolge}
    \bi
    \ii Berechnung des größten gemeinsamen Teilers {
      \bi
      \ii Wiederholte Subtraktion {
      \begin{columns}
        \begin{column}{0.4\textwidth}
          \begin{code}[tag=Py]
            \lstinputlisting[style=py,linerange=sub0-sub1]{lst/ggt.py}
          \end{code}
        \end{column}
        \hfill
        \begin{column}{0.4\textwidth}\ttfamily
          \begin{stdout}
          (i,j) = (7, 35)
                  (7, 28)
                  (7, 21)
                  (7, 14)
                  (7, 7)
          \end{stdout}
        \end{column}
      \end{columns}
       }\pause
    \ii Wiederholtes Modulo {
      \begin{columns}
        \begin{column}{0.4\textwidth}
          \begin{code}[tag=Py]
            \lstinputlisting[style=py,linerange=mod0-mod1]{lst/ggt.py}
          \end{code}
        \end{column}
        \hfill
        \begin{column}{0.4\textwidth}
          \begin{stdout}
          (i,j) = (7, 35)
                  (0, 7)
          \end{stdout}
        \end{column}
      \end{columns}
    }
    \ei }\medskip
    \ii Beide Programme brechnen das gleiche Ergebnis: ggT=7\\
        Sie zeigen aber unterschiedliche Zustandsfolgen.
        \ei
    \medskip
    \pause
    \structure{Frage:} Darf ein Übersetzer einen Algorithmus tauschen?
  \end{frame}

  \begin{frame}{Korrektheit einer Übersetzung}
    \bi
    \ii Die Programmiersprache definiert die \alert{beobachtbaren} Zustände. {
      \bi
      \ii Ein- und Ausgabe ist immer beobachtbar, oft aber auch Teile des Speichers
      \ii Bei C: Nur das Schreiben von globalen Variablen, nicht aber von Lokalen.
      \ei
    }\bigskip
    \ii Ein \advantage{korrekter} Übersetzer erhält alle beobachtbaren Zustände.{
      \bi
      \ii Es kann eine allerdings Abbildungsfunktion geben:\\[2ex]{
        \includegraphics[page=2,width=0.9\textwidth]{fig/01-zustand}
      }
      \ii Eine sehr absurder Übersetzer könnte alle beobachtbaren Bits invertieren.
      \ei
    }\bigskip
    \ii Grundlage von optimierenden Übersetzer! {
      \bi
      \ii Ein optimierender Übersetzer erhält nur den beobachtbaren Zustand.
      \ii Der nicht-beobachtbare Zustand kann sich beliebig ändern.
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[fragile,t]{Beispiele korrekter Übersetzung von C nach \only<1>{C}\only<2>{RISC-V}\only<3>{Kobold}}
    \begin{code}[tag=C]
      \begin{C}[]
        void foo() {
          int x = 0;
          x += 1; x += 1; x += 1;
          return x;
        }
      \end{C}
    \end{code}
    \begin{center}
      \Huge$\Downarrow$
    \end{center}
    \begin{code}<1>[tag=C]
      \begin{C}[]
        void foo() {
          return 3;
        }
      \end{C}
    \end{code}%
    \begin{code}<2>[tag={RV32I}]
      \begin{asm}[]
        foo:
          lui a0, 3
          ret
      \end{asm}
    \end{code}%
    \begin{code}<3>[tag={Kobold}]
      \begin{columns}
        \begin{column}{0.25\textwidth}
          \centering
          \includegraphics[height=3cm]{fig/01-cobold}
          \legalcode[commons=Kobold_artlibre_jnl.jpg]{Free Art License}{Jean-no}
        \end{column}\hfill
        \begin{column}{0.6\textwidth}
          \centering
          Dies ist ein besonders gut geschulter Kobold. Immer wenn man ihn irgendetwas fragt, wird er mit \ALERT{3} antworten.
        \end{column}
      \end{columns}
    \end{code}
  \end{frame}
#+end_src

* Bootstrapping und Portierung

#+begin_src latex
  \begin{frame}
    \Huge\centering
    Bootstrapping\\
    und\\
    Portierung
  \end{frame}

  \begin{frame}{Wer übersetzt den Übersetzer?}
    \bi
    \ii Wo läuft eigentlich der Übersetzer und wie kommen wir zu ihm? {
      \bi
      \ii Die allerersten Übersetzer von Programmen waren Menschen.
      \ii Wo sie herkommen: Evolution. Worauf sie laufen: Physik (wie der Kobold).
      \ei
    }\pause
    \ii Wir brauchen eine Übersetzer von L nach M der auf M läuft.\\[2ex] {
      \begin{center}
        \includegraphics[page=1,width=0.7\textwidth]{fig/01-t-diagram}
      \end{center}
    }
    \ei
    \bii
    \ii \Alert{Aber:} Es is zu aufwendig einen Übersetzer in M (z.B. Assembler) zu schreiben.
    \ii Wir wollen den Übersetzer lieber in L schreiben und irgendwie nach M bringen.
    \ii Dieser Prozess heißt Bootstrapping ($=$ sich selbst aus dem Sumpf ziehen).
    \eii
  \end{frame}

  \begin{frame}[t]{T-Diagramme (oder Tombstone Diagramme)}
    \bi
    \ii T-Diagramme dienen zur Visualisierung des Bootstrapping Problems \\[2ex] {
      \begin{center}
        \includegraphics[page=1,width=0.7\textwidth]{fig/01-t-diagram}
      \end{center}
    }
    \ei
    \begin{columns}
      \begin{column}{0.49\textwidth}
        \bi
        \ii Interpreter (für M auf m)\\[2ex]{
          \begin{center}
            \includegraphics[page=2,height=3cm]{fig/01-t-diagram}
          \end{center}
        }
        \ei
      \end{column}
      \begin{column}{0.49\textwidth}
        \bi
        \ii Echte Maschinen (führen m aus)\\[2ex]{
          \begin{center}
            \includegraphics[page=3,height=2cm]{fig/01-t-diagram}
            \vspace{1cm}
          \end{center}
        }
        \ei
      \end{column}
    \end{columns}

  \end{frame}

  \begin{frame}{1. Möglichkeit: Selbstübersetzung mittels Interpreter}
    \bi
    \ii Schreibe einen Interpreter \dn2 für L. Führe \dn1 auf \dn2 aus, um \dn[fill=badbee!40]{1} in \dn[fill=badbee!40]{1'} zu übersetzen.\\[2ex] {
      \begin{center}
        \only<1>{\includegraphics[height=4cm, page=4]{fig/01-t-diagram}}%
        \only<2>{\includegraphics[height=4cm, page=5]{fig/01-t-diagram}}
      \end{center}
    }
    \iiad (Langsame) Interpreter schreiben ist meist einfacher als Übersetzer.
    \iida Doppelter Aufwand und der Interpreter ist Wegwerfware
    \iida Verhält sich \dn1 auf echter Hardware und im Interpreter gleich?
    \ei
  \end{frame}

  \begin{frame}{2. Möglichkeit: Vereinfachter Übersetzer}
    \bi
    \ii Ableitung eines einfacheren Übersetzers \dn2 aus dem Vollausgestatten \dn1.\\[2ex] {
      \begin{center}
        \includegraphics[height=2cm, page=6]{fig/01-t-diagram}
      \end{center}
      \bi
      \ii Das Subset L' (von L) enthält nur die unbedingt notwendigen Sprachelemente.
      \ii Das Subset M' (von M) enthält nur einfache Maschinenbefehle.
      \ii \dn{2} darf langsam sein und langsamen Code erzeugen.
      \ei
    }
    \ii<2-> Manuelle oder semiautomatische Übersetzung von \dn{2} in \dn{3}.\\[2ex] {
      \begin{center}
        \includegraphics[height=2cm, page=7]{fig/01-t-diagram}
      \end{center}
      \bi
      \ii Teilweise mit einem existierenden Übersetzers einer anderen Sprache möglich.
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{2. Möglichkeit: Vereinfachter Übersetzer}
    \begin{center}
      \animation[width=0.8\textwidth]{8/1,9/2,10/3,11/4}{fig/01-t-diagram}
    \end{center}
    \begin{enumerate}
    \item Übersetze \dn{2} mit \dn{3}: \dn{2a} ist langsam und erzeugt langsamen Code.
    \item<3-> Übersetze \dn{1} zu einem langsamen, aber optimierenden, Übersetzer (1a).
    \item<4-> Übersetze \dn{1} erneut mit sich selbst (1b).
    \end{enumerate}
  \end{frame}
#+end_src


Portierung
#+begin_src latex
  \begin{frame}{Portierung auf neue Plattform und Cross-Compiler}
    \begin{center}
      \animation[width=0.7\textwidth]{12/1,13/2,14/3-}{fig/01-t-diagram}
    \end{center}
    \bi
    \ii Ähnliches Probleme wenn man auf eine neue Plattform N wechselt. {
      \bi
      \ii<2-> Mit der vorhandenen Werkzeugkette: Erzeuge den \alert{Cross-Compiler} \dn{Z'}.
      \ii<3-> Übersetze \dn{Z} mit seinem Cross-Compiler zu \dn{Z''}.
      \ei
    }
    \ii<4> Zunehmend kein Problem mehr, da viele Übersetzer Multitarget bieten. {
      \bi
      \ii Das Übersetzerbackend  bietet, über Optionen, sowohl M als auch N an.
      \ii LLVM: \texttt{llc -version} \hfill(\texttt{llc} ist das Backend von LLVM)
      \ei
    }
    \ei
  \end{frame}
#+end_src


* Zusammenfassung
#+begin_src latex
  \begin{frame}{Zusammenfassung}
    \bi
    \ii Virtuelle Maschinen führen Programme aus, haben Speicher und Befehle{%
      \bi
      \ii Ihre Maschinensprache umfasst alle valide Programme.
      \ii Korrekter Übersetzer erhält die Sprachsemantik und beobachtbare Zustände.
      \ei
    }\bigskip
    \ii Ebenenmodell: Schrittweise Abstraktion von der echten Hardware {
      \bi
      \ii Obere Schichten bieten ausdrucksstärkere Sprachen.
      \ii Untere Schichten sind direkt implementierbar.
      \ii Übergang zu den unteren Schichten durch Übersetzung (oder Interpretation)
      \ei
    }\bigskip
    \ii Bootstrapping: Der erste Übersetzer übersetzt sich selbst. {
      \bi
      \ii Reduktion auf manuelle Übersetzung eines abgespeckten Übersetzers
      \ii Bei der Portierung auf neue Plattform braucht es einn Cross-Compiler
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{Quellenverzeichnis}
    \printbibliography
  \end{frame}
#+end_src
