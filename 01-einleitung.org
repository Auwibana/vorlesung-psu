#+TITLE: Programmiersprachen und Übersetzer
#+SUBTITLE: 01 - Einleitung
#+INCLUDE: export-prologue.org
#+PROPERTY: header-args:latex :tangle yes :noweb yes :tangle-macros yes :tangle-prologue topic :tangle-epilogue endtopic :exports none

#+NAME: topic
#+BEGIN_SRC latex :tangle no
\psuSectionStart{{{{property(ITEM)}}}}
#+END_SRC

#+NAME: endtopic
#+BEGIN_SRC latex :tangle no
\psuSectionStop{{{{property(ITEM)}}}}{{{{range()}}}}
#+END_SRC

#+BEGIN_SRC latex :tangle-prologue nil :tangle-epilogue nil
\subtitle{{{{subtitle()}}}}
\begin{frame}
  \maketitle
\end{frame}
\psuSectionStop{Titlepage}{{{{range()}}}}
#+END_SRC

* Gedanken zu dieser Vorlesungseinheit                             :noexport:
Mit der ersten Vorlesung, soll der Studierene für die Vorlesung
motiviert werden. Es soll verstehen, welcher ganz konkreten
Erkenntnisgewinn daraus gezogen werden kann sich mit
Programmiersprachen und deren Implementierungen zu beschäftigen. Ihm
muss klar werden, dass er hier zukunftssicheres Wissen erlangt.

- Was muss der Studierende wissen um eine neue Programmiersprache
  effektiv und effizient ein zu setzen?

  - Welche Abstraktion bietet eine Programmiersprache an und was hat dies mit dem Ebenenmodell zu tun?

  - Was ist der Unterschied zwischen einem Interpreter und einem Übersetzer?

  - Was darf ein Übersetzer und was darf dieser nicht?


* Einleitung

#+BEGIN_SRC latex
  \begin{frame}{Der Dozent}
    \bi
    \ii Wer ist der Dozent da?\\{
      Informatikstudium in Erlangen (ab 2009), Promotion in Hannover (2019)\\
      Betriebssysteme, Emacs User, Schwäche für Graphdatenstrukturen
    }\qquad
    \ii Ich mag Programmiersprachen! {
      \bi
      \ii Sie erleichtern mir Lösungen klar und deutlich aufzuschreiben.
      \ii Sowohl eleganter als auch zu komplexer Code ist Kunst.
      \ei
    }\qquad\qquad
    \ii<2-> Dies ist meine erste eigene Vorlesung. {
      \bi
      \ii Wir müssen das jetzt gemeinsam durchstehen.
      \ii Ich werde mein Bestes geben ihnen nur Sinnvolles zu vermitteln.
      \ii Melden sie sich mit Fehlern, Kritik und Anregungen.
      \ei
    }
    \ei
  \end{frame}
#+END_SRC

#+BEGIN_SRC latex
  \begin{frame}{Was soll diese Veranstaltung leisten?}
    \btUseExtraItemSep
  \bi
  \ii<+-> Informatiker werden fortwährend mit neuen Sprachen konfrontiert. {
    \bi
    \ii The next 700 programming languages, P. J. Landin\only<+->{, \citeyear{landin:66:cacm}\hfill\cite{landin:66:cacm}}
    \ii<+-> Hype Train (z.B. Rust), Evolution (C++20), Legacy (COBOL)
    \ii<.-> Sprachen Allerorten: HTML5, LaTex/TikZ, SQL, QT5/QML,
    \ei
  }
  \ii<+-> \Structure{Anforderung an Sie}: Schnell \alert{effektiv} und \alert{effizient} entwickeln können. {
    \bi
    \ii Effektiv:  In der Lage sein ein komplexes Program zu schreiben.
    \ii Effizient: Das Programm soll schnell und sparsam sein.
    \ii Häufig gibt es eine Abwägung zwischen beiden Zielen (siehe Skriptsprachen)
    \ei
  }
  \ii<.-> \Structure{Mein Ziel}: Vermittlung von Handwerkszeug und Denkweisen {
    \bi
    \ii Welche Fragen muss ich an eine neue Programmiersprache stellen?
    \ii Welche Konstrukte müssen prinzipbedingt teuer sein?
    \ii Demystifizierung der Compiler Black Box.
    \ei
  }
  \ei
  \end{frame}

  \begin{frame}[fragile,t]{Wieso ist das überhaupt möglich?}
    \btUseExtraItemSep
    \bi
    \ii Sprachen wurden von Ingenieuren erdacht. Man baut was man kennt.  {
      \bi
      \ii Jede neue Sprache bringt nur eine Hand voll neuer Konzepte
      \ii Der Rest ist eine Rekombination von bereits bekanntem
      \ei
    }
    \ii<+-> Beispiel: Über einen Zahlenvektor iterieren {

    \begin{code}<.>[tag=C]
      \begin{C}[]
        int sum = 0;
        int *it;
        for (it  = &vec[0];    // Initialisierung
             it != &vec[10];   // Abbruchbedingung
             ++it) {           // Nächstes Element
          sum += (*i);
        }
      \end{C}
    \end{code}%
    \begin{code}<+>[tag=C++03]
      \begin{CPP}[]
        int sum = 0;
        std::vector<int>::iterator it;
        for (it = vec.begin();  // Initialisierung
             it != vec.end();   // Abbruchbedingung
             ++it) {            // Nächstes Element
          sum += (*i);
        }
      \end{CPP}
    \end{code}%
    \begin{code}<+>[tag=C++11]
      \begin{CPP}[]
        int sum = 0;
        for (int x : vec) { // foreach Schleife
          sum += x
        }
      \end{CPP}
    \end{code}%
    \begin{code}<+->[tag=Python]
      \begin{py}[]
        sum = 0
        for x in vec:
            sum += x
      \end{py}
    \end{code}
  }
    \ii<+> Gemeinsame Konzepte von verschiedenen Programmiersprachen {
      \bi
      \ii Datentypen, Objekte, Benennung von Objekten, Operationen auf Objekten
      \ii Gemeinsamkeiten erleichtern erfahrenen Programmierern den Einstieg.
      \ii Unendliche Mannigfaltigkeit in unendlicher Kombination!
      \ei
    }
    \ei

  \end{frame}
#+END_SRC

* Struktur der Veranstaltung

#+BEGIN_SRC latex
  \begin{frame}{Welchen Inhalt hat diese Veranstaltung?}
    \bi
    \ii \STRUCTURE{Programmiersprachen}: Abstrahiert von der echten Maschiene {
      \bi
      \ii Kernkonzepte die sich in vielen Sprachen wiederfinden
      \ii High-Level Paradigmen (funktional, OO), die sich daraus zusammensetzen
      \ii Wir werden uns verschiedenste Programmiersprachen anschauen
      \ei
      }
    \ei

    \begin{center}
      \Large {\Huge $\downarrow$} Programmiersprachen und Übersetzer {\Huge $\uparrow$}
    \end{center}

    \bi
    \ii \STRUCTURE{Übersetzer}: Bringt die Abstraktionen auf die Maschiene {
      \bi
      \ii Zwischenschritte vom Zeichenstrom zum Assemblerprogram
      \ii Nötige Datenstrukturen und Algorithmen
      \ii Praktische Arbeit an einem einfachen Übersetzer
      \ei
    }
    \ei

  \end{frame}

  \begin{frame}{Programmiersprachen}
    \centering
    \includegraphics[height=\textheight-2cm,page=1]{fig/01-overview-small}
  \end{frame}

  \begin{frame}{Übersetzer}
    \includegraphics[width=\textwidth,page=2]{fig/01-overview-small}
  \end{frame}

  \begin{frame}{Übersicht}
    \includegraphics[width=\textwidth,page=3]{fig/01-overview-small}
  \end{frame}
#+END_SRC

* Ebenenmodell und Virtuelle Maschienen
:PROPERTIES:
:CUSTOM_ID: 01-ebenenmodell
:END:

#+BEGIN_SRC latex
  \begin{frame}{Systemnahe Informatik}\framesubtitle{Der Blick aus 10000 Meilen}
    \begin{columns}
      \begin{column}{0.35\textwidth}
        \begin{center}\small
          \includegraphics[width=1.5cm]{fig/01-problem}\\\relax
          [Problem]\\[1ex]
          \fbox{\parbox{0.8\textwidth}{\centering
            Hochsprache\\
            $\Uparrow$\\
            \structure{Semantische Lücke}\\
            $\Downarrow$\\
            CPU-Steuersignale
          }}\\[1ex]\relax
        [Ausführung]\\\relax
        \includegraphics[width=1.5cm]{fig/01-cpu}
        \end{center}
      \end{column}\hfill
      \begin{column}{0.6\textwidth}
        \bi
        \ii {Informatisches Urproblem:\\ Schließen der Semantischen Lücke}\bigskip
        \ii Komplexitätsreduktion durch Abstraktion {
          \bi
          \ii Hierarchisch angeordnete \structure{virtuelle Maschienen}
          \ii Definierte Schnittstellen nach oben
          \ii Schrittweise Vereinfachungen nach unten
          \ei
        }\bigskip
        \ii PSÜ: Zwei Sichtweisen {
          \bi
          \ii Top-Down: Was bieten Sprachen an?
          \ii Bottom-Up: Wie bildet ein Compiler das ab?
          \ei
        }
        \ei
      \end{column}
    \end{columns}
  \end{frame}


  \newcommand{\down}[2][1em]{\tikzmark{#2}\tikz[remember picture,overlay]\draw[>=latex',->,thick,srared] (pic cs:#2)--++(down:#1);}
  \begin{frame}[label=vm-hierarchie]
    \frametitle{Hierarchie virtueller Maschinen\,\cite[S.\,3]{tanenbaum:06:sco}}

    \begin{columns}
      \begin{column}{0.7\textwidth}
        \bi
        \ii Schrittweises Schließen der semantischen Lücke\\[2ex]{
          \begin{tabular}{cllc}
            Ebene & Abstraktion & \\\hline
            $n$ & virtuelle Maschine $M_n$ & Sprache $L_n$ & \down{a} \\ \hline
            $\vdots$ & \multicolumn{1}{c}{$\vdots$}  & \multicolumn{1}{c}{$\vdots$}&\down{x}\\[0.5ex] \hline
            $2$ & virtuelle Maschine $M_2$ & Sprache $L_2$ &\down{b}\\ \hline
            $1$ & virtuelle Maschine $M_1$ & Sprache $L_1$ &\down{c}\\ \hline
            $0$ & reale Maschine $M_0$ & Sprache $L_0$\\\hline
          \end{tabular}
        }\bigskip
        \ii {$L_x$-Program wird auf Maschiene $M_{x-1}$ abgebildet
          \bi
          \ii \STRUCTURE{Dynamisch}: Interpreter als $L_{x-1}$-Program
          \ii \STRUCTURE{Statisch}: Compiler erzeugt $L_{x-1}$ Program\\
              Spätere Abbildung von $L_{x-1}$ auf $M_{x-2}$.
          \ei
        }
        \ei
      \end{column}\hfill
      \begin{column}{0.2\textwidth}
        \begin{tikzpicture}
          \foreach \x/\s in {0/0.7,1/0.8,2/0.9,3/1} {
            \node at (\x*1mm,-\x * 8mm) {
              \includegraphics[width=\s\textwidth]{fig/01-matroschka}
            };
          }
        \end{tikzpicture}
        \legalcode[commons=Dedoushka-no_bg.jpg]{CC BY-SA 3.0}{Dedoushka}
      \end{column}
    \end{columns}
  \end{frame}

  \begin{frame}[t,label=vm-hierarchie-beispiel]{Beispiel: Arbeitsplatzrechner}
    \animation[trim={\btLeftMargin} 0pt 0pt 0pt, width=\textwidth]{1/1,2/2}{fig/01-layers}
  \end{frame}

#+END_SRC

* Organisatorisches
