#+TITLE: Programmiersprachen und Übersetzer
#+SUBTITLE: 01 - Einleitung
#+INCLUDE: export-prologue.org
#+PROPERTY: header-args:latex :tangle yes :noweb yes :tangle-macros yes :tangle-prologue topic :tangle-epilogue endtopic :exports none

#+NAME: topic
#+BEGIN_SRC latex :tangle no
\psuSectionStart{{{{property(ITEM)}}}}{{{{n(block)}}}}
#+END_SRC

#+NAME: endtopic
#+BEGIN_SRC latex :tangle no
\psuSectionStop{{{{property(ITEM)}}}}{{{{n(block,-)}}}}
#+END_SRC

#+BEGIN_SRC latex :tangle-prologue nil
\subtitle{{{{subtitle()}}}}
\begin{frame}
  \maketitle
\end{frame}

\begin{frame}{Der Dozent}
    \PutAt{(10cm,1.6cm)}{
      \includegraphics[width=2cm]{fig/01-dietrich}
    }
    \bi
    \ii Wer ist der Dozent da? (22. Semester)\\{
      \bi
      \ii Informatikstudium in Erlangen (ab 2009)
      \ii System- und Rechnerarchitektur (ab 2017)
      \ii Promotion in Hannover (2019)
      \ii Betriebssysteme, Emacs User, Schwäche für Graphen
      \ei
    }\medskip
    \ii Ich mag Programmiersprachen! {
      \bi
      \ii Sie erleichtern mir Lösungen klar und deutlich aufzuschreiben.
      \ii Sowohl eleganter als auch zu komplexer Code ist Kunst.
      \ei
    }\qquad\qquad
    \ii<2-> Dies ist meine erste eigene Vorlesung. {
      \bi
      \ii Wir müssen das jetzt gemeinsam durchstehen.
      \ii Ich werde mein Bestes geben ihnen nur Sinnvolles zu vermitteln.
      \ii Melden sie sich mit Fehlern, Kritik und Anregungen.
      \ei
    }
    \ei
\end{frame}
#+END_SRC

* Gedanken zu dieser Vorlesung                                     :noexport:
Mit der ersten Vorlesung, soll der Studierene für die Vorlesung
motiviert werden. Es soll verstehen, welcher ganz konkreten
Erkenntnisgewinn aus der Veranstaltung gezogen werden kann sich mit
Programmiersprachen und deren Implementierungen zu beschäftigen. Ihm
muss klar werden, dass er hier zukunftssicheres Wissen erlangt.

- Was muss der Studierende wissen um eine neue Programmiersprache
  effektiv und effizient ein zu setzen?

  - Welche Abstraktion bietet eine Programmiersprache an und was hat
    dies mit dem Ebenenmodell zu tun?

  - Was ist der Unterschied zwischen einem Interpreter und einem
    Übersetzer?

  - Was darf ein Übersetzer und was darf dieser nicht?


* Einleitung
:PROPERTIES:
:CUSTOM_ID: 01-einleitung
:END:

In diesem Skript sind die Themen der Vorlesung "Programmiersprachen
und Übersetzer" noch einmal schriftlich erörtert. Dabei erhebt das
Skript **keinen** Anspruch auf Vollständigkeit und es ersetzt auch
nicht die Lektüre von Lehr- und Fachbüchern. Im Verlaufe der
Veranstaltung werden sie entsprechenden Literaturhinweise, sowohl
Bücher als auch Links zu entsprechenden Fachartikeln und
Blogeinträgen, finden. Sollten sie weitere Interessante Artikel zur
Veranstaltung finden, scheuen sie sich mir nicht diese zuzusenden.

Um unnötige Dopplungen mit den Folien zu vermeiden, haben wir die
einzelnen Vorlesungsfolien in dieses Dokument mit eingebunden. Zu den
jeweiligen Abschnitten finden sie die Erläuterungen, Ergänzungen und
Informationen, die während der Vorlesung auf der "Tonspur" erzählt
werden. In den jeweiligen Folienblöcken können sie mittels Mausklick
vorwärts, und bei gedrückter Shifttaste rückwärts, navigieren.

#+BEGIN_SRC latex
  \begin{frame}{Was soll diese Veranstaltung leisten?}
    \btUseExtraItemSep
  \bi
  \ii<+-> Informatiker werden fortwährend mit neuen Sprachen konfrontiert. {
    \bi
    \ii The next 700 programming languages, P. J. Landin\only<+->{, \citeyear{landin:66:cacm}\hfill\cite{landin:66:cacm}}
    \ii<+-> Hype Train (z.B. Rust), Evolution (C++20), Legacy (COBOL)
    \ii<.-> Sprachen Allerorten: HTML5, LaTex/TikZ, SQL, QT5/QML,
    \ei
  }
  \ii<+-> \Structure{Anforderung an Sie}: Schnell \alert{effektiv} und \alert{effizient} entwickeln können. {
    \bi
    \ii Effektiv:  In der Lage sein ein komplexes Program zu schreiben.
    \ii Effizient: Das Programm soll schnell und sparsam sein.
    \ii Häufig gibt es eine Abwägung zwischen beiden Zielen (siehe Skriptsprachen)
    \ei
  }
  \ii<.-> \Structure{Mein Ziel}: Vermittlung von Handwerkszeug und Denkweisen {
    \bi
    \ii Welche Fragen muss ich an eine neue Programmiersprache stellen?
    \ii Welche Konstrukte müssen prinzipbedingt teuer sein?
    \ii Demystifizierung der Compiler Black Box.
    \ei
  }
  \ei
  \end{frame}

  \begin{frame}[fragile,t]{Wieso ist das überhaupt möglich?}
    \btUseExtraItemSep
    \bi
    \ii Sprachen wurden von Ingenieuren erdacht. Man baut was man kennt.  {
      \bi
      \ii Jede neue Sprache bringt nur eine Hand voll neuer Konzepte
      \ii Der Rest ist eine Rekombination von bereits bekanntem
      \ei
    }
    \ii<+-> Beispiel: Über einen Zahlenvektor iterieren {

    \begin{code}<.>[tag=C]
      \begin{C}[]
        int sum = 0;
        int *it;
        for (it  = &vec[0];    // Initialisierung
             it != &vec[10];   // Abbruchbedingung
             ++it) {           // Nächstes Element
          sum += (*i);
        }
      \end{C}
    \end{code}%
    \begin{code}<+>[tag=C++03]
      \begin{CPP}[]
        int sum = 0;
        std::vector<int>::iterator it;
        for (it = vec.begin();  // Initialisierung
             it != vec.end();   // Abbruchbedingung
             ++it) {            // Nächstes Element
          sum += (*i);
        }
      \end{CPP}
    \end{code}%
    \begin{code}<+->[tag=Python]
      \begin{py}[]
        sum = 0
        for x in vec:
            sum += x
      \end{py}
    \end{code}%
    \begin{code}<+>[tag=C++11]
      \begin{CPP}[]
        int sum = 0;
        for (int x : vec) { // foreach Schleife
          sum += x
        }
      \end{CPP}
    \end{code}
  }
    \ii<+> Gemeinsame Konzepte von verschiedenen Programmiersprachen {
      \bi
      \ii Datentypen, Objekte, Benennung von Objekten, Operationen auf Objekten
      \ii Gemeinsamkeiten erleichtern erfahrenen Programmierern den Einstieg.
      \ii Unendliche Mannigfaltigkeit in unendlicher Kombination!
      \ei
    }
    \ei

  \end{frame}
#+END_SRC

Zunächst stellt sich die Frage, wieso es für einen Informatiker sinnvoll ist sich im Detail mit Programmiersprachen, ihren Konzepten und ihrer Übersetzung in Maschinencode zu beschäftigen.
Schließlich gibt es all diese Werkzeuge bereits und wir können sie einfach verwenden.
Außerdem haben sie vielleicht das Gefühl, dass Übersetzer und deren Konstruktion ein schwer zu durchdringendes Thema sind und eher an schwarze Magie denn an normale Programmierung erinnern.
Aus eigener Erfahrung kann ich ihnen sagen:
dem ist nicht so und sowohl Programmiersprachen, als auch Übersetzer, sind ein spannendes Feld der Informatik in dem eine beständige Entwicklung stattfindet.

Diese beständige Entwicklung stellt allerdings auch eine Herausforderung für sie, als Informatiker oder Informatik-geneigter Ingenieur, da.
Mit den Programmiersprachen, die sie im Laufe ihres Studiums konfrontiert sind, werden sie nicht über die nächsten 40 Jahre kommen.
Um zukunftssicher zu werden, brauchen sie nicht nur rein technisches Wissen um eine oder zwei Sprachen, sondern systematisches und konzeptionelles Wissen das nicht so schnell altert, wie der Hype-Train vom Java Bahnhof, über die C# Hochebene, zur **Rust**-Mine braucht.

Aber nicht nur die fortschreitende Entwicklung einzelner Programmiersprachen oder das aufkommen von ganz neuen Sprachen bringt dauerhafte Relevanz für das Thema, sondern auch die schiere Prevalenz und die Vielfalt an Sprachen, die von Computern mechanisch verarbeitet werden.
Sprachen werden nicht nur für das Kodifikation von ausführbaren Programmen verwendet, sondern, unter anderem, auch zur Aufbereitung von Informationen (z.B., [[https://www.w3.org/standards/webdesign/htmlcss][HTML5]] oder [[http://www.texample.net/tikz/][TiKZ]]) oder zur Beschreibung von Datenabfragen (z.B., SQL oder [[http://overpass-turbo.eu/s/M4M][Overpass]]).

Im Verlaufe ihres Lebens wird an sie, nachdem entschieden wurde Programmiersprache R++ in Version 2034 zu verwenden, die Anforderung gestellt werden möglichst schnell **effektiv** darin zu werden ein möglichst **effizientes** Programm zu schreiben.
Die von ihnen erwartete Effektivität besteht darin, dass sie überhaupt in die Lage kommen ein Programm zu schreiben.
Die erwartete Effizienz besteht darin, dass das erstellte Programm nicht unrealistisch lange für eine einfache Aufgabe braucht.
Aber auch wenn sie selbst in die Lage kommen die Wahl der Programmiersprache für ein neues Projekt zu treffen, brauchen sie das nötige Wissen um eine informierte Entscheidung treffen zu können.
Beispielsweise muss die Abwägung zwischen der performanten Ausführung einer übersetzten Sprache und der schnellen Entwicklung in einer Skriptsprache, je nach Anwendungsfall,Unternehmenstruktur und Verfügbarkeit von Entwicklern, anders getroffen werden.
Ein Startup, welches seine Webanwendung in [[https://github.com/azac/cobol-on-wheelchair][COBOL]] entwickelt, wird es schwer haben die nötige Entwicklungsgeschwindigkeit zu erreichen.

Da sie das Erlernen neuer Sprachen also nicht vermeiden können, können sie es sich auch gleich möglichst *einfach* machen und wiederverwendbare Konzepte lernen anstatt 20 Ausprägungen von selbem Konzept.
Dies ist auch das angepeilte Vorgehen dieser Veranstaltung:
Wir werden uns Sprachkonzepte anschauen, die immer wieder auftauchen, und wir werden versuchen ihre *Essenz* heraus zu destillieren.
Dabei werden wir uns Beispiele aus verschiedensten Sprachen anschauen um unterschiedliche Ausprägungen dieser Konzepte kennen zu lernen.
Nur so können wir der großen Vielfalt an Sprachen adequat begegnen ohne in einer Flut technischer Details unter zu gehen.

Zu Gute kommt uns dabei, dass Ingenieure, auch bei der Entwicklung einer neuen Sprache, nicht jedes mal auf der grünen Wiese anfangen, sondern gerne auf altbewährte Konzepte zurückgreifen.
Diese Evolutionäre Entwicklung ist allerdings nicht reiner Phantasielosigkeit geschuldet, sondern hat den sozialen Faktor, dass andere Ingenieure leichter in die neue Sprache hinein finden; die Einstiegshürde ist deutlich geringer.
Ein Beispiel für das evolutionäre einschleichen eines Sprachkonzepts in den Kanon allgemein bekannter Konzepte ist die Iteration über eine Sequenz von Elementen.
Wo in C noch umständlich mit Zeigern hantiert wird, und die alte C++ Variante beinahe genauso aussieht, hat die aktuelle Version von C++ die Möglichkeit, mittels einer Kurzschreibweise, über Sequenzen zu iterieren.

#+begin_src python
  sequence = [1, 1, 2, 3, 5, 8, 13]
  idx = 0
  while idx < len(sequence):
      print(sequence[idx])
      idx += 1

  print("---")
  for element in sequence:
      print(element)
#+end_src

Im Verlaufe des Skriptes gibt es Quellcodebeispiele, die direkt im Browser ausgeführt werden können.
Um die Ladezeit der Seite zu verringern haben wir darauf verzichtet diese Funktionalität standardmäßig zu aktivieren.
Durch einen Klick auf den "Load Interpreter" Button, wird [[https://github.com/viebel/klipse][Klipse]] nachgeladen und die Beispiele erwachen zum Leben und können auch direkt im Browser editiert werden.
Allerdings erfolgt das Nachladen von Klipse von Drittseiten, für deren Einstellung zu ihrer Privatsphäre wir nicht garantieren können.
Falls sie Browserplugins zur digitalen Selbstverteidigung, wie [[https://addons.mozilla.org/de/firefox/addon/umatrix/][uMatrix]], nutzen, müssen sie ihre Einstellungen entsprechend anpassen.

* Inhalt der Veranstaltung
:PROPERTIES:
:CUSTOM_ID: 01-inhalt
:END:

#+BEGIN_SRC latex
  \begin{frame}{Welchen Inhalt hat diese Veranstaltung?}
    \bi
    \ii \STRUCTURE{Programmiersprachen}: Abstrahiert von der echten Maschine {
      \bi
      \ii Kernkonzepte die sich in vielen Sprachen wiederfinden
      \ii High-Level Paradigmen (funktional, OO), die sich daraus zusammensetzen
      \ii Wir werden uns verschiedenste Programmiersprachen anschauen
      \ei
      }
    \ei

    \begin{center}
      \Large {\Huge $\downarrow$} Programmiersprachen und Übersetzer {\Huge $\uparrow$}
    \end{center}

    \bi
    \ii \STRUCTURE{Übersetzer}: Bringt die Abstraktionen auf die Maschine {
      \bi
      \ii Zwischenschritte vom Zeichenstrom zum Assemblerprogram
      \ii Nötige Datenstrukturen und Algorithmen
      \ii Praktische Arbeit an einem einfachen Übersetzer
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{Literaturhinweise}\small
    \begin{columns}
      \begin{column}{2cm}
        \includegraphics[width=\linewidth]{fig/01-pragmatics}%
      \end{column}
      \begin{column}{9cm}
        \emph{Programming Language Pragmatics, Fourth Edition.\\Michael L. Scott, 2015.}\\[1ex]
        Folgt einer ähnlichen Herangehensweise wie die Vorlesung. Deckt sowohl den Sprach- als auch den Übersetzerteil ab.
      \end{column}
    \end{columns}
    \bigskip
    \begin{columns}
      \begin{column}{2cm}
        \includegraphics[width=\linewidth]{fig/01-aho}%
      \end{column}

      \begin{column}{8cm}
        \emph{Compiler: Prinzipien, Techniken und Werkzeuge.\\Ullmann, Lam, Sethi, Aho, 2008.}\\[1ex]
         \textbf{Das} klassische Buch zum Übersetzerbau (Drachenbuch). Auch bereits in der alten Auflage von unschätzbarem Wissen.
       \end{column}
       \begin{column}{2cm}
         \includegraphics[width=\linewidth]{fig/01-aho-old}%
       \end{column}
     \end{columns}
  \end{frame}
#+END_SRC

Diese Veranstaltung trägt den Namen "Programmiersprachen und Übersetzer" und ist dementsprechend auch entlang dieser beiden Begriffe in zwei Teile getrennt, die allerdings eng miteinander interagieren.
Die Programmiersprachen geben vor, welche Konstrukte bei der *effektiven* Kodierung von Programmen verwendet werden können.
Auf der Gegenseite entscheidet der Übersetzer, wie diese Konstrukte auf die darunterliegende Maschine abgebildet werden und er bestimmt damit maßgeblich die *Effizienz* der Programmausführung.

Im Bereich der Sprachen werden wir uns mit Kernkonzepten beschäftigen, die in vielen unterschiedlichen Sprachen auftauchen.
Dazu gehört die Frage nach Typannotationen (z.B., ~int~, ~struct element~), genauso wie die Menge der verwendbaren Kontrollstrukturen (z.B.
~if~, ~while~, ~do-while~).
Hierbei werden wir eine Fokus auf jene Konzepte werfen, die in Sprachen verwendet werden die dem funktionale bzw.
dem objekt-orientierten Paradigma zugeordnet werden können.
Man kann davon sprechen, dass ein **Programmierparadigma** aus diesen Konzepten zusammengesetzt wird um einen bestimmen Stil oder "Philosophie" von Implementierungen zu ermöglichen.
Jedoch kann heute kaum noch eine Programmiersprache nur einem dieser Paradigmen zugeordnet werden.

Auf Seite der Übersetzer, wollen wir uns jene Zwischenschritte anschauen, die notwendig sind um Programme einer Hochsprache in die eigentliche Sprache der Maschine zu übersetzen.
Durch diese mechanische Übersetzung, bei der die Abstraktionen der Sprache schrittweise abgebaut werden, können wir nicht nur fest stellen ob bei der Kodierung Fehler passiert sind (der Übersetzung schlägt fehl), sondern es können auch diverse Optimierungen durchgeführt werden, auf die wir ebenfalls einen kurzen Blick werfen wollen.
Dabei können die Vorlesungen zum Übersetzerbau keine vollständige Einleitung sein, dazu ist die Vielfalt an möglichen Sprachkonstrukten zu groß.
Das Ziel dieser Termine ist es ihnen einen Überblick über die kanonischen Zwischenschitte der Übersetzung von imperativen Sprachen zu geben.
Dabei ist es ebenfalls mein Ziel ihnen eine Intuition zu vermitteln, welche Konstrukte einer Sprache inhärent weniger effizient sind als andere.

Als Literatur zu dieser Vorlesung empfehle ich ihnen "Programming Language Pragmatics" von Micahel L.
Scott, welches eine ähnliche Mischung von Sprachkonzepten und Übersetzerbau wie diese Vorlesung hat.
Dabei deckt dieses Buch viel mehr ab als wir in dieser Veranstaltung machen können, und ist daher nicht nur eine gute Grundlage zur Vor- und Nachbereitung, sondern auch ein Startpunkt für alle Studierenden, die sich noch tiefer mit dem Thema auseinander setzen wollen.
Daneben muss man auch **das** klassische Buch zum Übersetzerbau von Ullmann, Lam, Sethi und Aho empfehlen, welches den Übersetzerbau noch intensiver diskutiert.
Im Laufe der Veranstaltung werde ich, wo sinnvoll, einzelne Unterkapitel aus diesen Büchern referenzieren.

#+BEGIN_SRC latex
    \begin{frame}{Übersicht}
      \includegraphics[width=\textwidth,page=3]{fig/01-overview-small}
    \end{frame}

    \begin{frame}{Programmiersprachen}
      \centering
      \includegraphics[height=\textheight-2cm,page=1]{fig/01-overview-small}
    \end{frame}

    \begin{frame}{Übersetzer}
      \includegraphics[width=\textwidth,page=2]{fig/01-overview-small}
    \end{frame}

    \begin{frame}[fragile]{Kurzübersicht: Syntaktische Analyse}
      \framesubtitle{\lecturetag{compiler}{1}}
      \begin{center}
        \includegraphics[page=1,width=0.6\linewidth]{fig/01-overview-example}
      \end{center}
      \bi
      \ii Von der Zeichenkette zum Abstrakten Syntaxbaum {
        \bi
        \ii Strukturierte Daten lassen sich leicher verarbeiten als Strings
        \ii Formaler Gramatiken und effiziente Parsetechniken
        \ii Parser prüft einen Teil der Spracheregeln: Syntaktische Korrektheit
        \ei
      }
      \ei
    \end{frame}

    \begin{frame}{Kurzübersicht: Semantische Analyse}
      \framesubtitle{\lecturetag{compiler}{4}}
      \begin{center}
        \includegraphics[page=2,width=0.6\linewidth]{fig/01-overview-example}
      \end{center}
      \bi
      \ii Von Typprüfung und Namensauflösung {
        \bi
        \ii Ist das Programm wirklich Teil der Sprache?
        \ii Namensauflösung findet zu jedem Bezeichner das jeweilige Objekt.
        \ii Typprüfung stellt sicher, dass die deklarierten und inferrierten Typen stimmen.
        \ei
      }
      \ei
    \end{frame}

    \begin{frame}{Kurzübersicht: Zwischencodeerzeugung}
      \framesubtitle{\lecturetag{compiler}{7}}
      \begin{center}
        \includegraphics[page=3,width=\linewidth]{fig/01-overview-example}
      \end{center}
      \bi
      \ii Vom Syntaxbaum zum Kontrollflussgraphen {
        \bi
        \ii Zwischencode ist eine ausdrucksmächtige virtuelle Maschine.
        \ii Bereits nahe an realer Maschine, aber gut für Analysen und Optimierungen
        \ii Alle Sprachkonstrukte müssen linearisiert werden.
        \ei
      }
      \ei
    \end{frame}

    \begin{frame}[fragile]{Kurzübersicht: Maschinencode}
      \framesubtitle{\lecturetag{compiler}{9}}
      \begin{columns}
        \begin{column}{0.4\textwidth}
          \includegraphics[page=4,width=\linewidth]{fig/01-overview-example}
        \end{column}\hfill
        \begin{column}{0.4\textwidth}
          \begin{code}[tag=RV32I]
          \lstinputlisting[style=ASM]{lst/01-example-if.S}
        \end{code}
      \end{column}
    \end{columns}
    \bigskip

    \bi
    \ii Vom Zwischencode zur realen Maschine {
      \bi
      \ii Auswahl von passenden Befehlen der realen Maschine
      \ii Bestimmung des Stacklayouts für jede Funktion
      \ii Entscheidung welcher Wert zu welchem Zeitpunkt in einem Register \enquote{lebt}.
      \ei
    }
    \ei

    \end{frame}

#+END_SRC

Die drei Themenbereiche:
Übersetzertechniken, Sprachkonzepten und Paradigmen von Programmiersprachen werden in den nächsten 12 Vorlesungen vermischt und aufeinander aufbauend behandelt werden.
Dabei werden wir in der ersten Hälfte des Semesters die notwendigen Grundlagen an Sprachkonzepten schaffen, um sie dann direkt in der entsprechenden Phase der Übersetzung verwendet zu können.
Zum Beispiel führt die semantische Analyse sowohl die Typprüfung, als auch die Namensauflösung durch, wodurch Vorlesung 2 und 3 direkt in die Semantische Analyse im Übersetzer übergeht.

In der zweiten Hälfte des Semesters wird der Fokus der Veranstaltung sich in beide Richtungen erweitern:
Zum einen lernen wir die weiteren technischen Schritte kennen um vom Abstrakten Syntaxbaum zum fertigen Maschinenprogramm zu kommen.
Zum anderen schauen wir uns die Philosophie hinter dem objektorientierten und dem funktionalen Programmierparadigma an, welche aus den grundlegenden Sprachkonzepten komponiert sind.
Hier geht es nur noch teilweise um konkrete Techniken und Sprachkonstrukte, sondern mehr um jene Designentscheidungen und Prinzipien die man anwenden muss um objekt-orientiert bzw.
funktional zu programmieren.
Denn nur weil eine Sprache Abstraktionen für Klassen und Objekte anbietet, heißt es noch lange nicht, dass alle Programme, die in jener Sprache verfasst sind, automatisch auch Objekt-Orientiert sind.
Man kann jede Turing-vollständige Sprache gegen den Strich bürsten; man sollte es nur nicht tun.

Die einzelnen Schritte der Übersetzung können wir in mindestens vier Abschnitte eingeteilen, die von weiteren, optionalen, Abschnitten begleitet werden können.
Jeder dieser Abschnitte wird in einer Vorlesung behandelt und soll einen Überblick über das jeweilige Thema bieten.

- Syntaktische Analyse :: Die Übersetzung startet in der Syntaktischen Analyse mit dem Einlesen des Programms als Zeichenkette (z.B. von der Festplatte). Dabei haben die einzelnen Zeichen noch keinerlei *Bedeutung* (oder Semantik) für den Übersetzer, sondern es ist nur ein Array von Bytes. Zu diesem Zeitpunkt ist der Quellcode noch nach dem jeweiligen Gusto des Programmiers (z.B., überflüssige Leerzeichen) formatiert. Durch die Syntaktische Analyse überführen wir diese Sequenz von Bytes in einen **Abstrakten Syntaxbaum** (AST), der die hierarchische Programmstruktur widerspiegelt. In dem gezeigten Beispiel, ist die Bedingung ~a > b~ als erstes Kind der Bedingung im Baum eingeordnet. Um diesen Schritt der Strukturextraktion zu machen, werden wir uns die *Lexing* (Abtastung) und *Parsing* (Zerteilung) anschauen. Nachdem wir ein Programm syntaktisch analysiert haben, wissen wir ob es einen Syntaxfehler enthält. Allerdings ist noch nicht klar, ob es wirklich ein valides Programm der gewünschten Sprache ist, denn es könnte, zum Beispiel, noch Typfehler enthalten.
- Semantische Analyse :: Den zweiten notwendigen Schritt der Programmanalyse führen wir auf dem AST durch. Dabei analysieren wir den AST auf seine semantische Bedeutung. Zum einen bedeutet das den Schritt *vom Identifier zum Namen* zu machen (Namensauflösung) und für jede Verwendung einer Variable die gültige Definition zu finden. Im Beispiel sieht man dem AST erst nach der Semantischen Analyse an, dass ~a~ eine lokale und ~b~ eine globale Variable ist. Weiterhin wird das Programm auf Typkorrektheit hin untersucht: Passen, die von den Blättern des Baumes  (unten) zur Wurzel (oben) hin propagierten Datentypen, zu den verwendeten Operationen. Würde man im Beispiel schreiben ~a > "hallo"~, wäre dies zwar syntaktisch Korrekt, jedoch nicht semantisch, da man Zahlen nicht mit Zeichenketten vergleichen darf. Nach der Semantischen Analyse wissen wir endgültig ob das Programm ein valides Programm ist. Tritt bis hier kein Fehler bei der Übersetzung auf, darf auch in den nachfolgenden Schritten kein Fehler mehr auftreten.
- Erzeugung des Zwischencodes :: Mit dem Übergang vom AST zum Zwischencode (engl. intermediate representation, IR) klopfen wir die hierarchische Baumstruktur einzelner Operationen platt und machen einen großen Schritt hin zur realen Maschine. Der Zwischencode moderner Übersetzer ist die Assemblerbefehle angelehnt, enthält aber noch genug Informationen um weitreichende Programmoptimierungen durchzuführen. Der Zwischencode enthält keine sprachspezifischen Konstrukte mehr und kann daher für Sprachfrontends verwendet werden. Zum Beispiel wird sowohl die Programmiersprache [[https://www.rust-lang.org/][Rust]] als auch C++ (bei Verwendung von clang) in LLVM IR[fn::Einen kurzen Überblick über LLVM IR bietet der folgende Blogeintrag: https://idea.popcount.org/2013-07-24-ir-is-better-than-assembly/]
 übersetzt, bevor es an Optimierung und die Erzeugung der Binärdatei geht.
   #+CAPTION: Mehrere Frontends übersetzen in die gleiche Zwischensprache und erlauben es daher den selben Optimierer und verschiedene Maschinenbackends zu verwenden. Die Abbildung stammt aus dem [[http://aosabook.org/en/llvm.html][AOSA Buch]], CC BY-SA 3.0, Chris Lattner.
   #+NAME:   fig:01-retargetable-compiler
   [[./fig/01-retargetable-compiler.png]]


- Maschinencode :: Für den letzten Schritt zur Binärdatei, muss der Zwischencode zu Assemblerinstruktionen übersetzt werden. Dabei müssen semantisch äquivalente Befehle oder Befehlssequenzen der realen Maschine ausgewählt werden. Weiterhin verwendet der Zwischencode noch (unendlich viele) Variablen, wo die reale Maschine nur eine endliche Anzahl an Registern anbietet. Daher müssen die Werte an diese realen Register gebunden werden (Registerallokation).

#+begin_src latex
  \begin{frame}[fragile]{Was passiert in den Übungen?}
    \Alert{Ziel:} Vertiefung von theoretischem Wissen und praktische Erfahrungen.
    \medskip
    \bi
    \ii Theorieaufgaben zur Durchdringung des Vorlesungsinhalts
    \ii Praktische Programmieraufgaben {
      \bi
      \ii Erweiterung eines kleinen Beispielübersetzers (in Python)
      \ii Arbeiten am Parser, der Typprüfung, Codeerzeugung, und am Optimierer
      \ii Übersetzer macht selbst rege gebrauch von Python Sprachfeaturen
      \ei
    }\medskip
    \ii Die Programmiersprache L0 - Basis unseres Übersetzers{
      \begin{columns}
        \begin{column}{0.49\textwidth}
          \begin{code}[tag=L0]
            \begin{lzero}[]
              var fib_calls : int;

              func fib(n : int) : int {
                fib_calls = fib_calls + 1;
                if (n <= 1) {
                  return n;
                }
                return fib(n-1) + fib(n-2);
              }

            \end{lzero}
          \end{code}
        \end{column}
        \hfill
        \begin{column}{0.49\textwidth}
          \btUseExtraItemSep[-\smallskipamount]
          \bi
          \ii Globale und lokale Variablen
          \ii Funktionen mit mehreren Argumenten
          \ii Nur Ganzahlen und Pointer
          \ii Keine Sicherheitsnetze
          \ei

        \end{column}
      \end{columns}
    }
    \ei
  \end{frame}
#+END_SRC

Während wir in der Vorlesung die theoretischen Grundlagen kennen lernen, soll ihr Wissen in der Übung weiter vertieft werden.
Dies wird zum einen dadurch geschehen, dass wir ihnen passende theoretische Aufgaben zur Bearbeitung stellen.
Zum anderen sollen sie auch praktische Übungen an einem Beispielübersetzer, der von uns bereitgestellt wird, durchführen.
Dieser Übersetzer verarbeitet bereits die rudimentäre L0 Sprache und wird von ihnen um diverse Fähigkeiten erweitert werden.
Durch diese Arbeit an einem existierenden Übersetzer lernen sie sowohl den Aufbau eines solchen Softwareprojekts kennen, als können die Arbeit eines Übersetzers "Live und in Farbe" erleben.

* Organisation der Veranstaltung
:PROPERTIES:
:CUSTOM_ID: 01-organisation
:END:

#+BEGIN_SRC latex
  \begin{frame}[t]{Organisatorische Hinweise}
  \PutAt{(10.5cm,1cm)}{
    \includegraphics[width=2cm]{fig/01-dietrich}\\[2ex]
    \includegraphics[width=2cm]{fig/01-landsberg}
  }
  \bi
  \ii Vorlesung: 13 Vorlesung {
    \bi
    \ii Dienstag 9:00-11:00, 201, Conticampus
    \ii Semesterplan und Vorlesungskipt auf der SRA Webseite
    \ii \url{https://www.sra.uni-hannover.de/p/lehre-V\_PS\%C3\%9C}
    \ei
  }\medskip
  \ii Wie funktioniert der Übungsbetrieb? {
    \bi
    \ii 2 Übungstracks (A,B), mit einer Woche Versatz (wie GBS)
    \ii 6 Übungsaufgaben mit praktischem und theoretischem Inhalt\\[1ex]
    \ii Pro Track: 6 Tafel- und 6 Kleingruppenübungen, alternierend
    \ii Tafelübung: Dienstag 16:00-18:00,
    \ii Kleingruppenübung: Betreuung durch studentische Hilfskräfte
    \ei
  }\medskip
  \ii Bonuspunkte auf die Klausur (wie bei GBS) {
    \bi
    \ii Abgabe der Übungsaufgaben, maximal +10\%  Klausurpunkte
    \ii Testatklausur am \alert{23. Juni 2019}, maximal +10\% der Klausurpunkte
    \ii Bonuspunkte werden auf \structure{bestandene} Klausuren angerechnet.
    \ei
  }\bigskip
  \ii<2-> Was ist Klausurrelevant? \hfill\ALERT{\strut \only<3->{Vorlesung+Skript+Übung} }
  \ei
  \end{frame}
#+END_SRC

* Ebenenmodell und Virtuelle Maschinen
:PROPERTIES:
:CUSTOM_ID: 01-ebenenmodell
:END:

Das Ebenenmodell

#+BEGIN_SRC latex
  \begin{frame}
  \centering
  \Huge Ebenenmodell\\und\\ Virtuelle Maschinen
  \end{frame}

  \begin{frame}{Systemnahe Informatik}\framesubtitle{Der Blick aus 10000 Meilen}
      \begin{columns}
        \begin{column}{0.35\textwidth}
          \begin{center}\small
            \includegraphics[width=1.5cm]{fig/01-problem}\\\relax
            [Problem]\\[1ex]
            \fbox{\parbox{0.8\textwidth}{\centering
              Hochsprache\\
              $\Uparrow$\\
              \structure{Semantische Lücke}\\
              $\Downarrow$\\
              CPU-Steuersignale
            }}\\[1ex]\relax
          [Ausführung]\\\relax
          \includegraphics[width=1.5cm]{fig/01-cpu}
          \end{center}
        \end{column}\hfill
        \begin{column}{0.6\textwidth}
          \bi
          \ii {Informatisches Urproblem:\\ Schließen der Semantischen Lücke}\bigskip
          \ii Komplexitätsreduktion durch Abstraktion {
            \bi
            \ii Hierarchisch angeordnete \structure{virtuelle Maschinen}
            \ii Definierte Schnittstellen nach oben
            \ii Schrittweise Vereinfachungen nach unten
            \ei
          }\bigskip
          \ii PSÜ: Zwei Sichtweisen {
            \bi
            \ii Top-Down: Was bieten Sprachen an?
            \ii Bottom-Up: Wie bildet ein Compiler das ab?
            \ei
          }
          \ei
        \end{column}
      \end{columns}
    \end{frame}


    \newcommand{\down}[2][1em]{\tikzmark{#2}\tikz[remember picture,overlay]\draw[>=latex',->,thick,srared] (pic cs:#2)--++(down:#1);}
    \begin{frame}[label=vm-hierarchie]
      \frametitle{Hierarchie virtueller Maschinen\,\cite[S.\,3]{tanenbaum:06:sco}}

      \begin{columns}
        \begin{column}{0.7\textwidth}
          \bi
          \ii Schrittweises Schließen der semantischen Lücke\\[2ex]{
            \begin{tabular}{cllc}
              Ebene & Abstraktion & \\\hline
              $n$ & virtuelle Maschine $M_n$ & Sprache $L_n$ & \down{a} \\ \hline
              $\vdots$ & \multicolumn{1}{c}{$\vdots$}  & \multicolumn{1}{c}{$\vdots$}&\down{x}\\[0.5ex] \hline
              $2$ & virtuelle Maschine $M_2$ & Sprache $L_2$ &\down{b}\\ \hline
              $1$ & virtuelle Maschine $M_1$ & Sprache $L_1$ &\down{c}\\ \hline
              $0$ & reale Maschine $M_0$ & Sprache $L_0$\\\hline
            \end{tabular}
          }\bigskip
          \ii {$L_x$-Program wird auf Maschine $M_{x-1}$ abgebildet
            \bi
            \ii \STRUCTURE{Dynamisch}: Interpreter als $L_{x-1}$-Program
            \ii \STRUCTURE{Statisch}: Compiler erzeugt $L_{x-1}$ Program\\
                Spätere Abbildung von $L_{x-1}$ auf $M_{x-2}$.
            \ei
          }
          \ei
        \end{column}\hfill
        \begin{column}{0.2\textwidth}
          \begin{tikzpicture}
            \foreach \x/\s in {0/0.7,1/0.8,2/0.9,3/1} {
              \node at (\x*1mm,-\x * 8mm) {
                \includegraphics[width=\s\textwidth]{fig/01-matroschka}
              };
            }
          \end{tikzpicture}
          \legalcode[commons=Dedoushka-no_bg.jpg]{CC BY-SA 3.0}{Dedoushka}
        \end{column}
      \end{columns}
    \end{frame}

    \begin{frame}[t,label=vm-hierarchie-beispiel]{Beispiel: Arbeitsplatzrechner}
      \animation[trim={\btLeftMargin} 0pt 0pt 0pt, width=\textwidth]{1/1,2/2}{fig/01-layers}
    \end{frame}

#+END_SRC

Virtuelle Maschinen

#+begin_src latex
  \begin{frame}[t]{"Virtuelle Maschinen"}
    \alert{Wichtig:} Wir meinen nicht VMWare, Virtualbox oder KVM.\bigskip

    \bi
    \ii Maschienenmodell der virtuellen Maschine {
      \bi
      \ii \structure{Speicher/Objekte}: Wie kann man Daten ablegen und wieder abrufen?
      \ii \structure{Befehle/Operationen}: Wie kann man Daten miteinander kombinieren?
      \ii Ein "\structure{Prozessor}" kann dieses Modell implementieren.
      \ei
    }\medskip
    \ii Maschinenprogramme {
      \bi
      \ii Eine Menge Befehlen, die gegen das Maschinenmodell geschrieben wurden.
      \ii Wird von einem Prozessor verarbeitet um ein Ergebnis zu berechnen.
      \ei
    }\medskip
    \ii Sprache der virtuellen Maschiene {
      \bi
      \ii Nicht jede Zeichenkette ist ein für jedes Maschinenmodell ein valides Program.
      \ii Synaktische und Semantische Regeln um valide Programme zu schreiben.
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[fragile,t]{Beispiel: Die (virtuelle) RISC-V Maschine}
    RISC-V ist eine Rechnerarchitektur, die an industrieller Relevanz gewinnt.\bigskip

    \bi
    \ii Maschinenmodell (RV32I) {
      \bi
      \ii \structure{Speicher}: 32 CPU Register + frei addressierbarer Speicher.
      \ii \structure{Befehle}: 47 Instruktionen mit arithmetischen, binären und Sprungbefehlen.
      \ii Der SweRV von Western Digital is \alert{ein} Prozessor für dieses Modell.
      \ei
    }\medskip
    \ii Beispiel eines Maschinenprograms: 02 b5 05 3b 80 82 \pause{
      \\{\scriptsize (Wir tun mal so als wäre Assembler und Binärcode das gleiche)}\smallskip
      \begin{code}[tag=RV32I]
        \begin{asm}[]
          multiply: # int multiply(int a, int b) { return a*b; }
              mul a0, a0, a1
              ret
        \end{asm}
      \end{code}
    }\medskip
    \ii Die RV32I Assemblersprache {
      \bi
      \ii Welche Mnemonics gibt es? Anzahl und Art der Argumente.
      \ii \texttt{add}: 1 Ziel- und 2 Quellregister; \texttt{addi}: 1 Zielregister und 12-Bit Ganzzahl
      \ii \enquote{\texttt{addi a0, a2, $\gamma_i$}} -- wäre nicht valide in der RV32I Sprache.
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[fragile,t]{Beispiel: Die virtuelle C Maschine}
    \bi
    \ii Maschinenmodell {
      \bi
      \ii \structure{Speicher}: Definierten Variablen und über Pointer erreichbarer Speicher
      \ii \structure{Befehle}: z.B: \lstinline{if (a < 3) return b * (c + d);}
      \ii Sowohl GCC als auch Clang sind \enquote{Prozessoren} für dieses Modell.
      \ii Es gibt auch C Interpreter die als Prozessoren agieren.
      \ei
    }\medskip
    \ii Beispielprogramm : Der Obfuscated Tiny C Compiler (2048 Zeichen)\footnote{\url{https://bellard.org/otcc/}}{
      \begin{code}[tag=C90]
        \lstinputlisting[basicstyle=\ttfamily\tiny, breaklines=true, postbreak=\mbox{}]{lst/01-otcc.c}
      \end{code}
    }\medskip
    \ii Die C Sprache (eigentlich eine ganze Familie von Sprachen) {
      \bi
      \ii Variablen und Funktionen müssen deklariert sein, um sie zu nutzen.
      \ii Eine Ganzzahl is kein valider Funktionsname.
      \ii \enquote{\texttt{"12345(b, c)}} -- is kein valides C Programm.
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}<1-2>{Definitionen}
    \btUseExtraItemSep \setbeamercovered{transparent}
    \begin{description}
    \item[Programmiersprache] Regelwerk zur Erstellung von Zeichenketten, die valide Programme für ein bestimmtes
      Maschinenmodell sind. Verletzt eine Zeichenkette auch nur eine dieser Regeln ist es kein entsprechendes Programm.
    \item<1>[Interpreter] Ein Programm das  Sprachprozessor für bestimmten Maschinenmodell ist und andere Programme direkt ausführt.
    \item[Übersetzer] Ebenfalls ein Sprachprozessor, der das gegebene Programm allerdings nicht ausführt, sondern in eine valides
      Maschinenprogramm für eine andere Sprache übersetzt.
    \end{description}
  \end{frame}

#+end_src

Beobachtbare Zustände

#+begin_src latex
  \begin{frame}{Beobachtbare Zustände und Zustandsfolgen}
    \structure{Frage:} Wann ist eine Übersetzung eigentlich korrekt?\bigskip

    \bi
    \ii Das Maschinenmodell bestimmt den beobachtbaren Zustand ($q_n$) {
      \bi
      \ii Bei RISC-V: Zustand ist der Registersatz nach jeder Instruktionen.
      \ii Wir werden keine halb ausgeführten Instruktionen sehen.
      \ii Definition des beobachtbaren Zustands ist schwer bei komplexeren Sprachen.
      \ei
    }\medskip
    \ii Programmausführung durch einen Prozessor ergibt eine Zustandfolge: \\
    $q = (q_1, q_2, \ldots, q_n)$ {
      \bi
      \ii Die Zustände sind vom Speicher der Maschine abgeleitet
      \ii Die Übergänge sind Folge von ausgeführten Operationen: $q_t\rightarrow q_{t+1}$
      \ei
    }
    \ei
    \medskip
    \includegraphics[page=1]{fig/01-zustand}
  \end{frame}


  \begin{frame}[fragile]{Beispiel einer Zustandsfolge}
    \bi
    \ii Berechnung des größten gemeinsamen Teilers {
      \bi
      \ii Wiederholte Subtraktion {
      \begin{columns}
        \begin{column}{0.4\textwidth}
          \begin{code}[tag=Py]
            \lstinputlisting[style=py,linerange=sub0-sub1]{lst/ggt.py}
          \end{code}
        \end{column}
        \hfill
        \begin{column}{0.4\textwidth}\ttfamily
          \begin{stdout}
          (i,j) = (7, 35)
                  (7, 28)
                  (7, 21)
                  (7, 14)
                  (7, 7)
          \end{stdout}
        \end{column}
      \end{columns}
       }\pause
    \ii Wiederholtes Modulo {
      \begin{columns}
        \begin{column}{0.4\textwidth}
          \begin{code}[tag=Py]
            \lstinputlisting[style=py,linerange=mod0-mod1]{lst/ggt.py}
          \end{code}
        \end{column}
        \hfill
        \begin{column}{0.4\textwidth}
          \begin{stdout}
          (i,j) = (7, 35)
                  (0, 7)
          \end{stdout}
        \end{column}
      \end{columns}
    }
    \ei }\medskip
    \ii Beide Programme brechnen das gleiche Ergebnis: ggT=7\\
        Sie zeigen aber unterschiedliche Zustandsfolgen.
        \ei
    \medskip
    \pause
    \structure{Frage:} Darf ein Übersetzer einen Algorithmus tauschen?
  \end{frame}

  \begin{frame}{Korrektheit einer Übersetzung}
    \bi
    \ii Die Programmiersprache definiert die \alert{beobachtbaren} Zustände. {
      \bi
      \ii Ein- und Ausgabe ist immer beobachtbar, oft aber auch Teile des Speichers
      \ii Bei C: Nur das Schreiben von globalen Variablen, nicht aber von Lokalen.
      \ei
    }\bigskip
    \ii Ein \advantage{korrekter} Übersetzer erhält alle beobachtbaren Zustände.{
      \bi
      \ii Es kann eine allerdings Abbildungsfunktion geben:\\[2ex]{
        \includegraphics[page=2,width=0.9\textwidth]{fig/01-zustand}
      }
      \ii Eine sehr absurder Übersetzer könnte alle beobachtbaren Bits invertieren.
      \ei
    }\bigskip
    \ii Grundlage von optimierenden Übersetzer! {
      \bi
      \ii Ein optimierender Übersetzer erhält nur den beobachtbaren Zustand.
      \ii Der nicht-beobachtbare Zustand kann sich beliebig ändern.
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[fragile,t]{Beispiele korrekter Übersetzung von C nach \only<1>{C}\only<2>{RISC-V}\only<3>{Kobold}}
    \begin{code}[tag=C]
      \begin{C}[]
        void foo() {
          int x = 0;
          x += 1; x += 1; x += 1;
          return x;
        }
      \end{C}
    \end{code}
    \begin{center}
      \Huge$\Downarrow$
    \end{center}
    \begin{code}<1>[tag=C]
      \begin{C}[]
        void foo() {
          return 3;
        }
      \end{C}
    \end{code}%
    \begin{code}<2>[tag={RV32I}]
      \begin{asm}[]
        foo:
          lui a0, 3
          ret
      \end{asm}
    \end{code}%
    \begin{code}<3>[tag={Kobold}]
      \begin{columns}
        \begin{column}{0.25\textwidth}
          \centering
          \includegraphics[height=3cm]{fig/01-cobold}
          \legalcode[commons=Kobold_artlibre_jnl.jpg]{Free Art License}{Jean-no}
        \end{column}\hfill
        \begin{column}{0.6\textwidth}
          \centering
          Dies ist ein besonders gut geschulter Kobold. Immer wenn man ihn irgendetwas fragt, wird er mit \ALERT{3} antworten.
        \end{column}
      \end{columns}
    \end{code}
  \end{frame}
#+end_src

* Bootstrapping und Portierung
:PROPERTIES:
:CUSTOM_ID: 01-bootstrapping
:END:

#+begin_src latex
  \begin{frame}
    \Huge\centering
    Bootstrapping\\
    und\\
    Portierung
  \end{frame}

  \begin{frame}{Wer übersetzt den Übersetzer?}
    \bi
    \ii Wo läuft eigentlich der Übersetzer und wie kommen wir zu ihm? {
      \bi
      \ii Die allerersten Übersetzer von Programmen waren Menschen.
      \ii Wo sie herkommen: Evolution. Worauf sie laufen: Physik (wie der Kobold).
      \ei
    }\pause
    \ii Wir brauchen eine Übersetzer von L nach M der auf M läuft.\\[2ex] {
      \begin{center}
        \includegraphics[page=1,width=0.7\textwidth]{fig/01-t-diagram}
      \end{center}
    }
    \ei
    \bii
    \ii \Alert{Aber:} Es is zu aufwendig einen Übersetzer in M (z.B. Assembler) zu schreiben.
    \ii Wir wollen den Übersetzer lieber in L schreiben und irgendwie nach M bringen.
    \ii Dieser Prozess heißt Bootstrapping ($=$ sich selbst aus dem Sumpf ziehen).
    \eii
  \end{frame}

  \begin{frame}[t]{T-Diagramme (oder Tombstone Diagramme)}
    \bi
    \ii T-Diagramme dienen zur Visualisierung des Bootstrapping Problems \\[2ex] {
      \begin{center}
        \includegraphics[page=1,width=0.7\textwidth]{fig/01-t-diagram}
      \end{center}
    }
    \ei
    \begin{columns}
      \begin{column}{0.49\textwidth}
        \bi
        \ii Interpreter (für M auf m)\\[2ex]{
          \begin{center}
            \includegraphics[page=2,height=3cm]{fig/01-t-diagram}
          \end{center}
        }
        \ei
      \end{column}
      \begin{column}{0.49\textwidth}
        \bi
        \ii Echte Maschinen (führen m aus)\\[2ex]{
          \begin{center}
            \includegraphics[page=3,height=2cm]{fig/01-t-diagram}
            \vspace{1cm}
          \end{center}
        }
        \ei
      \end{column}
    \end{columns}

  \end{frame}

  \begin{frame}{1. Möglichkeit: Selbstübersetzung mittels Interpreter}
    \bi
    \ii Schreibe einen Interpreter \dn2 für L. Führe \dn1 auf \dn2 aus, um \dn[fill=badbee!40]{1} in \dn[fill=badbee!40]{1'} zu übersetzen.\\[2ex] {
      \begin{center}
        \only<1>{\includegraphics[height=4cm, page=4]{fig/01-t-diagram}}%
        \only<2>{\includegraphics[height=4cm, page=5]{fig/01-t-diagram}}
      \end{center}
    }
    \iiad (Langsame) Interpreter schreiben ist meist einfacher als Übersetzer.
    \iida Doppelter Aufwand und der Interpreter ist Wegwerfware
    \iida Verhält sich \dn1 auf echter Hardware und im Interpreter gleich?
    \ei
  \end{frame}

  \begin{frame}{2. Möglichkeit: Vereinfachter Übersetzer}
    \bi
    \ii Ableitung eines einfacheren Übersetzers \dn2 aus dem Vollausgestatten \dn1.\\[2ex] {
      \begin{center}
        \includegraphics[height=2cm, page=6]{fig/01-t-diagram}
      \end{center}
      \bi
      \ii Das Subset L' (von L) enthält nur die unbedingt notwendigen Sprachelemente.
      \ii Das Subset M' (von M) enthält nur einfache Maschinenbefehle.
      \ii \dn{2} darf langsam sein und langsamen Code erzeugen.
      \ei
    }
    \ii<2-> Manuelle oder semiautomatische Übersetzung von \dn{2} in \dn{3}.\\[2ex] {
      \begin{center}
        \includegraphics[height=2cm, page=7]{fig/01-t-diagram}
      \end{center}
      \bi
      \ii Teilweise mit einem existierenden Übersetzers einer anderen Sprache möglich.
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{2. Möglichkeit: Vereinfachter Übersetzer}
    \begin{center}
      \animation[width=0.8\textwidth]{8/1,9/2,10/3,11/4}{fig/01-t-diagram}
    \end{center}
    \begin{enumerate}
    \item Übersetze \dn{2} mit \dn{3}: \dn{2a} ist langsam und erzeugt langsamen Code.
    \item<3-> Übersetze \dn{1} zu einem langsamen, aber optimierenden, Übersetzer (1a).
    \item<4-> Übersetze \dn{1} erneut mit sich selbst (1b).
    \end{enumerate}
  \end{frame}
#+end_src


Portierung
#+begin_src latex
  \begin{frame}{Portierung auf neue Plattform und Cross-Compiler}
    \begin{center}
      \animation[width=0.7\textwidth]{12/1,13/2,14/3-}{fig/01-t-diagram}
    \end{center}
    \bi
    \ii Ähnliches Probleme wenn man auf eine neue Plattform N wechselt. {
      \bi
      \ii<2-> Mit der vorhandenen Werkzeugkette: Erzeuge den \alert{Cross-Compiler} \dn{Z'}.
      \ii<3-> Übersetze \dn{Z} mit seinem Cross-Compiler zu \dn{Z''}.
      \ei
    }
    \ii<4> Zunehmend kein Problem mehr, da viele Übersetzer Multitarget bieten. {
      \bi
      \ii Das Übersetzerbackend  bietet, über Optionen, sowohl M als auch N an.
      \ii LLVM: \texttt{llc -version} \hfill(\texttt{llc} ist das Backend von LLVM)
      \ei
    }
    \ei
  \end{frame}
#+end_src


* Zusammenfassung
#+begin_src latex
  \begin{frame}{Zusammenfassung}
    \bi
    \ii Virtuelle Maschinen führen Programme aus, haben Speicher und Befehle{%
      \bi
      \ii Ihre Maschinensprache umfasst alle valide Programme.
      \ii Korrekter Übersetzer erhält die Sprachsemantik und beobachtbare Zustände.
      \ei
    }\bigskip
    \ii Ebenenmodell: Schrittweise Abstraktion von der echten Hardware {
      \bi
      \ii Obere Schichten bieten ausdrucksstärkere Sprachen.
      \ii Untere Schichten sind direkt implementierbar.
      \ii Übergang zu den unteren Schichten durch Übersetzung (oder Interpretation)
      \ei
    }\bigskip
    \ii Bootstrapping: Der erste Übersetzer übersetzt sich selbst. {
      \bi
      \ii Reduktion auf manuelle Übersetzung eines abgespeckten Übersetzers
      \ii Bei der Portierung auf neue Plattform braucht es einn Cross-Compiler
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{Quellenverzeichnis}
    \nocite{scott:15:book}
    \nocite{aho:07}
    \printbibliography
  \end{frame}
#+end_src
