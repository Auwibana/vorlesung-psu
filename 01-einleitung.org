#+TITLE: Programmiersprachen und Übersetzer
#+SUBTITLE: 01 - Einleitung
#+INCLUDE: export-prologue.org
#+PROPERTY: header-args:latex :tangle yes :noweb yes :tangle-macros yes :tangle-prologue topic :tangle-epilogue endtopic :exports none

#+NAME: topic
#+BEGIN_SRC latex :tangle no
\psuSectionStart{{{{property(ITEM)}}}}
#+END_SRC

#+NAME: endtopic
#+BEGIN_SRC latex :tangle no
\psuSectionStop{{{{property(ITEM)}}}}{{{{range()}}}}
#+END_SRC

#+BEGIN_SRC latex :tangle-prologue nil :tangle-epilogue nil
\subtitle{{{{subtitle()}}}}
\begin{frame}
  \maketitle
\end{frame}
\psuSectionStop{Titlepage}{{{{range()}}}}
#+END_SRC

* Gedanken zu dieser Vorlesungseinheit                             :noexport:
Mit der ersten Vorlesung, soll der Studierene für die Vorlesung
motiviert werden. Es soll verstehen, welcher ganz konkreten
Erkenntnisgewinn daraus gezogen werden kann sich mit
Programmiersprachen und deren Implementierungen zu beschäftigen. Ihm
muss klar werden, dass er hier zukunftssicheres Wissen erlangt.

- Was muss der Studierende wissen um eine neue Programmiersprache
  effektiv und effizient ein zu setzen?

  - Welche Abstraktion bietet eine Programmiersprache an und was hat dies mit dem Ebenenmodell zu tun?

  - Was ist der Unterschied zwischen einem Interpreter und einem Übersetzer?

  - Was darf ein Übersetzer und was darf dieser nicht?


* Einleitung
:PROPERTIES:
:CUSTOM_ID: 01-einleitung
:END:

#+BEGIN_SRC latex
  \begin{frame}{Der Dozent}
    \bi
    \ii Wer ist der Dozent da?\\{
      Informatikstudium in Erlangen (ab 2009), Promotion in Hannover (2019)\\
      Betriebssysteme, Emacs User, Schwäche für Graphdatenstrukturen
    }\qquad
    \ii Ich mag Programmiersprachen! {
      \bi
      \ii Sie erleichtern mir Lösungen klar und deutlich aufzuschreiben.
      \ii Sowohl eleganter als auch zu komplexer Code ist Kunst.
      \ei
    }\qquad\qquad
    \ii<2-> Dies ist meine erste eigene Vorlesung. {
      \bi
      \ii Wir müssen das jetzt gemeinsam durchstehen.
      \ii Ich werde mein Bestes geben ihnen nur Sinnvolles zu vermitteln.
      \ii Melden sie sich mit Fehlern, Kritik und Anregungen.
      \ei
    }
    \ei
  \end{frame}
#+END_SRC

#+BEGIN_SRC latex
  \begin{frame}{Was soll diese Veranstaltung leisten?}
    \btUseExtraItemSep
  \bi
  \ii<+-> Informatiker werden fortwährend mit neuen Sprachen konfrontiert. {
    \bi
    \ii The next 700 programming languages, P. J. Landin\only<+->{, \citeyear{landin:66:cacm}\hfill\cite{landin:66:cacm}}
    \ii<+-> Hype Train (z.B. Rust), Evolution (C++20), Legacy (COBOL)
    \ii<.-> Sprachen Allerorten: HTML5, LaTex/TikZ, SQL, QT5/QML,
    \ei
  }
  \ii<+-> \Structure{Anforderung an Sie}: Schnell \alert{effektiv} und \alert{effizient} entwickeln können. {
    \bi
    \ii Effektiv:  In der Lage sein ein komplexes Program zu schreiben.
    \ii Effizient: Das Programm soll schnell und sparsam sein.
    \ii Häufig gibt es eine Abwägung zwischen beiden Zielen (siehe Skriptsprachen)
    \ei
  }
  \ii<.-> \Structure{Mein Ziel}: Vermittlung von Handwerkszeug und Denkweisen {
    \bi
    \ii Welche Fragen muss ich an eine neue Programmiersprache stellen?
    \ii Welche Konstrukte müssen prinzipbedingt teuer sein?
    \ii Demystifizierung der Compiler Black Box.
    \ei
  }
  \ei
  \end{frame}

  \begin{frame}[fragile,t]{Wieso ist das überhaupt möglich?}
    \btUseExtraItemSep
    \bi
    \ii Sprachen wurden von Ingenieuren erdacht. Man baut was man kennt.  {
      \bi
      \ii Jede neue Sprache bringt nur eine Hand voll neuer Konzepte
      \ii Der Rest ist eine Rekombination von bereits bekanntem
      \ei
    }
    \ii<+-> Beispiel: Über einen Zahlenvektor iterieren {

    \begin{code}<.>[tag=C]
      \begin{C}[]
        int sum = 0;
        int *it;
        for (it  = &vec[0];    // Initialisierung
             it != &vec[10];   // Abbruchbedingung
             ++it) {           // Nächstes Element
          sum += (*i);
        }
      \end{C}
    \end{code}%
    \begin{code}<+>[tag=C++03]
      \begin{CPP}[]
        int sum = 0;
        std::vector<int>::iterator it;
        for (it = vec.begin();  // Initialisierung
             it != vec.end();   // Abbruchbedingung
             ++it) {            // Nächstes Element
          sum += (*i);
        }
      \end{CPP}
    \end{code}%
    \begin{code}<+>[tag=C++11]
      \begin{CPP}[]
        int sum = 0;
        for (int x : vec) { // foreach Schleife
          sum += x
        }
      \end{CPP}
    \end{code}%
    \begin{code}<+->[tag=Python]
      \begin{py}[]
        sum = 0
        for x in vec:
            sum += x
      \end{py}
    \end{code}
  }
    \ii<+> Gemeinsame Konzepte von verschiedenen Programmiersprachen {
      \bi
      \ii Datentypen, Objekte, Benennung von Objekten, Operationen auf Objekten
      \ii Gemeinsamkeiten erleichtern erfahrenen Programmierern den Einstieg.
      \ii Unendliche Mannigfaltigkeit in unendlicher Kombination!
      \ei
    }
    \ei

  \end{frame}
#+END_SRC

* Inhalt der Veranstaltung
:PROPERTIES:
:CUSTOM_ID: 01-inhalt
:END:

#+BEGIN_SRC latex
  \begin{frame}{Welchen Inhalt hat diese Veranstaltung?}
    \bi
    \ii \STRUCTURE{Programmiersprachen}: Abstrahiert von der echten Maschine {
      \bi
      \ii Kernkonzepte die sich in vielen Sprachen wiederfinden
      \ii High-Level Paradigmen (funktional, OO), die sich daraus zusammensetzen
      \ii Wir werden uns verschiedenste Programmiersprachen anschauen
      \ei
      }
    \ei

    \begin{center}
      \Large {\Huge $\downarrow$} Programmiersprachen und Übersetzer {\Huge $\uparrow$}
    \end{center}

    \bi
    \ii \STRUCTURE{Übersetzer}: Bringt die Abstraktionen auf die Maschine {
      \bi
      \ii Zwischenschritte vom Zeichenstrom zum Assemblerprogram
      \ii Nötige Datenstrukturen und Algorithmen
      \ii Praktische Arbeit an einem einfachen Übersetzer
      \ei
    }
    \ei

  \end{frame}

  \begin{frame}{Programmiersprachen}
    \centering
    \includegraphics[height=\textheight-2cm,page=1]{fig/01-overview-small}
  \end{frame}

  \begin{frame}{Übersetzer}
    \includegraphics[width=\textwidth,page=2]{fig/01-overview-small}
  \end{frame}

  \begin{frame}{Übersicht}
    \includegraphics[width=\textwidth,page=3]{fig/01-overview-small}
  \end{frame}
#+END_SRC

#+BEGIN_SRC latex
\begin{frame}{Was passiert in den Übungen?}
FIXME
\end{frame}
#+END_SRC

#+BEGIN_SRC latex
\begin{frame}{Literaturhinweise}
FIXME
\end{frame}
#+END_SRC

* TODO Organisation der Veranstaltung
:PROPERTIES:
:CUSTOM_ID: 01-organisation
:END:

#+BEGIN_SRC latex
\begin{frame}{Organisatorische Hinweise}
\bi
\ii Wie funktioniert der Vorlesungsbetrieb?
\ii Wie funktioniert der Übungsbetrieb?
\ii Was ist Klausurrelevant
\ei
\end{frame}
#+END_SRC


* Ebenenmodell und Virtuelle Maschinen
:PROPERTIES:
:CUSTOM_ID: 01-ebenenmodell
:END:

#+BEGIN_SRC latex
\begin{frame}
\centering
\Huge Ebenenmodell\\und\\ Virtuelle Maschinen
\end{frame}

\begin{frame}{Systemnahe Informatik}\framesubtitle{Der Blick aus 10000 Meilen}
    \begin{columns}
      \begin{column}{0.35\textwidth}
        \begin{center}\small
          \includegraphics[width=1.5cm]{fig/01-problem}\\\relax
          [Problem]\\[1ex]
          \fbox{\parbox{0.8\textwidth}{\centering
            Hochsprache\\
            $\Uparrow$\\
            \structure{Semantische Lücke}\\
            $\Downarrow$\\
            CPU-Steuersignale
          }}\\[1ex]\relax
        [Ausführung]\\\relax
        \includegraphics[width=1.5cm]{fig/01-cpu}
        \end{center}
      \end{column}\hfill
      \begin{column}{0.6\textwidth}
        \bi
        \ii {Informatisches Urproblem:\\ Schließen der Semantischen Lücke}\bigskip
        \ii Komplexitätsreduktion durch Abstraktion {
          \bi
          \ii Hierarchisch angeordnete \structure{virtuelle Maschinen}
          \ii Definierte Schnittstellen nach oben
          \ii Schrittweise Vereinfachungen nach unten
          \ei
        }\bigskip
        \ii PSÜ: Zwei Sichtweisen {
          \bi
          \ii Top-Down: Was bieten Sprachen an?
          \ii Bottom-Up: Wie bildet ein Compiler das ab?
          \ei
        }
        \ei
      \end{column}
    \end{columns}
  \end{frame}


  \newcommand{\down}[2][1em]{\tikzmark{#2}\tikz[remember picture,overlay]\draw[>=latex',->,thick,srared] (pic cs:#2)--++(down:#1);}
  \begin{frame}[label=vm-hierarchie]
    \frametitle{Hierarchie virtueller Maschinen\,\cite[S.\,3]{tanenbaum:06:sco}}

    \begin{columns}
      \begin{column}{0.7\textwidth}
        \bi
        \ii Schrittweises Schließen der semantischen Lücke\\[2ex]{
          \begin{tabular}{cllc}
            Ebene & Abstraktion & \\\hline
            $n$ & virtuelle Maschine $M_n$ & Sprache $L_n$ & \down{a} \\ \hline
            $\vdots$ & \multicolumn{1}{c}{$\vdots$}  & \multicolumn{1}{c}{$\vdots$}&\down{x}\\[0.5ex] \hline
            $2$ & virtuelle Maschine $M_2$ & Sprache $L_2$ &\down{b}\\ \hline
            $1$ & virtuelle Maschine $M_1$ & Sprache $L_1$ &\down{c}\\ \hline
            $0$ & reale Maschine $M_0$ & Sprache $L_0$\\\hline
          \end{tabular}
        }\bigskip
        \ii {$L_x$-Program wird auf Maschine $M_{x-1}$ abgebildet
          \bi
          \ii \STRUCTURE{Dynamisch}: Interpreter als $L_{x-1}$-Program
          \ii \STRUCTURE{Statisch}: Compiler erzeugt $L_{x-1}$ Program\\
              Spätere Abbildung von $L_{x-1}$ auf $M_{x-2}$.
          \ei
        }
        \ei
      \end{column}\hfill
      \begin{column}{0.2\textwidth}
        \begin{tikzpicture}
          \foreach \x/\s in {0/0.7,1/0.8,2/0.9,3/1} {
            \node at (\x*1mm,-\x * 8mm) {
              \includegraphics[width=\s\textwidth]{fig/01-matroschka}
            };
          }
        \end{tikzpicture}
        \legalcode[commons=Dedoushka-no_bg.jpg]{CC BY-SA 3.0}{Dedoushka}
      \end{column}
    \end{columns}
  \end{frame}

  \begin{frame}[t,label=vm-hierarchie-beispiel]{Beispiel: Arbeitsplatzrechner}
    \animation[trim={\btLeftMargin} 0pt 0pt 0pt, width=\textwidth]{1/1,2/2}{fig/01-layers}
  \end{frame}

#+END_SRC


#+begin_src latex
  \begin{frame}[t]{"Virtuelle Maschinen"}
    \alert{Wichtig:} Wir meinen nicht VMWare, Virtualbox oder KVM.\bigskip

    \bi
    \ii Maschienenmodell der virtuellen Maschine {
      \bi
      \ii \structure{Speicher/Objekte}: Wie kann man Daten ablegen und wieder abrufen?
      \ii \structure{Befehle/Operationen}: Wie kann man Daten miteinander kombinieren?
      \ii Ein "\structure{Prozessor}" kann dieses Modell implementieren.
      \ei
    }\medskip
    \ii Maschinenprogramme {
      \bi
      \ii Eine Menge Befehlen, die gegen das Maschinenmodell geschrieben wurden.
      \ii Wird von einem Prozessor verarbeitet um ein Ergebnis zu berechnen.
      \ei
    }\medskip
    \ii Sprache der virtuellen Maschiene {
      \bi
      \ii Nicht jede Zeichenkette ist ein für jedes Maschinenmodell ein valides Program.
      \ii Synaktische und Semantische Regeln um valide Programme zu schreiben.
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[fragile,t]{Beispiel: Die RISC-V (Virtuelle) Maschine}
    RISC-V ist eine Rechnerarchitektur, die an industrieller Relevanz gewinnt.\bigskip

    \bi
    \ii Maschienenmodell (RV32I) {
      \bi
      \ii \structure{Speicher}: 32 CPU Register + frei addressierbarer Speicher.
      \ii \structure{Befehle}: 47 Instruktionen mit arithmetischen, binären und Sprungbefehlen.
      \ii Der SweRV von Western Digital is \alert{ein} Prozessor für dieses Modell.
      \ei
    }\medskip
    \ii Beispiel eines Maschinenprograms: 02 b5 05 3b 80 82 \pause{
      \\{\scriptsize (Wir tun mal so als wäre Assembler und Binärcode das gleiche)}\smallskip
      \begin{code}[tag=RV32I]
        \begin{asm}[]
          multiply: # int multiply(int a, int b) { return a*b; }
              mul a0, a0, a1
              ret
        \end{asm}
      \end{code}
    }\medskip
    \ii Die RV32I Assemblersprache {
      \bi
      \ii Welche Mnemonics gibt es? Anzahl und Art der Argumente.
      \ii \texttt{add}: 1 Ziel- und 2 Quellregister; \texttt{addi}: 1 Zielregister und 12-Bit Ganzzahl
      \ii \enquote{\texttt{addi a0, a2, $\gamma_i$}} -- wäre nicht valide in der RV32I Sprache.
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[fragile,t]{Beispiel: Die virtuelle C Maschine}
    \bi
    \ii Maschienenmodell {
      \bi
      \ii \structure{Speicher}: Definierten Variablen und über Pointer erreichbarer Speicher
      \ii \structure{Befehle}: z.B: \lstinline{if (a < 3) return b * (c + d);}
      \ii Sowohl GCC als auch Clang sind \enquote{Prozessoren} für dieses Modell.
      \ii Es gibt auch C Interpreter die als Prozessoren agieren.
      \ei
    }\medskip
    \ii Beispielprogramm : Der Obfuscated Tiny C Compiler (2048 Zeichen)\footnote{\url{https://bellard.org/otcc/}}{
      \begin{code}[tag=C90]
        \lstinputlisting[basicstyle=\ttfamily\tiny, breaklines=true, postbreak=\mbox{}]{lst/01-otcc.c}
      \end{code}
    }\medskip
    \ii Die C Sprache (eigentlich eine ganze Familie von Sprachen) {
      \bi
      \ii Variablen und Funktionen müssen deklariert sein, um sie zu nutzen.
      \ii Eine Ganzzahl is kein valider Funktionsname.
      \ii \enquote{\texttt{"12345(b, c)}} -- is kein valides C Programm.
      \ei
    }
    \ei
  \end{frame}

#+end_src
Bootstrapping und Cross-Compilation
- T-Diagramme
- Übersetzung
