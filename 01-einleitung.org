#+TITLE: Programmiersprachen und Übersetzer
#+SUBTITLE: 01 - Einleitung
#+INCLUDE: export-prologue.org
#+PROPERTY: header-args:latex :tangle yes :noweb yes :tangle-macros yes :tangle-prologue topic :tangle-epilogue endtopic :exports none

#+NAME: topic
#+BEGIN_SRC latex :tangle no
\psuSectionStart{{{{property(ITEM)}}}}
#+END_SRC

#+NAME: endtopic
#+BEGIN_SRC latex :tangle no
\psuSectionStop{{{{property(ITEM)}}}}{{{{range()}}}}
#+END_SRC

#+BEGIN_SRC latex :tangle-prologue nil :tangle-epilogue nil
\subtitle{{{{subtitle()}}}}
\begin{frame}
  \maketitle
\end{frame}
\psuSectionStop{Titlepage}{{{{range()}}}}
#+END_SRC

* Gedanken zu dieser Vorlesungseinheit                             :noexport:
Mit der ersten Vorlesung, soll der Studierene für die Vorlesung
motiviert werden. Es soll verstehen, welcher ganz konkreten
Erkenntnisgewinn daraus gezogen werden kann sich mit
Programmiersprachen und deren Implementierungen zu beschäftigen. Ihm
muss klar werden, dass er hier zukunftssicheres Wissen erlangt.

- Was muss der Studierende wissen um eine neue Programmiersprache
  effektiv und effizient ein zu setzen?

  - Welche Abstraktion bietet eine Programmiersprache an und was hat dies mit dem Ebenenmodell zu tun?

  - Was ist der Unterschied zwischen einem Interpreter und einem Übersetzer?

  - Was darf ein Übersetzer und was darf dieser nicht?


* Einleitung
:PROPERTIES:
:CUSTOM_ID: 01-einleitung
:END:

#+BEGIN_SRC latex
  \begin{frame}{Der Dozent}
    \bi
    \ii Wer ist der Dozent da?\\{
      Informatikstudium in Erlangen (ab 2009), Promotion in Hannover (2019)\\
      Betriebssysteme, Emacs User, Schwäche für Graphdatenstrukturen
    }\qquad
    \ii Ich mag Programmiersprachen! {
      \bi
      \ii Sie erleichtern mir Lösungen klar und deutlich aufzuschreiben.
      \ii Sowohl eleganter als auch zu komplexer Code ist Kunst.
      \ei
    }\qquad\qquad
    \ii<2-> Dies ist meine erste eigene Vorlesung. {
      \bi
      \ii Wir müssen das jetzt gemeinsam durchstehen.
      \ii Ich werde mein Bestes geben ihnen nur Sinnvolles zu vermitteln.
      \ii Melden sie sich mit Fehlern, Kritik und Anregungen.
      \ei
    }
    \ei
  \end{frame}
#+END_SRC

#+BEGIN_SRC latex
  \begin{frame}{Was soll diese Veranstaltung leisten?}
    \btUseExtraItemSep
  \bi
  \ii<+-> Informatiker werden fortwährend mit neuen Sprachen konfrontiert. {
    \bi
    \ii The next 700 programming languages, P. J. Landin\only<+->{, \citeyear{landin:66:cacm}\hfill\cite{landin:66:cacm}}
    \ii<+-> Hype Train (z.B. Rust), Evolution (C++20), Legacy (COBOL)
    \ii<.-> Sprachen Allerorten: HTML5, LaTex/TikZ, SQL, QT5/QML,
    \ei
  }
  \ii<+-> \Structure{Anforderung an Sie}: Schnell \alert{effektiv} und \alert{effizient} entwickeln können. {
    \bi
    \ii Effektiv:  In der Lage sein ein komplexes Program zu schreiben.
    \ii Effizient: Das Programm soll schnell und sparsam sein.
    \ii Häufig gibt es eine Abwägung zwischen beiden Zielen (siehe Skriptsprachen)
    \ei
  }
  \ii<.-> \Structure{Mein Ziel}: Vermittlung von Handwerkszeug und Denkweisen {
    \bi
    \ii Welche Fragen muss ich an eine neue Programmiersprache stellen?
    \ii Welche Konstrukte müssen prinzipbedingt teuer sein?
    \ii Demystifizierung der Compiler Black Box.
    \ei
  }
  \ei
  \end{frame}

  \begin{frame}[fragile,t]{Wieso ist das überhaupt möglich?}
    \btUseExtraItemSep
    \bi
    \ii Sprachen wurden von Ingenieuren erdacht. Man baut was man kennt.  {
      \bi
      \ii Jede neue Sprache bringt nur eine Hand voll neuer Konzepte
      \ii Der Rest ist eine Rekombination von bereits bekanntem
      \ei
    }
    \ii<+-> Beispiel: Über einen Zahlenvektor iterieren {

    \begin{code}<.>[tag=C]
      \begin{C}[]
        int sum = 0;
        int *it;
        for (it  = &vec[0];    // Initialisierung
             it != &vec[10];   // Abbruchbedingung
             ++it) {           // Nächstes Element
          sum += (*i);
        }
      \end{C}
    \end{code}%
    \begin{code}<+>[tag=C++03]
      \begin{CPP}[]
        int sum = 0;
        std::vector<int>::iterator it;
        for (it = vec.begin();  // Initialisierung
             it != vec.end();   // Abbruchbedingung
             ++it) {            // Nächstes Element
          sum += (*i);
        }
      \end{CPP}
    \end{code}%
    \begin{code}<+>[tag=C++11]
      \begin{CPP}[]
        int sum = 0;
        for (int x : vec) { // foreach Schleife
          sum += x
        }
      \end{CPP}
    \end{code}%
    \begin{code}<+->[tag=Python]
      \begin{py}[]
        sum = 0
        for x in vec:
            sum += x
      \end{py}
    \end{code}
  }
    \ii<+> Gemeinsame Konzepte von verschiedenen Programmiersprachen {
      \bi
      \ii Datentypen, Objekte, Benennung von Objekten, Operationen auf Objekten
      \ii Gemeinsamkeiten erleichtern erfahrenen Programmierern den Einstieg.
      \ii Unendliche Mannigfaltigkeit in unendlicher Kombination!
      \ei
    }
    \ei

  \end{frame}
#+END_SRC

* Inhalt der Veranstaltung
:PROPERTIES:
:CUSTOM_ID: 01-inhalt
:END:

#+BEGIN_SRC latex
  \begin{frame}{Welchen Inhalt hat diese Veranstaltung?}
    \bi
    \ii \STRUCTURE{Programmiersprachen}: Abstrahiert von der echten Maschine {
      \bi
      \ii Kernkonzepte die sich in vielen Sprachen wiederfinden
      \ii High-Level Paradigmen (funktional, OO), die sich daraus zusammensetzen
      \ii Wir werden uns verschiedenste Programmiersprachen anschauen
      \ei
      }
    \ei

    \begin{center}
      \Large {\Huge $\downarrow$} Programmiersprachen und Übersetzer {\Huge $\uparrow$}
    \end{center}

    \bi
    \ii \STRUCTURE{Übersetzer}: Bringt die Abstraktionen auf die Maschine {
      \bi
      \ii Zwischenschritte vom Zeichenstrom zum Assemblerprogram
      \ii Nötige Datenstrukturen und Algorithmen
      \ii Praktische Arbeit an einem einfachen Übersetzer
      \ei
    }
    \ei

  \end{frame}

  \begin{frame}{Programmiersprachen}
    \centering
    \includegraphics[height=\textheight-2cm,page=1]{fig/01-overview-small}
  \end{frame}

  \begin{frame}{Übersetzer}
    \includegraphics[width=\textwidth,page=2]{fig/01-overview-small}
  \end{frame}

  \begin{frame}{Übersicht}
    \includegraphics[width=\textwidth,page=3]{fig/01-overview-small}
  \end{frame}
#+END_SRC

#+BEGIN_SRC latex
\begin{frame}{Was passiert in den Übungen?}
FIXME
\end{frame}
#+END_SRC

#+BEGIN_SRC latex
\begin{frame}{Literaturhinweise}
FIXME
\end{frame}
#+END_SRC

* TODO Organisation der Veranstaltung
:PROPERTIES:
:CUSTOM_ID: 01-organisation
:END:

#+BEGIN_SRC latex
\begin{frame}{Organisatorische Hinweise}
\bi
\ii Wie funktioniert der Vorlesungsbetrieb?
\ii Wie funktioniert der Übungsbetrieb?
\ii Was ist Klausurrelevant
\ei
\end{frame}
#+END_SRC


* Ebenenmodell und Virtuelle Maschinen
:PROPERTIES:
:CUSTOM_ID: 01-ebenenmodell
:END:

Das Ebenenmodell

#+BEGIN_SRC latex
  \begin{frame}
  \centering
  \Huge Ebenenmodell\\und\\ Virtuelle Maschinen
  \end{frame}

  \begin{frame}{Systemnahe Informatik}\framesubtitle{Der Blick aus 10000 Meilen}
      \begin{columns}
        \begin{column}{0.35\textwidth}
          \begin{center}\small
            \includegraphics[width=1.5cm]{fig/01-problem}\\\relax
            [Problem]\\[1ex]
            \fbox{\parbox{0.8\textwidth}{\centering
              Hochsprache\\
              $\Uparrow$\\
              \structure{Semantische Lücke}\\
              $\Downarrow$\\
              CPU-Steuersignale
            }}\\[1ex]\relax
          [Ausführung]\\\relax
          \includegraphics[width=1.5cm]{fig/01-cpu}
          \end{center}
        \end{column}\hfill
        \begin{column}{0.6\textwidth}
          \bi
          \ii {Informatisches Urproblem:\\ Schließen der Semantischen Lücke}\bigskip
          \ii Komplexitätsreduktion durch Abstraktion {
            \bi
            \ii Hierarchisch angeordnete \structure{virtuelle Maschinen}
            \ii Definierte Schnittstellen nach oben
            \ii Schrittweise Vereinfachungen nach unten
            \ei
          }\bigskip
          \ii PSÜ: Zwei Sichtweisen {
            \bi
            \ii Top-Down: Was bieten Sprachen an?
            \ii Bottom-Up: Wie bildet ein Compiler das ab?
            \ei
          }
          \ei
        \end{column}
      \end{columns}
    \end{frame}


    \newcommand{\down}[2][1em]{\tikzmark{#2}\tikz[remember picture,overlay]\draw[>=latex',->,thick,srared] (pic cs:#2)--++(down:#1);}
    \begin{frame}[label=vm-hierarchie]
      \frametitle{Hierarchie virtueller Maschinen\,\cite[S.\,3]{tanenbaum:06:sco}}

      \begin{columns}
        \begin{column}{0.7\textwidth}
          \bi
          \ii Schrittweises Schließen der semantischen Lücke\\[2ex]{
            \begin{tabular}{cllc}
              Ebene & Abstraktion & \\\hline
              $n$ & virtuelle Maschine $M_n$ & Sprache $L_n$ & \down{a} \\ \hline
              $\vdots$ & \multicolumn{1}{c}{$\vdots$}  & \multicolumn{1}{c}{$\vdots$}&\down{x}\\[0.5ex] \hline
              $2$ & virtuelle Maschine $M_2$ & Sprache $L_2$ &\down{b}\\ \hline
              $1$ & virtuelle Maschine $M_1$ & Sprache $L_1$ &\down{c}\\ \hline
              $0$ & reale Maschine $M_0$ & Sprache $L_0$\\\hline
            \end{tabular}
          }\bigskip
          \ii {$L_x$-Program wird auf Maschine $M_{x-1}$ abgebildet
            \bi
            \ii \STRUCTURE{Dynamisch}: Interpreter als $L_{x-1}$-Program
            \ii \STRUCTURE{Statisch}: Compiler erzeugt $L_{x-1}$ Program\\
                Spätere Abbildung von $L_{x-1}$ auf $M_{x-2}$.
            \ei
          }
          \ei
        \end{column}\hfill
        \begin{column}{0.2\textwidth}
          \begin{tikzpicture}
            \foreach \x/\s in {0/0.7,1/0.8,2/0.9,3/1} {
              \node at (\x*1mm,-\x * 8mm) {
                \includegraphics[width=\s\textwidth]{fig/01-matroschka}
              };
            }
          \end{tikzpicture}
          \legalcode[commons=Dedoushka-no_bg.jpg]{CC BY-SA 3.0}{Dedoushka}
        \end{column}
      \end{columns}
    \end{frame}

    \begin{frame}[t,label=vm-hierarchie-beispiel]{Beispiel: Arbeitsplatzrechner}
      \animation[trim={\btLeftMargin} 0pt 0pt 0pt, width=\textwidth]{1/1,2/2}{fig/01-layers}
    \end{frame}

#+END_SRC

Virtuelle Maschinen

#+begin_src latex
  \begin{frame}[t]{"Virtuelle Maschinen"}
    \alert{Wichtig:} Wir meinen nicht VMWare, Virtualbox oder KVM.\bigskip

    \bi
    \ii Maschienenmodell der virtuellen Maschine {
      \bi
      \ii \structure{Speicher/Objekte}: Wie kann man Daten ablegen und wieder abrufen?
      \ii \structure{Befehle/Operationen}: Wie kann man Daten miteinander kombinieren?
      \ii Ein "\structure{Prozessor}" kann dieses Modell implementieren.
      \ei
    }\medskip
    \ii Maschinenprogramme {
      \bi
      \ii Eine Menge Befehlen, die gegen das Maschinenmodell geschrieben wurden.
      \ii Wird von einem Prozessor verarbeitet um ein Ergebnis zu berechnen.
      \ei
    }\medskip
    \ii Sprache der virtuellen Maschiene {
      \bi
      \ii Nicht jede Zeichenkette ist ein für jedes Maschinenmodell ein valides Program.
      \ii Synaktische und Semantische Regeln um valide Programme zu schreiben.
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[fragile,t]{Beispiel: Die (virtuelle) RISC-V Maschine}
    RISC-V ist eine Rechnerarchitektur, die an industrieller Relevanz gewinnt.\bigskip

    \bi
    \ii Maschinenmodell (RV32I) {
      \bi
      \ii \structure{Speicher}: 32 CPU Register + frei addressierbarer Speicher.
      \ii \structure{Befehle}: 47 Instruktionen mit arithmetischen, binären und Sprungbefehlen.
      \ii Der SweRV von Western Digital is \alert{ein} Prozessor für dieses Modell.
      \ei
    }\medskip
    \ii Beispiel eines Maschinenprograms: 02 b5 05 3b 80 82 \pause{
      \\{\scriptsize (Wir tun mal so als wäre Assembler und Binärcode das gleiche)}\smallskip
      \begin{code}[tag=RV32I]
        \begin{asm}[]
          multiply: # int multiply(int a, int b) { return a*b; }
              mul a0, a0, a1
              ret
        \end{asm}
      \end{code}
    }\medskip
    \ii Die RV32I Assemblersprache {
      \bi
      \ii Welche Mnemonics gibt es? Anzahl und Art der Argumente.
      \ii \texttt{add}: 1 Ziel- und 2 Quellregister; \texttt{addi}: 1 Zielregister und 12-Bit Ganzzahl
      \ii \enquote{\texttt{addi a0, a2, $\gamma_i$}} -- wäre nicht valide in der RV32I Sprache.
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[fragile,t]{Beispiel: Die virtuelle C Maschine}
    \bi
    \ii Maschinenmodell {
      \bi
      \ii \structure{Speicher}: Definierten Variablen und über Pointer erreichbarer Speicher
      \ii \structure{Befehle}: z.B: \lstinline{if (a < 3) return b * (c + d);}
      \ii Sowohl GCC als auch Clang sind \enquote{Prozessoren} für dieses Modell.
      \ii Es gibt auch C Interpreter die als Prozessoren agieren.
      \ei
    }\medskip
    \ii Beispielprogramm : Der Obfuscated Tiny C Compiler (2048 Zeichen)\footnote{\url{https://bellard.org/otcc/}}{
      \begin{code}[tag=C90]
        \lstinputlisting[basicstyle=\ttfamily\tiny, breaklines=true, postbreak=\mbox{}]{lst/01-otcc.c}
      \end{code}
    }\medskip
    \ii Die C Sprache (eigentlich eine ganze Familie von Sprachen) {
      \bi
      \ii Variablen und Funktionen müssen deklariert sein, um sie zu nutzen.
      \ii Eine Ganzzahl is kein valider Funktionsname.
      \ii \enquote{\texttt{"12345(b, c)}} -- is kein valides C Programm.
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}<1-2>{Definitionen}
    \btUseExtraItemSep \setbeamercovered{transparent}
    \begin{description}
    \item[Programmiersprache] Regelwerk zur Erstellung von Zeichenketten, die valide Programme für ein bestimmtes
      Maschinenmodell sind. Verletzt eine Zeichenkette auch nur eine dieser Regeln ist es kein entsprechendes Programm.
    \item<1>[Interpreter] Ein Programm das  Sprachprozessor für bestimmten Maschinenmodell ist und andere Programme direkt ausführt.
    \item[Übersetzer] Ebenfalls ein Sprachprozessor, der das gegebene Programm allerdings nicht ausführt, sondern in eine valides
      Maschinenprogramm für eine andere Sprache übersetzt.
    \end{description}
  \end{frame}

#+end_src

Beobachtbare Zustände

#+begin_src latex
  \begin{frame}{Beobachtbare Zustände und Zustandsfolgen}
    \structure{Frage:} Wann ist eine Übersetzung eigentlich korrekt?\bigskip

    \bi
    \ii Das Maschinenmodell bestimmt den beobachtbaren Zustand ($q_n$) {
      \bi
      \ii Bei RISC-V: Zustand ist der Registersatz nach jeder Instruktionen.
      \ii Wir werden keine halb ausgeführten Instruktionen sehen.
      \ii Definition des beobachtbaren Zustands ist schwer bei komplexeren Sprachen.
      \ei
    }\medskip
    \ii Programmausführung durch einen Prozessor ergibt eine Zustandfolge: \\
    $q = (q_1, q_2, \ldots, q_n)$ {
      \bi
      \ii Die Zustände sind vom Speicher der Maschine abgeleitet
      \ii Die Übergänge sind Folge von ausgeführten Operationen: $q_t\rightarrow q_{t+1}$
      \ei
    }
    \ei
    \medskip
    \includegraphics[page=1]{fig/01-zustand}
  \end{frame}


  \begin{frame}[fragile]{Beispiel einer Zustandsfolge}
    \bi
    \ii Berechnung des größten gemeinsamen Teilers {
      \bi
      \ii Wiederholte Subtraktion {
      \begin{columns}
        \begin{column}{0.4\textwidth}
          \begin{code}[tag=Py]
            \lstinputlisting[style=py,linerange=sub0-sub1]{lst/ggt.py}
          \end{code}
        \end{column}
        \hfill
        \begin{column}{0.4\textwidth}\ttfamily
          \begin{stdout}
          (i,j) = (7, 35)
                  (7, 28)
                  (7, 21)
                  (7, 14)
                  (7, 7)
          \end{stdout}
        \end{column}
      \end{columns}
       }\pause
    \ii Wiederholtes Modulo {
      \begin{columns}
        \begin{column}{0.4\textwidth}
          \begin{code}[tag=Py]
            \lstinputlisting[style=py,linerange=mod0-mod1]{lst/ggt.py}
          \end{code}
        \end{column}
        \hfill
        \begin{column}{0.4\textwidth}
          \begin{stdout}
          (i,j) = (7, 35)
                  (0, 7)
          \end{stdout}
        \end{column}
      \end{columns}
    }
    \ei }\medskip
    \ii Beide Programme brechnen das gleiche Ergebnis: ggT=7\\
        Sie zeigen aber unterschiedliche Zustandsfolgen.
        \ei
    \medskip
    \pause
    \structure{Frage:} Darf ein Übersetzer einen Algorithmus tauschen?
  \end{frame}

  \begin{frame}{Korrektheit einer Übersetzung}
    \bi
    \ii Die Programmiersprache definiert die \alert{beobachtbaren} Zustände. {
      \bi
      \ii Ein- und Ausgabe ist immer beobachtbar, oft aber auch Teile des Speichers
      \ii Bei C: Nur das Schreiben von globalen Variablen, nicht aber von Lokalen.
      \ei
    }\bigskip
    \ii Ein \advantage{korrekter} Übersetzer erhält alle beobachtbaren Zustände.{
      \bi
      \ii Es kann eine Abbildungsfunktion geben:\\[2ex]{
        \includegraphics[page=2,width=0.9\textwidth]{fig/01-zustand}
      }
      \ii Eine sehr absurder Übersetzer könnte alle beobachtbaren Bits invertieren.
      \ei
    }\bigskip
    \ii Grundlage von optimierenden Übersetzer! {
      \bi
      \ii Ein optimierender Übersetzer erhält nur den beobachtbaren Zustand.
      \ii Der nicht-beobachtbare Zustand kann sich beliebig ändern.
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[fragile,t]{Beispiele korrekter Übersetzung von C nach \only<1>{C}\only<2>{RISC-V}\only<3>{Kobold}}
    \begin{code}[tag=C]
      \begin{C}[]
        void foo() {
          int x = 0;
          x += 1; x += 1; x += 1;
          return x;
        }
      \end{C}
    \end{code}
    \begin{center}
      \Huge$\Downarrow$
    \end{center}
    \begin{code}<1>[tag=C]
      \begin{C}[]
        void foo() {
          return 3;
        }
      \end{C}
    \end{code}%
    \begin{code}<2>[tag={RV32I}]
      \begin{asm}[]
        foo:
          lui a0, 3
          ret
      \end{asm}
    \end{code}%
    \begin{code}<3>[tag={Kobold}]
      \begin{columns}
        \begin{column}{0.25\textwidth}
          \centering
          \includegraphics[height=3cm]{fig/01-cobold}
          \legalcode[commons=Kobold_artlibre_jnl.jpg]{Free Art License}{Jean-no}
        \end{column}\hfill
        \begin{column}{0.6\textwidth}
          \centering
          Dies ist ein besonders gut geschulter Kobold. Immer wenn man ihn irgendetwas fragt, wird er mit \ALERT{3} antworten.
        \end{column}
      \end{columns}
    \end{code}
  \end{frame}
#+end_src

* Bootstrapping und Cross-Compilation

#+begin_src latex
  \begin{frame}
    \Huge\centering
    Bootstrapping\\
    und\\
    Cross-Compilation
  \end{frame}

  \begin{frame}{Wer übersetzt den Übersetzer?}
    \bi
    \ii Woher kommt eigentlich der Übersetzter und wo läuft er? {
      \bi
      \ii Die allerersten Übersetzer von Programmen waren Menschen.
      \ii Wo sie herkommen: Evolution. Worauf sie laufen: Physik (wie der Kobold).
      \ei
    }
    \ii Wir wollen eine Übersetzer von L nach M der auf M läuft. {
    }
    \ei
  \end{frame}

#+end_src
Wo läuft eigentlich mein Übersetzer? Und wie komme ich zu ihm?

- T-Diagramme
- Übersetzung
